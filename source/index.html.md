---
title: API Reference

language_tabs:
  - shell
  - ruby
  - python
  - javascript

toc_footers:
  - <a href='#'>Sign Up for a Developer Key</a>
  - <a href='https://github.com/tripit/slate'>Documentation Powered by Slate</a>

includes:
  - errors

search: true
---

# Introduction

The Chai API is broken down by style or task.

## Assertion Styles

The Expect / Should API covers the BDD assertion styles.
The Assert API covers the TDD assertion style.

### Plugins

The Plugin API will be of use to anyone interested in building plugins as helpers to DRY up your tests, or for release to the community.

### Tools

The Online Test Suite is a live run of Chai’s test suite. Use it to ensure browser compatibility.

# Assert

The assert style is very similar to node.js’ included assert module, with a bit of extra sugar. 
Of the three style options, assert is the only one that is not chainable. Check out the [Style Guide](http://chaijs.com/guide/styles/) for a comparison.

## API Reference

### assert(expression, message)

* @param { Mixed } expression to test for truthiness
* @param { String } message to display on error
Write your own test expressions.

```javascript
assert('foo' !== 'bar', 'foo is not bar');
assert(Array.isArray([]), 'empty arrays are arrays');
```

### .fail(actual, expected, [message], [operator])

* @param { Mixed } actual
* @param { Mixed } expected
* @param { String } message
* @param { String } operator

Throw a failure. Node.js assert module-compatible.

### .isOk(object, [message])

* @param { Mixed } object to test
* @param { String } message
Asserts that object is truthy.

```javascript
assert.isOk('everything', 'everything is ok');
assert.isOk(false, 'this will fail');
```
chai
Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
Chai version
Assertion Error
Utils for plugins (not exported)
# .use(function)

Provides a way to extend the internals of Chai.
Utility Functions
Configuration
Primary `Assertion` prototype
Core Assertions
Expect interface
Should interface
Assert interface
chai
http://chaijs.com
Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
Module dependencies.
Module export.
Assertion Constructor

Creates object for chaining.

`Assertion` objects contain metadata in the form of flags. Three flags can
be assigned during instantiation by passing arguments to this constructor:

- `object`: This flag contains the target of the assertion. For example, in
  the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
  contain `numKittens` so that the `equal` assertion can reference it when
  needed.

- `message`: This flag contains an optional custom error message to be
  prepended to the error message that's generated by the assertion when it
  fails.

- `ssfi`: This flag stands for "start stack function indicator". It
  contains a function reference that serves as the starting point for
  removing frames from the stack trace of the error that's created by the
  assertion when it fails. The goal is to provide a cleaner stack trace to
  end users by removing Chai's internal functions. Note that it only works
  in environments that support `Error.captureStackTrace`, and only when
  `Chai.config.includeStack` hasn't been set to `false`.

- `lockSsfi`: This flag controls whether or not the given `ssfi` flag
  should retain its current value, even as assertions are chained off of
  this object. This is usually set to `true` when creating a new assertion
  from within another assertion. It's also temporarily set to `true` before
  an overwritten assertion gets called by the overwriting assertion.
### .assert(expression, message, negateMessage, expected, actual, showDiff)

Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
### ._obj

Quick reference to stored `actual` value for plugin developers.
### config.includeStack

User configurable property, influences whether stack trace
is included in Assertion error message. Default of false
suppresses stack trace in the error message.

    chai.config.includeStack = true;  // enable stack on error
### config.showDiff

User configurable property, influences whether or not
the `showDiff` flag should be included in the thrown
AssertionErrors. `false` will always be `false`; `true`
will be true when the assertion has requested a diff
be shown.
### config.truncateThreshold

User configurable property, sets length threshold for actual and
expected values in assertion errors. If this threshold is exceeded, for
example for large data structures, the value is replaced with something
like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.

Set it to zero if you want to disable truncating altogether.

This is especially userful when doing assertions on arrays: having this
set to a reasonable large value makes the failure messages readily
inspectable.

    chai.config.truncateThreshold = 0;  // disable truncating
### config.useProxy

User configurable property, defines if chai will use a Proxy to throw
an error when a non-existent property is read, which protects users
from typos when using property-based assertions.

Set it to false if you want to disable this feature.

    chai.config.useProxy = false;  // disable use of Proxy

This feature is automatically disabled regardless of this config value
in environments that don't support proxies.
### config.proxyExcludedKeys

User configurable property, defines which properties should be ignored
instead of throwing an error if they do not exist on the assertion.
This is only applied if the environment Chai is running in supports proxies and
if the `useProxy` configuration setting is enabled.
By default, `then` and `inspect` will not throw an error if they do not exist on the
assertion object because the `.inspect` property is read by `util.inspect` (for example, when
using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.

    // By default these keys will not throw an error if they do not exist on the assertion object
    chai.config.proxyExcludedKeys = ['then', 'inspect'];
chai
http://chaijs.com
Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### Language Chains

The following are provided as chainable getters to improve the readability
of your assertions.

**Chains**

- to
- be
- been
- is
- that
- which
- and
- has
- have
- with
- at
- of
- same
- but
- does
### .not

Negates all assertions that follow in the chain.

    expect(function () {}).to.not.throw();
    expect({a: 1}).to.not.have.property('b');
    expect([1, 2]).to.be.an('array').that.does.not.include(3);

Just because you can negate any assertion with `.not` doesn't mean you
should. With great power comes great responsibility. It's often best to
assert that the one expected output was produced, rather than asserting
that one of countless unexpected outputs wasn't produced. See individual
assertions for specific guidance.

    expect(2).to.equal(2); // Recommended
    expect(2).to.not.equal(1); // Not recommended
### .deep

Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`
assertions that follow in the chain to use deep equality instead of strict
(`===`) equality. See the `deep-eql` project page for info on the deep
equality algorithm: https://github.com/chaijs/deep-eql.

    // Target object deeply (but not strictly) equals `{a: 1}`
    expect({a: 1}).to.deep.equal({a: 1});
    expect({a: 1}).to.not.equal({a: 1});

    // Target array deeply (but not strictly) includes `{a: 1}`
    expect([{a: 1}]).to.deep.include({a: 1});
    expect([{a: 1}]).to.not.include({a: 1});

    // Target object deeply (but not strictly) includes `x: {a: 1}`
    expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
    expect({x: {a: 1}}).to.not.include({x: {a: 1}});

    // Target array deeply (but not strictly) has member `{a: 1}`
    expect([{a: 1}]).to.have.deep.members([{a: 1}]);
    expect([{a: 1}]).to.not.have.members([{a: 1}]);

    // Target set deeply (but not strictly) has key `{a: 1}`
    expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
    expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);

    // Target object deeply (but not strictly) has property `x: {a: 1}`
    expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
    expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
### .nested

Enables dot- and bracket-notation in all `.property` and `.include`
assertions that follow in the chain.

    expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
    expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});

If `.` or `[]` are part of an actual property name, they can be escaped by
adding two backslashes before them.

    expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
    expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});

`.nested` cannot be combined with `.own`.
### .own

Causes all `.property` and `.include` assertions that follow in the chain
to ignore inherited properties.

    Object.prototype.b = 2;

    expect({a: 1}).to.have.own.property('a');
    expect({a: 1}).to.have.property('b').but.not.own.property('b'); 

    expect({a: 1}).to.own.include({a: 1});
    expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});

`.own` cannot be combined with `.nested`.
### .ordered

Causes all `.members` assertions that follow in the chain to require that
members be in the same order.

    expect([1, 2]).to.have.ordered.members([1, 2])
      .but.not.have.ordered.members([2, 1]);

When `.include` and `.ordered` are combined, the ordering begins at the
start of both arrays.

    expect([1, 2, 3]).to.include.ordered.members([1, 2])
      .but.not.include.ordered.members([2, 3]);
### .any

Causes all `.keys` assertions that follow in the chain to only require that
the target have at least one of the given keys. This is the opposite of
`.all`, which requires that the target have all of the given keys.

    expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');

See the `.keys` doc for guidance on when to use `.any` or `.all`.
### .all

Causes all `.keys` assertions that follow in the chain to require that the
target have all of the given keys. This is the opposite of `.any`, which
only requires that the target have at least one of the given keys.

    expect({a: 1, b: 2}).to.have.all.keys('a', 'b');

Note that `.all` is used by default when neither `.all` nor `.any` are
added earlier in the chain. However, it's often best to add `.all` anyway
because it improves readability.

See the `.keys` doc for guidance on when to use `.any` or `.all`.
### .a(type[, msg])

Asserts that the target's type is equal to the given string `type`. Types
are case insensitive. See the `type-detect` project page for info on the
type detection algorithm: https://github.com/chaijs/type-detect.

    expect('foo').to.be.a('string');
    expect({a: 1}).to.be.an('object');
    expect(null).to.be.a('null');
    expect(undefined).to.be.an('undefined');
    expect(new Error).to.be.an('error');
    expect(Promise.resolve()).to.be.a('promise');
    expect(new Float32Array).to.be.a('float32array');
    expect(Symbol()).to.be.a('symbol');

`.a` supports objects that have a custom type set via `Symbol.toStringTag`.

    var myObj = {
      [Symbol.toStringTag]: 'myCustomType'
    };

    expect(myObj).to.be.a('myCustomType').but.not.an('object');

It's often best to use `.a` to check a target's type before making more
assertions on the same target. That way, you avoid unexpected behavior from
any assertion that does different things based on the target's type.

    expect([1, 2, 3]).to.be.an('array').that.includes(2);
    expect([]).to.be.an('array').that.is.empty;

Add `.not` earlier in the chain to negate `.a`. However, it's often best to
assert that the target is the expected type, rather than asserting that it
isn't one of many unexpected types.

    expect('foo').to.be.a('string'); // Recommended
    expect('foo').to.not.be.an('array'); // Not recommended

`.a` accepts an optional `msg` argument which is a custom error message to
show when the assertion fails. The message can also be given as the second
argument to `expect`.

    expect(1).to.be.a('string', 'nooo why fail??');
    expect(1, 'nooo why fail??').to.be.a('string');

`.a` can also be used as a language chain to improve the readability of
your assertions. 

    expect({b: 2}).to.have.a.property('b');

The alias `.an` can be used interchangeably with `.a`.
### .include(val[, msg])

When the target is a string, `.include` asserts that the given string `val`
is a substring of the target.

    expect('foobar').to.include('foo');

When the target is an array, `.include` asserts that the given `val` is a
member of the target.

    expect([1, 2, 3]).to.include(2);

When the target is an object, `.include` asserts that the given object
`val`'s properties are a subset of the target's properties.

    expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});

When the target is a Set or WeakSet, `.include` asserts that the given `val` is a
member of the target. SameValueZero equality algorithm is used.

    expect(new Set([1, 2])).to.include(2);

When the target is a Map, `.include` asserts that the given `val` is one of
the values of the target. SameValueZero equality algorithm is used.

    expect(new Map([['a', 1], ['b', 2]])).to.include(2);

Because `.include` does different things based on the target's type, it's
important to check the target's type before using `.include`. See the `.a`
doc for info on testing a target's type.

    expect([1, 2, 3]).to.be.an('array').that.includes(2);

By default, strict (`===`) equality is used to compare array members and
object properties. Add `.deep` earlier in the chain to use deep equality
instead (WeakSet targets are not supported). See the `deep-eql` project
page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.

    // Target array deeply (but not strictly) includes `{a: 1}`
    expect([{a: 1}]).to.deep.include({a: 1});
    expect([{a: 1}]).to.not.include({a: 1});

    // Target object deeply (but not strictly) includes `x: {a: 1}`
    expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
    expect({x: {a: 1}}).to.not.include({x: {a: 1}});

By default, all of the target's properties are searched when working with
objects. This includes properties that are inherited and/or non-enumerable.
Add `.own` earlier in the chain to exclude the target's inherited
properties from the search.

    Object.prototype.b = 2;

    expect({a: 1}).to.own.include({a: 1});
    expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});

Note that a target object is always only searched for `val`'s own
enumerable properties.

`.deep` and `.own` can be combined.

    expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});

Add `.nested` earlier in the chain to enable dot- and bracket-notation when
referencing nested properties.

    expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});

If `.` or `[]` are part of an actual property name, they can be escaped by
adding two backslashes before them.

    expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});

`.deep` and `.nested` can be combined.

    expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});

`.own` and `.nested` cannot be combined.

Add `.not` earlier in the chain to negate `.include`.

    expect('foobar').to.not.include('taco');
    expect([1, 2, 3]).to.not.include(4);

However, it's dangerous to negate `.include` when the target is an object.
The problem is that it creates uncertain expectations by asserting that the
target object doesn't have all of `val`'s key/value pairs but may or may
not have some of them. It's often best to identify the exact output that's
expected, and then write an assertion that only accepts that exact output.

When the target object isn't even expected to have `val`'s keys, it's
often best to assert exactly that.

    expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
    expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended

When the target object is expected to have `val`'s keys, it's often best to
assert that each of the properties has its expected value, rather than
asserting that each property doesn't have one of many unexpected values.

    expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
    expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended

`.include` accepts an optional `msg` argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to `expect`.

    expect([1, 2, 3]).to.include(4, 'nooo why fail??');
    expect([1, 2, 3], 'nooo why fail??').to.include(4);

`.include` can also be used as a language chain, causing all `.members` and
`.keys` assertions that follow in the chain to require the target to be a
superset of the expected set, rather than an identical set. Note that
`.members` ignores duplicates in the subset when `.include` is added.

    // Target object's keys are a superset of ['a', 'b'] but not identical
    expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
    expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');

    // Target array is a superset of [1, 2] but not identical
    expect([1, 2, 3]).to.include.members([1, 2]);
    expect([1, 2, 3]).to.not.have.members([1, 2]);

    // Duplicates in the subset are ignored
    expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);

Note that adding `.any` earlier in the chain causes the `.keys` assertion
to ignore `.include`.

    // Both assertions are identical
    expect({a: 1}).to.include.any.keys('a', 'b');
    expect({a: 1}).to.have.any.keys('a', 'b');

The aliases `.includes`, `.contain`, and `.contains` can be used
interchangeably with `.include`.
### .ok

Asserts that the target is loosely (`==`) equal to `true`. However, it's
often best to assert that the target is strictly (`===`) or deeply equal to
its expected value.

    expect(1).to.equal(1); // Recommended
    expect(1).to.be.ok; // Not recommended

    expect(true).to.be.true; // Recommended
    expect(true).to.be.ok; // Not recommended

Add `.not` earlier in the chain to negate `.ok`.

    expect(0).to.equal(0); // Recommended
    expect(0).to.not.be.ok; // Not recommended

    expect(false).to.be.false; // Recommended
    expect(false).to.not.be.ok; // Not recommended

    expect(null).to.be.null; // Recommended
    expect(null).to.not.be.ok; // Not recommended

    expect(undefined).to.be.undefined; // Recommended
    expect(undefined).to.not.be.ok; // Not recommended

A custom error message can be given as the second argument to `expect`.

    expect(false, 'nooo why fail??').to.be.ok;
### .true

Asserts that the target is strictly (`===`) equal to `true`.

    expect(true).to.be.true;

Add `.not` earlier in the chain to negate `.true`. However, it's often best
to assert that the target is equal to its expected value, rather than not
equal to `true`.

    expect(false).to.be.false; // Recommended
    expect(false).to.not.be.true; // Not recommended

    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.true; // Not recommended

A custom error message can be given as the second argument to `expect`.

    expect(false, 'nooo why fail??').to.be.true;
### .false

Asserts that the target is strictly (`===`) equal to `false`.

    expect(false).to.be.false;

Add `.not` earlier in the chain to negate `.false`. However, it's often
best to assert that the target is equal to its expected value, rather than
not equal to `false`.

    expect(true).to.be.true; // Recommended
    expect(true).to.not.be.false; // Not recommended

    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.false; // Not recommended

A custom error message can be given as the second argument to `expect`.

    expect(true, 'nooo why fail??').to.be.false;
### .null

Asserts that the target is strictly (`===`) equal to `null`.

    expect(null).to.be.null;

Add `.not` earlier in the chain to negate `.null`. However, it's often best
to assert that the target is equal to its expected value, rather than not
equal to `null`.

    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.null; // Not recommended

A custom error message can be given as the second argument to `expect`.

    expect(42, 'nooo why fail??').to.be.null;
### .undefined

Asserts that the target is strictly (`===`) equal to `undefined`.

    expect(undefined).to.be.undefined;

Add `.not` earlier in the chain to negate `.undefined`. However, it's often
best to assert that the target is equal to its expected value, rather than
not equal to `undefined`.

    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.undefined; // Not recommended

A custom error message can be given as the second argument to `expect`.

    expect(42, 'nooo why fail??').to.be.undefined;
### .NaN

Asserts that the target is exactly `NaN`.

    expect(NaN).to.be.NaN;

Add `.not` earlier in the chain to negate `.NaN`. However, it's often best
to assert that the target is equal to its expected value, rather than not
equal to `NaN`.

    expect('foo').to.equal('foo'); // Recommended
    expect('foo').to.not.be.NaN; // Not recommended

A custom error message can be given as the second argument to `expect`.

    expect(42, 'nooo why fail??').to.be.NaN;
### .exist

Asserts that the target is not strictly (`===`) equal to either `null` or
`undefined`. However, it's often best to assert that the target is equal to
its expected value.

    expect(1).to.equal(1); // Recommended
    expect(1).to.exist; // Not recommended

    expect(0).to.equal(0); // Recommended
    expect(0).to.exist; // Not recommended

Add `.not` earlier in the chain to negate `.exist`.

    expect(null).to.be.null; // Recommended
    expect(null).to.not.exist; // Not recommended

    expect(undefined).to.be.undefined; // Recommended
    expect(undefined).to.not.exist; // Not recommended

A custom error message can be given as the second argument to `expect`.

    expect(null, 'nooo why fail??').to.exist;
### .empty

When the target is a string or array, `.empty` asserts that the target's
`length` property is strictly (`===`) equal to `0`.

    expect([]).to.be.empty;
    expect('').to.be.empty;

When the target is a map or set, `.empty` asserts that the target's `size`
property is strictly equal to `0`.

    expect(new Set()).to.be.empty;
    expect(new Map()).to.be.empty;

When the target is a non-function object, `.empty` asserts that the target
doesn't have any own enumerable properties. Properties with Symbol-based
keys are excluded from the count.

    expect({}).to.be.empty;

Because `.empty` does different things based on the target's type, it's
important to check the target's type before using `.empty`. See the `.a`
doc for info on testing a target's type.

    expect([]).to.be.an('array').that.is.empty;

Add `.not` earlier in the chain to negate `.empty`. However, it's often
best to assert that the target contains its expected number of values,
rather than asserting that it's not empty.

    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.not.be.empty; // Not recommended

    expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
    expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended

    expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
    expect({a: 1}).to.not.be.empty; // Not recommended

A custom error message can be given as the second argument to `expect`.

    expect([1, 2, 3], 'nooo why fail??').to.be.empty;
### .arguments

Asserts that the target is an `arguments` object.

    function test () {
      expect(arguments).to.be.arguments;
    }

    test();

Add `.not` earlier in the chain to negate `.arguments`. However, it's often
best to assert which type the target is expected to be, rather than
asserting that its not an `arguments` object.

    expect('foo').to.be.a('string'); // Recommended
    expect('foo').to.not.be.arguments; // Not recommended

A custom error message can be given as the second argument to `expect`.

    expect({}, 'nooo why fail??').to.be.arguments;

The alias `.Arguments` can be used interchangeably with `.arguments`.
### .equal(val[, msg])

Asserts that the target is strictly (`===`) equal to the given `val`.

    expect(1).to.equal(1);
    expect('foo').to.equal('foo');

Add `.deep` earlier in the chain to use deep equality instead. See the
`deep-eql` project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.

    // Target object deeply (but not strictly) equals `{a: 1}`
    expect({a: 1}).to.deep.equal({a: 1});
    expect({a: 1}).to.not.equal({a: 1});

    // Target array deeply (but not strictly) equals `[1, 2]`
    expect([1, 2]).to.deep.equal([1, 2]);
    expect([1, 2]).to.not.equal([1, 2]);

Add `.not` earlier in the chain to negate `.equal`. However, it's often
best to assert that the target is equal to its expected value, rather than
not equal to one of countless unexpected values.

    expect(1).to.equal(1); // Recommended
    expect(1).to.not.equal(2); // Not recommended

`.equal` accepts an optional `msg` argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to `expect`.

    expect(1).to.equal(2, 'nooo why fail??');
    expect(1, 'nooo why fail??').to.equal(2);

The aliases `.equals` and `eq` can be used interchangeably with `.equal`.
### .eql(obj[, msg])

Asserts that the target is deeply equal to the given `obj`. See the
`deep-eql` project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.

    // Target object is deeply (but not strictly) equal to {a: 1}
    expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});

    // Target array is deeply (but not strictly) equal to [1, 2]
    expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);

Add `.not` earlier in the chain to negate `.eql`. However, it's often best
to assert that the target is deeply equal to its expected value, rather
than not deeply equal to one of countless unexpected values.

    expect({a: 1}).to.eql({a: 1}); // Recommended
    expect({a: 1}).to.not.eql({b: 2}); // Not recommended

`.eql` accepts an optional `msg` argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to `expect`.

    expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
    expect({a: 1}, 'nooo why fail??').to.eql({b: 2});

The alias `.eqls` can be used interchangeably with `.eql`.

The `.deep.equal` assertion is almost identical to `.eql` but with one
difference: `.deep.equal` causes deep equality comparisons to also be used
for any other assertions that follow in the chain.
### .above(n[, msg])

Asserts that the target is a number or a date greater than the given number or date `n` respectively.
However, it's often best to assert that the target is equal to its expected
value.

    expect(2).to.equal(2); // Recommended
    expect(2).to.be.above(1); // Not recommended

Add `.lengthOf` earlier in the chain to assert that the value of the
target's `length` property is greater than the given number `n`.

    expect('foo').to.have.lengthOf(3); // Recommended
    expect('foo').to.have.lengthOf.above(2); // Not recommended

    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended

Add `.not` earlier in the chain to negate `.above`.

    expect(2).to.equal(2); // Recommended
    expect(1).to.not.be.above(2); // Not recommended

`.above` accepts an optional `msg` argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to `expect`.

    expect(1).to.be.above(2, 'nooo why fail??');
    expect(1, 'nooo why fail??').to.be.above(2);

The aliases `.gt` and `.greaterThan` can be used interchangeably with
`.above`.
### .least(n[, msg])

Asserts that the target is a number or a date greater than or equal to the given
number or date `n` respectively. However, it's often best to assert that the target is equal to
its expected value.

    expect(2).to.equal(2); // Recommended
    expect(2).to.be.at.least(1); // Not recommended
    expect(2).to.be.at.least(2); // Not recommended

Add `.lengthOf` earlier in the chain to assert that the value of the
target's `length` property is greater than or equal to the given number
`n`.

    expect('foo').to.have.lengthOf(3); // Recommended
    expect('foo').to.have.lengthOf.at.least(2); // Not recommended

    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended

Add `.not` earlier in the chain to negate `.least`.

    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.at.least(2); // Not recommended

`.least` accepts an optional `msg` argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to `expect`.

    expect(1).to.be.at.least(2, 'nooo why fail??');
    expect(1, 'nooo why fail??').to.be.at.least(2);

The alias `.gte` can be used interchangeably with `.least`.
### .below(n[, msg])

Asserts that the target is a number or a date less than the given number or date `n` respectively.
However, it's often best to assert that the target is equal to its expected
value.

    expect(1).to.equal(1); // Recommended
    expect(1).to.be.below(2); // Not recommended

Add `.lengthOf` earlier in the chain to assert that the value of the
target's `length` property is less than the given number `n`.

    expect('foo').to.have.lengthOf(3); // Recommended
    expect('foo').to.have.lengthOf.below(4); // Not recommended

    expect([1, 2, 3]).to.have.length(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended

Add `.not` earlier in the chain to negate `.below`.

    expect(2).to.equal(2); // Recommended
    expect(2).to.not.be.below(1); // Not recommended

`.below` accepts an optional `msg` argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to `expect`.

    expect(2).to.be.below(1, 'nooo why fail??');
    expect(2, 'nooo why fail??').to.be.below(1);

The aliases `.lt` and `.lessThan` can be used interchangeably with
`.below`.
### .most(n[, msg])

Asserts that the target is a number or a date less than or equal to the given number
or date `n` respectively. However, it's often best to assert that the target is equal to its
expected value.

    expect(1).to.equal(1); // Recommended
    expect(1).to.be.at.most(2); // Not recommended
    expect(1).to.be.at.most(1); // Not recommended

Add `.lengthOf` earlier in the chain to assert that the value of the
target's `length` property is less than or equal to the given number `n`.

    expect('foo').to.have.lengthOf(3); // Recommended
    expect('foo').to.have.lengthOf.at.most(4); // Not recommended

    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended

Add `.not` earlier in the chain to negate `.most`.

    expect(2).to.equal(2); // Recommended
    expect(2).to.not.be.at.most(1); // Not recommended

`.most` accepts an optional `msg` argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to `expect`.

    expect(2).to.be.at.most(1, 'nooo why fail??');
    expect(2, 'nooo why fail??').to.be.at.most(1);

The alias `.lte` can be used interchangeably with `.most`.
### .within(start, finish[, msg])

Asserts that the target is a number or a date greater than or equal to the given
number or date `start`, and less than or equal to the given number or date `finish` respectively.
However, it's often best to assert that the target is equal to its expected
value.

    expect(2).to.equal(2); // Recommended
    expect(2).to.be.within(1, 3); // Not recommended
    expect(2).to.be.within(2, 3); // Not recommended
    expect(2).to.be.within(1, 2); // Not recommended

Add `.lengthOf` earlier in the chain to assert that the value of the
target's `length` property is greater than or equal to the given number
`start`, and less than or equal to the given number `finish`.

    expect('foo').to.have.lengthOf(3); // Recommended
    expect('foo').to.have.lengthOf.within(2, 4); // Not recommended

    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended

Add `.not` earlier in the chain to negate `.within`.

    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.within(2, 4); // Not recommended

`.within` accepts an optional `msg` argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to `expect`.

    expect(4).to.be.within(1, 3, 'nooo why fail??');
    expect(4, 'nooo why fail??').to.be.within(1, 3);
### .instanceof(constructor[, msg])

Asserts that the target is an instance of the given `constructor`.

    function Cat () { }

    expect(new Cat()).to.be.an.instanceof(Cat);
    expect([1, 2]).to.be.an.instanceof(Array);

Add `.not` earlier in the chain to negate `.instanceof`.

    expect({a: 1}).to.not.be.an.instanceof(Array);

`.instanceof` accepts an optional `msg` argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to `expect`.

    expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
    expect(1, 'nooo why fail??').to.be.an.instanceof(Array);

Due to limitations in ES5, `.instanceof` may not always work as expected
when using a transpiler such as Babel or TypeScript. In particular, it may
produce unexpected results when subclassing built-in object such as
`Array`, `Error`, and `Map`. See your transpiler's docs for details:

- ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
- ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))

The alias `.instanceOf` can be used interchangeably with `.instanceof`.
### .property(name[, val[, msg]])

Asserts that the target has a property with the given key `name`.

    expect({a: 1}).to.have.property('a');

When `val` is provided, `.property` also asserts that the property's value
is equal to the given `val`.

    expect({a: 1}).to.have.property('a', 1);

By default, strict (`===`) equality is used. Add `.deep` earlier in the
chain to use deep equality instead. See the `deep-eql` project page for
info on the deep equality algorithm: https://github.com/chaijs/deep-eql.

    // Target object deeply (but not strictly) has property `x: {a: 1}`
    expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
    expect({x: {a: 1}}).to.not.have.property('x', {a: 1});

The target's enumerable and non-enumerable properties are always included
in the search. By default, both own and inherited properties are included.
Add `.own` earlier in the chain to exclude inherited properties from the
search.

    Object.prototype.b = 2;

    expect({a: 1}).to.have.own.property('a');
    expect({a: 1}).to.have.own.property('a', 1);
    expect({a: 1}).to.have.property('b').but.not.own.property('b'); 

`.deep` and `.own` can be combined.

    expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});

Add `.nested` earlier in the chain to enable dot- and bracket-notation when
referencing nested properties.

    expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
    expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');

If `.` or `[]` are part of an actual property name, they can be escaped by
adding two backslashes before them.

    expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');

`.deep` and `.nested` can be combined.

    expect({a: {b: [{c: 3}]}})
      .to.have.deep.nested.property('a.b[0]', {c: 3});

`.own` and `.nested` cannot be combined.

Add `.not` earlier in the chain to negate `.property`.

    expect({a: 1}).to.not.have.property('b');

However, it's dangerous to negate `.property` when providing `val`. The
problem is that it creates uncertain expectations by asserting that the
target either doesn't have a property with the given key `name`, or that it
does have a property with the given key `name` but its value isn't equal to
the given `val`. It's often best to identify the exact output that's
expected, and then write an assertion that only accepts that exact output.

When the target isn't expected to have a property with the given key
`name`, it's often best to assert exactly that.

    expect({b: 2}).to.not.have.property('a'); // Recommended
    expect({b: 2}).to.not.have.property('a', 1); // Not recommended

When the target is expected to have a property with the given key `name`,
it's often best to assert that the property has its expected value, rather
than asserting that it doesn't have one of many unexpected values.

    expect({a: 3}).to.have.property('a', 3); // Recommended
    expect({a: 3}).to.not.have.property('a', 1); // Not recommended

`.property` changes the target of any assertions that follow in the chain
to be the value of the property from the original target object.

    expect({a: 1}).to.have.property('a').that.is.a('number');

`.property` accepts an optional `msg` argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to `expect`. When not providing `val`, only use the
second form.

    // Recommended
    expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
    expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
    expect({a: 1}, 'nooo why fail??').to.have.property('b');

    // Not recommended
    expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');

The above assertion isn't the same thing as not providing `val`. Instead,
it's asserting that the target object has a `b` property that's equal to
`undefined`.

The assertions `.ownProperty` and `.haveOwnProperty` can be used
interchangeably with `.own.property`.
### .ownPropertyDescriptor(name[, descriptor[, msg]])

Asserts that the target has its own property descriptor with the given key
`name`. Enumerable and non-enumerable properties are included in the
search.

    expect({a: 1}).to.have.ownPropertyDescriptor('a');

When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that
the property's descriptor is deeply equal to the given `descriptor`. See
the `deep-eql` project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.

    expect({a: 1}).to.have.ownPropertyDescriptor('a', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 1,
    });

Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.

    expect({a: 1}).to.not.have.ownPropertyDescriptor('b');

However, it's dangerous to negate `.ownPropertyDescriptor` when providing
a `descriptor`. The problem is that it creates uncertain expectations by
asserting that the target either doesn't have a property descriptor with
the given key `name`, or that it does have a property descriptor with the
given key `name` but its not deeply equal to the given `descriptor`. It's
often best to identify the exact output that's expected, and then write an
assertion that only accepts that exact output.

When the target isn't expected to have a property descriptor with the given
key `name`, it's often best to assert exactly that.

    // Recommended
    expect({b: 2}).to.not.have.ownPropertyDescriptor('a');

    // Not recommended
    expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 1,
    });

When the target is expected to have a property descriptor with the given
key `name`, it's often best to assert that the property has its expected
descriptor, rather than asserting that it doesn't have one of many
unexpected descriptors.

    // Recommended
    expect({a: 3}).to.have.ownPropertyDescriptor('a', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 3,
    });

    // Not recommended
    expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 1,
    });

`.ownPropertyDescriptor` changes the target of any assertions that follow
in the chain to be the value of the property descriptor from the original
target object.

    expect({a: 1}).to.have.ownPropertyDescriptor('a')
      .that.has.property('enumerable', true);

`.ownPropertyDescriptor` accepts an optional `msg` argument which is a
custom error message to show when the assertion fails. The message can also
be given as the second argument to `expect`. When not providing
`descriptor`, only use the second form.

    // Recommended
    expect({a: 1}).to.have.ownPropertyDescriptor('a', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 2,
    }, 'nooo why fail??');

    // Recommended
    expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 2,
    });

    // Recommended
    expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');

    // Not recommended
    expect({a: 1})
      .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');

The above assertion isn't the same thing as not providing `descriptor`.
Instead, it's asserting that the target object has a `b` property
descriptor that's deeply equal to `undefined`.

The alias `.haveOwnPropertyDescriptor` can be used interchangeably with
`.ownPropertyDescriptor`.
### .lengthOf(n[, msg])

Asserts that the target's `length` property is equal to the given number
`n`.

    expect([1, 2, 3]).to.have.lengthOf(3);
    expect('foo').to.have.lengthOf(3);

Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often
best to assert that the target's `length` property is equal to its expected
value, rather than not equal to one of many unexpected values.

    expect('foo').to.have.lengthOf(3); // Recommended
    expect('foo').to.not.have.lengthOf(4); // Not recommended

`.lengthOf` accepts an optional `msg` argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to `expect`.

    expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
    expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);

`.lengthOf` can also be used as a language chain, causing all `.above`,
`.below`, `.least`, `.most`, and `.within` assertions that follow in the
chain to use the target's `length` property as the target. However, it's
often best to assert that the target's `length` property is equal to its
expected length, rather than asserting that its `length` property falls
within some range of values.

    // Recommended
    expect([1, 2, 3]).to.have.lengthOf(3);

    // Not recommended
    expect([1, 2, 3]).to.have.lengthOf.above(2);
    expect([1, 2, 3]).to.have.lengthOf.below(4);
    expect([1, 2, 3]).to.have.lengthOf.at.least(3);
    expect([1, 2, 3]).to.have.lengthOf.at.most(3);
    expect([1, 2, 3]).to.have.lengthOf.within(2,4);

Due to a compatibility issue, the alias `.length` can't be chained directly
off of an uninvoked method such as `.a`. Therefore, `.length` can't be used
interchangeably with `.lengthOf` in every situation. It's recommended to
always use `.lengthOf` instead of `.length`.

    expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
    expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
### .match(re[, msg])

Asserts that the target matches the given regular expression `re`.

    expect('foobar').to.match(/^foo/);

Add `.not` earlier in the chain to negate `.match`.

    expect('foobar').to.not.match(/taco/);

`.match` accepts an optional `msg` argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to `expect`.

    expect('foobar').to.match(/taco/, 'nooo why fail??');
    expect('foobar', 'nooo why fail??').to.match(/taco/);

The alias `.matches` can be used interchangeably with `.match`.
### .string(str[, msg])

Asserts that the target string contains the given substring `str`.

    expect('foobar').to.have.string('bar');

Add `.not` earlier in the chain to negate `.string`.

    expect('foobar').to.not.have.string('taco');

`.string` accepts an optional `msg` argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to `expect`.

    expect('foobar').to.have.string(/taco/, 'nooo why fail??');
    expect('foobar', 'nooo why fail??').to.have.string(/taco/);
### .keys(key1[, key2[, ...]])

Asserts that the target object, array, map, or set has the given keys. Only
the target's own inherited properties are included in the search. 

When the target is an object or array, keys can be provided as one or more
string arguments, a single array argument, or a single object argument. In
the latter case, only the keys in the given object matter; the values are
ignored.

    expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
    expect(['x', 'y']).to.have.all.keys(0, 1);

    expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
    expect(['x', 'y']).to.have.all.keys([0, 1]);

    expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
    expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5

When the target is a map or set, each key must be provided as a separate
argument.

    expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
    expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');

Because `.keys` does different things based on the target's type, it's
important to check the target's type before using `.keys`. See the `.a` doc
for info on testing a target's type.

    expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');

By default, strict (`===`) equality is used to compare keys of maps and
sets. Add `.deep` earlier in the chain to use deep equality instead. See
the `deep-eql` project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.

    // Target set deeply (but not strictly) has key `{a: 1}`
    expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
    expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);

By default, the target must have all of the given keys and no more. Add
`.any` earlier in the chain to only require that the target have at least
one of the given keys. Also, add `.not` earlier in the chain to negate
`.keys`. It's often best to add `.any` when negating `.keys`, and to use
`.all` when asserting `.keys` without negation.

When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts
exactly what's expected of the output, whereas `.not.all.keys` creates
uncertain expectations.

    // Recommended; asserts that target doesn't have any of the given keys
    expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');

    // Not recommended; asserts that target doesn't have all of the given
    // keys but may or may not have some of them
    expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');

When asserting `.keys` without negation, `.all` is preferred because
`.all.keys` asserts exactly what's expected of the output, whereas
`.any.keys` creates uncertain expectations.

    // Recommended; asserts that target has all the given keys
    expect({a: 1, b: 2}).to.have.all.keys('a', 'b');

    // Not recommended; asserts that target has at least one of the given
    // keys but may or may not have more of them
    expect({a: 1, b: 2}).to.have.any.keys('a', 'b');

Note that `.all` is used by default when neither `.all` nor `.any` appear
earlier in the chain. However, it's often best to add `.all` anyway because
it improves readability.

    // Both assertions are identical
    expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
    expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended

Add `.include` earlier in the chain to require that the target's keys be a
superset of the expected keys, rather than identical sets.

    // Target object's keys are a superset of ['a', 'b'] but not identical
    expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
    expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');

However, if `.any` and `.include` are combined, only the `.any` takes
effect. The `.include` is ignored in this case.

    // Both assertions are identical
    expect({a: 1}).to.have.any.keys('a', 'b');
    expect({a: 1}).to.include.any.keys('a', 'b');

A custom error message can be given as the second argument to `expect`.

    expect({a: 1}, 'nooo why fail??').to.have.key('b');

The alias `.key` can be used interchangeably with `.keys`.
### .throw([errorLike], [errMsgMatcher], [msg])

When no arguments are provided, `.throw` invokes the target function and
asserts that an error is thrown.

    var badFn = function () { throw new TypeError('Illegal salmon!'); };

    expect(badFn).to.throw();

When one argument is provided, and it's an error constructor, `.throw`
invokes the target function and asserts that an error is thrown that's an
instance of that error constructor.

    var badFn = function () { throw new TypeError('Illegal salmon!'); };

    expect(badFn).to.throw(TypeError);

When one argument is provided, and it's an error instance, `.throw` invokes
the target function and asserts that an error is thrown that's strictly
(`===`) equal to that error instance.

    var err = new TypeError('Illegal salmon!');
    var badFn = function () { throw err; };

    expect(badFn).to.throw(err);

When one argument is provided, and it's a string, `.throw` invokes the
target function and asserts that an error is thrown with a message that
contains that string.

    var badFn = function () { throw new TypeError('Illegal salmon!'); };

    expect(badFn).to.throw('salmon');

When one argument is provided, and it's a regular expression, `.throw`
invokes the target function and asserts that an error is thrown with a
message that matches that regular expression.

    var badFn = function () { throw new TypeError('Illegal salmon!'); };

    expect(badFn).to.throw(/salmon/);

When two arguments are provided, and the first is an error instance or
constructor, and the second is a string or regular expression, `.throw`
invokes the function and asserts that an error is thrown that fulfills both
conditions as described above.

    var err = new TypeError('Illegal salmon!');
    var badFn = function () { throw err; };

    expect(badFn).to.throw(TypeError, 'salmon');
    expect(badFn).to.throw(TypeError, /salmon/);
    expect(badFn).to.throw(err, 'salmon');
    expect(badFn).to.throw(err, /salmon/);

Add `.not` earlier in the chain to negate `.throw`.
    
    var goodFn = function () {};

    expect(goodFn).to.not.throw();

However, it's dangerous to negate `.throw` when providing any arguments.
The problem is that it creates uncertain expectations by asserting that the
target either doesn't throw an error, or that it throws an error but of a
different type than the given type, or that it throws an error of the given
type but with a message that doesn't include the given string. It's often
best to identify the exact output that's expected, and then write an
assertion that only accepts that exact output.

When the target isn't expected to throw an error, it's often best to assert
exactly that.

    var goodFn = function () {};

    expect(goodFn).to.not.throw(); // Recommended
    expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended

When the target is expected to throw an error, it's often best to assert
that the error is of its expected type, and has a message that includes an
expected string, rather than asserting that it doesn't have one of many
unexpected types, and doesn't have a message that includes some string.

    var badFn = function () { throw new TypeError('Illegal salmon!'); };

    expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
    expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended

`.throw` changes the target of any assertions that follow in the chain to
be the error object that's thrown.

    var err = new TypeError('Illegal salmon!');
    err.code = 42;
    var badFn = function () { throw err; };

    expect(badFn).to.throw(TypeError).with.property('code', 42);

`.throw` accepts an optional `msg` argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to `expect`. When not providing two arguments, always use
the second form.

    var goodFn = function () {};

    expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
    expect(goodFn, 'nooo why fail??').to.throw();

Due to limitations in ES5, `.throw` may not always work as expected when
using a transpiler such as Babel or TypeScript. In particular, it may
produce unexpected results when subclassing the built-in `Error` object and
then passing the subclassed constructor to `.throw`. See your transpiler's
docs for details:

- ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
- ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))

Beware of some common mistakes when using the `throw` assertion. One common
mistake is to accidentally invoke the function yourself instead of letting
the `throw` assertion invoke the function for you. For example, when
testing if a function named `fn` throws, provide `fn` instead of `fn()` as
the target for the assertion.

    expect(fn).to.throw();     // Good! Tests `fn` as desired
    expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`

If you need to assert that your function `fn` throws when passed certain
arguments, then wrap a call to `fn` inside of another function.

    expect(function () { fn(42); }).to.throw();  // Function expression
    expect(() => fn(42)).to.throw();             // ES6 arrow function

Another common mistake is to provide an object method (or any stand-alone
function that relies on `this`) as the target of the assertion. Doing so is
problematic because the `this` context will be lost when the function is
invoked by `.throw`; there's no way for it to know what `this` is supposed
to be. There are two ways around this problem. One solution is to wrap the
method or function call inside of another function. Another solution is to
use `bind`.

    expect(function () { cat.meow(); }).to.throw();  // Function expression
    expect(() => cat.meow()).to.throw();             // ES6 arrow function
    expect(cat.meow.bind(cat)).to.throw();           // Bind

Finally, it's worth mentioning that it's a best practice in JavaScript to
only throw `Error` and derivatives of `Error` such as `ReferenceError`,
`TypeError`, and user-defined objects that extend `Error`. No other type of
value will generate a stack trace when initialized. With that said, the
`throw` assertion does technically support any type of value being thrown,
not just `Error` and its derivatives.

The aliases `.throws` and `.Throw` can be used interchangeably with
`.throw`.
### .respondTo(method[, msg])

When the target is a non-function object, `.respondTo` asserts that the
target has a method with the given name `method`. The method can be own or
inherited, and it can be enumerable or non-enumerable.

    function Cat () {}
    Cat.prototype.meow = function () {};

    expect(new Cat()).to.respondTo('meow');

When the target is a function, `.respondTo` asserts that the target's
`prototype` property has a method with the given name `method`. Again, the
method can be own or inherited, and it can be enumerable or non-enumerable.

    function Cat () {}
    Cat.prototype.meow = function () {};

    expect(Cat).to.respondTo('meow');

Add `.itself` earlier in the chain to force `.respondTo` to treat the
target as a non-function object, even if it's a function. Thus, it asserts
that the target has a method with the given name `method`, rather than
asserting that the target's `prototype` property has a method with the
given name `method`.

    function Cat () {}
    Cat.prototype.meow = function () {};
    Cat.hiss = function () {};

    expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');

When not adding `.itself`, it's important to check the target's type before
using `.respondTo`. See the `.a` doc for info on checking a target's type.

    function Cat () {}
    Cat.prototype.meow = function () {};

    expect(new Cat()).to.be.an('object').that.respondsTo('meow');

Add `.not` earlier in the chain to negate `.respondTo`.

    function Dog () {}
    Dog.prototype.bark = function () {};

    expect(new Dog()).to.not.respondTo('meow');

`.respondTo` accepts an optional `msg` argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to `expect`.

    expect({}).to.respondTo('meow', 'nooo why fail??');
    expect({}, 'nooo why fail??').to.respondTo('meow');

The alias `.respondsTo` can be used interchangeably with `.respondTo`.
### .itself

Forces all `.respondTo` assertions that follow in the chain to behave as if
the target is a non-function object, even if it's a function. Thus, it
causes `.respondTo` to assert that the target has a method with the given
name, rather than asserting that the target's `prototype` property has a
method with the given name.

    function Cat () {}
    Cat.prototype.meow = function () {};
    Cat.hiss = function () {};

    expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
### .satisfy(matcher[, msg])

Invokes the given `matcher` function with the target being passed as the
first argument, and asserts that the value returned is truthy.

    expect(1).to.satisfy(function(num) {
      return num > 0; 
    });

Add `.not` earlier in the chain to negate `.satisfy`.

    expect(1).to.not.satisfy(function(num) {
      return num > 2;
    });

`.satisfy` accepts an optional `msg` argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to `expect`.

    expect(1).to.satisfy(function(num) {
      return num > 2;
    }, 'nooo why fail??');

    expect(1, 'nooo why fail??').to.satisfy(function(num) {
      return num > 2;
    });

The alias `.satisfies` can be used interchangeably with `.satisfy`.
### .closeTo(expected, delta[, msg])

Asserts that the target is a number that's within a given +/- `delta` range
of the given number `expected`. However, it's often best to assert that the
target is equal to its expected value.

    // Recommended
    expect(1.5).to.equal(1.5);

    // Not recommended
    expect(1.5).to.be.closeTo(1, 0.5);
    expect(1.5).to.be.closeTo(2, 0.5);
    expect(1.5).to.be.closeTo(1, 1);

Add `.not` earlier in the chain to negate `.closeTo`.

    expect(1.5).to.equal(1.5); // Recommended
    expect(1.5).to.not.be.closeTo(3, 1); // Not recommended

`.closeTo` accepts an optional `msg` argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to `expect`.

    expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
    expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);

The alias `.approximately` can be used interchangeably with `.closeTo`.
### .members(set[, msg])

Asserts that the target array has the same members as the given array
`set`.

    expect([1, 2, 3]).to.have.members([2, 1, 3]);
    expect([1, 2, 2]).to.have.members([2, 1, 2]);

By default, members are compared using strict (`===`) equality. Add `.deep`
earlier in the chain to use deep equality instead. See the `deep-eql`
project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.

    // Target array deeply (but not strictly) has member `{a: 1}`
    expect([{a: 1}]).to.have.deep.members([{a: 1}]);
    expect([{a: 1}]).to.not.have.members([{a: 1}]);

By default, order doesn't matter. Add `.ordered` earlier in the chain to
require that members appear in the same order.

    expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
    expect([1, 2, 3]).to.have.members([2, 1, 3])
      .but.not.ordered.members([2, 1, 3]);

By default, both arrays must be the same size. Add `.include` earlier in
the chain to require that the target's members be a superset of the
expected members. Note that duplicates are ignored in the subset when
`.include` is added.

    // Target array is a superset of [1, 2] but not identical
    expect([1, 2, 3]).to.include.members([1, 2]);
    expect([1, 2, 3]).to.not.have.members([1, 2]);

    // Duplicates in the subset are ignored
    expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);

`.deep`, `.ordered`, and `.include` can all be combined. However, if
`.include` and `.ordered` are combined, the ordering begins at the start of
both arrays.

    expect([{a: 1}, {b: 2}, {c: 3}])
      .to.include.deep.ordered.members([{a: 1}, {b: 2}])
      .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);

Add `.not` earlier in the chain to negate `.members`. However, it's
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the target array doesn't have all of the same members as
the given array `set` but may or may not have some of them. It's often best
to identify the exact output that's expected, and then write an assertion
that only accepts that exact output.

    expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
    expect([1, 2]).to.not.have.members([3, 4]); // Not recommended

`.members` accepts an optional `msg` argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to `expect`.

    expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
    expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
### .oneOf(list[, msg])

Asserts that the target is a member of the given array `list`. However,
it's often best to assert that the target is equal to its expected value.

    expect(1).to.equal(1); // Recommended
    expect(1).to.be.oneOf([1, 2, 3]); // Not recommended

Comparisons are performed using strict (`===`) equality.

Add `.not` earlier in the chain to negate `.oneOf`.

    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended

`.oneOf` accepts an optional `msg` argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to `expect`.

    expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
    expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
### .change(subject[, prop[, msg]])

When one argument is provided, `.change` asserts that the given function
`subject` returns a different value when it's invoked before the target
function compared to when it's invoked afterward. However, it's often best
to assert that `subject` is equal to its expected value.

    var dots = ''
      , addDot = function () { dots += '.'; }
      , getDots = function () { return dots; };

    // Recommended
    expect(getDots()).to.equal('');
    addDot();
    expect(getDots()).to.equal('.');

    // Not recommended
    expect(addDot).to.change(getDots);

When two arguments are provided, `.change` asserts that the value of the
given object `subject`'s `prop` property is different before invoking the
target function compared to afterward.

    var myObj = {dots: ''}
      , addDot = function () { myObj.dots += '.'; };

    // Recommended
    expect(myObj).to.have.property('dots', '');
    addDot();
    expect(myObj).to.have.property('dots', '.');

    // Not recommended
    expect(addDot).to.change(myObj, 'dots');

Strict (`===`) equality is used to compare before and after values.

Add `.not` earlier in the chain to negate `.change`.

    var dots = ''
      , noop = function () {}
      , getDots = function () { return dots; };

    expect(noop).to.not.change(getDots);

    var myObj = {dots: ''}
      , noop = function () {};

    expect(noop).to.not.change(myObj, 'dots');

`.change` accepts an optional `msg` argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to `expect`. When not providing two arguments, always
use the second form.

    var myObj = {dots: ''}
      , addDot = function () { myObj.dots += '.'; };

    expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');

    var dots = ''
      , addDot = function () { dots += '.'; }
      , getDots = function () { return dots; };

    expect(addDot, 'nooo why fail??').to.not.change(getDots);

`.change` also causes all `.by` assertions that follow in the chain to
assert how much a numeric subject was increased or decreased by. However,
it's dangerous to use `.change.by`. The problem is that it creates
uncertain expectations by asserting that the subject either increases by
the given delta, or that it decreases by the given delta. It's often best
to identify the exact output that's expected, and then write an assertion
that only accepts that exact output.

    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; }
      , subtractTwo = function () { myObj.val -= 2; };

    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
    expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended

    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
    expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended

The alias `.changes` can be used interchangeably with `.change`.
### .increase(subject[, prop[, msg]])

When one argument is provided, `.increase` asserts that the given function
`subject` returns a greater number when it's invoked after invoking the
target function compared to when it's invoked beforehand. `.increase` also
causes all `.by` assertions that follow in the chain to assert how much
greater of a number is returned. It's often best to assert that the return
value increased by the expected amount, rather than asserting it increased
by any amount.

    var val = 1
      , addTwo = function () { val += 2; }
      , getVal = function () { return val; };

    expect(addTwo).to.increase(getVal).by(2); // Recommended
    expect(addTwo).to.increase(getVal); // Not recommended

When two arguments are provided, `.increase` asserts that the value of the
given object `subject`'s `prop` property is greater after invoking the
target function compared to beforehand.

    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };

    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
    expect(addTwo).to.increase(myObj, 'val'); // Not recommended

Add `.not` earlier in the chain to negate `.increase`. However, it's
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the subject either decreases, or that it stays the same.
It's often best to identify the exact output that's expected, and then
write an assertion that only accepts that exact output.

When the subject is expected to decrease, it's often best to assert that it
decreased by the expected amount.

    var myObj = {val: 1}
      , subtractTwo = function () { myObj.val -= 2; };

    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
    expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended

When the subject is expected to stay the same, it's often best to assert
exactly that.

    var myObj = {val: 1}
      , noop = function () {};

    expect(noop).to.not.change(myObj, 'val'); // Recommended
    expect(noop).to.not.increase(myObj, 'val'); // Not recommended

`.increase` accepts an optional `msg` argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to `expect`. When not providing two arguments, always
use the second form.

    var myObj = {val: 1}
      , noop = function () {};

    expect(noop).to.increase(myObj, 'val', 'nooo why fail??');

    var val = 1
      , noop = function () {}
      , getVal = function () { return val; };

    expect(noop, 'nooo why fail??').to.increase(getVal);

The alias `.increases` can be used interchangeably with `.increase`.
### .decrease(subject[, prop[, msg]])

When one argument is provided, `.decrease` asserts that the given function
`subject` returns a lesser number when it's invoked after invoking the
target function compared to when it's invoked beforehand. `.decrease` also
causes all `.by` assertions that follow in the chain to assert how much
lesser of a number is returned. It's often best to assert that the return
value decreased by the expected amount, rather than asserting it decreased
by any amount.

    var val = 1
      , subtractTwo = function () { val -= 2; }
      , getVal = function () { return val; };

    expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
    expect(subtractTwo).to.decrease(getVal); // Not recommended

When two arguments are provided, `.decrease` asserts that the value of the
given object `subject`'s `prop` property is lesser after invoking the
target function compared to beforehand. 

    var myObj = {val: 1}
      , subtractTwo = function () { myObj.val -= 2; };

    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
    expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended

Add `.not` earlier in the chain to negate `.decrease`. However, it's
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the subject either increases, or that it stays the same.
It's often best to identify the exact output that's expected, and then
write an assertion that only accepts that exact output.

When the subject is expected to increase, it's often best to assert that it
increased by the expected amount.

    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };

    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
    expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended

When the subject is expected to stay the same, it's often best to assert
exactly that.

    var myObj = {val: 1}
      , noop = function () {};

    expect(noop).to.not.change(myObj, 'val'); // Recommended
    expect(noop).to.not.decrease(myObj, 'val'); // Not recommended

`.decrease` accepts an optional `msg` argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to `expect`. When not providing two arguments, always
use the second form.

    var myObj = {val: 1}
      , noop = function () {};

    expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');

    var val = 1
      , noop = function () {}
      , getVal = function () { return val; };

    expect(noop, 'nooo why fail??').to.decrease(getVal);

The alias `.decreases` can be used interchangeably with `.decrease`.
### .by(delta[, msg])

When following an `.increase` assertion in the chain, `.by` asserts that
the subject of the `.increase` assertion increased by the given `delta`.

    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };

    expect(addTwo).to.increase(myObj, 'val').by(2);

When following a `.decrease` assertion in the chain, `.by` asserts that the
subject of the `.decrease` assertion decreased by the given `delta`.

    var myObj = {val: 1}
      , subtractTwo = function () { myObj.val -= 2; };

    expect(subtractTwo).to.decrease(myObj, 'val').by(2);

When following a `.change` assertion in the chain, `.by` asserts that the
subject of the `.change` assertion either increased or decreased by the
given `delta`. However, it's dangerous to use `.change.by`. The problem is
that it creates uncertain expectations. It's often best to identify the
exact output that's expected, and then write an assertion that only accepts
that exact output.

    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; }
      , subtractTwo = function () { myObj.val -= 2; };

    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
    expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended

    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
    expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended

Add `.not` earlier in the chain to negate `.by`. However, it's often best
to assert that the subject changed by its expected delta, rather than
asserting that it didn't change by one of countless unexpected deltas.

    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };

    // Recommended
    expect(addTwo).to.increase(myObj, 'val').by(2);

    // Not recommended
    expect(addTwo).to.increase(myObj, 'val').but.not.by(3);

`.by` accepts an optional `msg` argument which is a custom error message to
show when the assertion fails. The message can also be given as the second
argument to `expect`.

    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };

    expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
    expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
### .extensible

Asserts that the target is extensible, which means that new properties can
be added to it. Primitives are never extensible.

    expect({a: 1}).to.be.extensible;

Add `.not` earlier in the chain to negate `.extensible`.

    var nonExtensibleObject = Object.preventExtensions({})
      , sealedObject = Object.seal({})
      , frozenObject = Object.freeze({});

    expect(nonExtensibleObject).to.not.be.extensible;
    expect(sealedObject).to.not.be.extensible;
    expect(frozenObject).to.not.be.extensible;
    expect(1).to.not.be.extensible;

A custom error message can be given as the second argument to `expect`.

    expect(1, 'nooo why fail??').to.be.extensible;
### .sealed

Asserts that the target is sealed, which means that new properties can't be
added to it, and its existing properties can't be reconfigured or deleted.
However, it's possible that its existing properties can still be reassigned
to different values. Primitives are always sealed.

    var sealedObject = Object.seal({});
    var frozenObject = Object.freeze({});

    expect(sealedObject).to.be.sealed;
    expect(frozenObject).to.be.sealed;
    expect(1).to.be.sealed;

Add `.not` earlier in the chain to negate `.sealed`.

    expect({a: 1}).to.not.be.sealed;

A custom error message can be given as the second argument to `expect`.

    expect({a: 1}, 'nooo why fail??').to.be.sealed;
### .frozen

Asserts that the target is frozen, which means that new properties can't be
added to it, and its existing properties can't be reassigned to different
values, reconfigured, or deleted. Primitives are always frozen.

    var frozenObject = Object.freeze({});

    expect(frozenObject).to.be.frozen;
    expect(1).to.be.frozen;

Add `.not` earlier in the chain to negate `.frozen`.

    expect({a: 1}).to.not.be.frozen;

A custom error message can be given as the second argument to `expect`.

    expect({a: 1}, 'nooo why fail??').to.be.frozen;
### .finite

Asserts that the target is a number, and isn't `NaN` or positive/negative
`Infinity`.

    expect(1).to.be.finite;

Add `.not` earlier in the chain to negate `.finite`. However, it's
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the subject either isn't a number, or that it's `NaN`, or
that it's positive `Infinity`, or that it's negative `Infinity`. It's often
best to identify the exact output that's expected, and then write an
assertion that only accepts that exact output.

When the target isn't expected to be a number, it's often best to assert
that it's the expected type, rather than asserting that it isn't one of
many unexpected types.

    expect('foo').to.be.a('string'); // Recommended
    expect('foo').to.not.be.finite; // Not recommended

When the target is expected to be `NaN`, it's often best to assert exactly
that.

    expect(NaN).to.be.NaN; // Recommended
    expect(NaN).to.not.be.finite; // Not recommended

When the target is expected to be positive infinity, it's often best to
assert exactly that.

    expect(Infinity).to.equal(Infinity); // Recommended
    expect(Infinity).to.not.be.finite; // Not recommended

When the target is expected to be negative infinity, it's often best to
assert exactly that.

    expect(-Infinity).to.equal(-Infinity); // Recommended
    expect(-Infinity).to.not.be.finite; // Not recommended

A custom error message can be given as the second argument to `expect`.

    expect('foo', 'nooo why fail??').to.be.finite;
chai
Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
Chai dependencies.
Module export.
### assert(expression, message)

Write your own test expressions.

    assert('foo' !== 'bar', 'foo is not bar');
    assert(Array.isArray([]), 'empty arrays are arrays');
### .fail(actual, expected, [message], [operator])

Throw a failure. Node.js `assert` module-compatible.
### .isOk(object, [message])

Asserts that `object` is truthy.

    assert.isOk('everything', 'everything is ok');
    assert.isOk(false, 'this will fail');
### .isNotOk(object, [message])

Asserts that `object` is falsy.

    assert.isNotOk('everything', 'this will fail');
    assert.isNotOk(false, 'this will pass');
### .equal(actual, expected, [message])

Asserts non-strict equality (`==`) of `actual` and `expected`.

    assert.equal(3, '3', '== coerces values to strings');
### .notEqual(actual, expected, [message])

Asserts non-strict inequality (`!=`) of `actual` and `expected`.

    assert.notEqual(3, 4, 'these numbers are not equal');
### .strictEqual(actual, expected, [message])

Asserts strict equality (`===`) of `actual` and `expected`.

    assert.strictEqual(true, true, 'these booleans are strictly equal');
### .notStrictEqual(actual, expected, [message])

Asserts strict inequality (`!==`) of `actual` and `expected`.

    assert.notStrictEqual(3, '3', 'no coercion for strict equality');
### .deepEqual(actual, expected, [message])

Asserts that `actual` is deeply equal to `expected`.

    assert.deepEqual({ tea: 'green' }, { tea: 'green' });
### .notDeepEqual(actual, expected, [message])

Assert that `actual` is not deeply equal to `expected`.

    assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
### .isAbove(valueToCheck, valueToBeAbove, [message])

Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.

    assert.isAbove(5, 2, '5 is strictly greater than 2');
### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])

Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.

    assert.isAtLeast(5, 2, '5 is greater or equal to 2');
    assert.isAtLeast(3, 3, '3 is greater or equal to 3');
### .isBelow(valueToCheck, valueToBeBelow, [message])

Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.

    assert.isBelow(3, 6, '3 is strictly less than 6');
### .isAtMost(valueToCheck, valueToBeAtMost, [message])

Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.

    assert.isAtMost(3, 6, '3 is less than or equal to 6');
    assert.isAtMost(4, 4, '4 is less than or equal to 4');
### .isTrue(value, [message])

Asserts that `value` is true.

    var teaServed = true;
    assert.isTrue(teaServed, 'the tea has been served');
### .isNotTrue(value, [message])

Asserts that `value` is not true.

    var tea = 'tasty chai';
    assert.isNotTrue(tea, 'great, time for tea!');
### .isFalse(value, [message])

Asserts that `value` is false.

    var teaServed = false;
    assert.isFalse(teaServed, 'no tea yet? hmm...');
### .isNotFalse(value, [message])

Asserts that `value` is not false.

    var tea = 'tasty chai';
    assert.isNotFalse(tea, 'great, time for tea!');
### .isNull(value, [message])

Asserts that `value` is null.

    assert.isNull(err, 'there was no error');
### .isNotNull(value, [message])

Asserts that `value` is not null.

    var tea = 'tasty chai';
    assert.isNotNull(tea, 'great, time for tea!');
### .isNaN

Asserts that value is NaN.

    assert.isNaN(NaN, 'NaN is NaN');
### .isNotNaN

Asserts that value is not NaN.

    assert.isNotNaN(4, '4 is not NaN');
### .exists

Asserts that the target is neither `null` nor `undefined`.

    var foo = 'hi';

    assert.exists(foo, 'foo is neither `null` nor `undefined`');
### .notExists

Asserts that the target is either `null` or `undefined`.

    var bar = null
      , baz;

    assert.notExists(bar);
    assert.notExists(baz, 'baz is either null or undefined');
### .isUndefined(value, [message])

Asserts that `value` is `undefined`.

    var tea;
    assert.isUndefined(tea, 'no tea defined');
### .isDefined(value, [message])

Asserts that `value` is not `undefined`.

    var tea = 'cup of chai';
    assert.isDefined(tea, 'tea has been defined');
### .isFunction(value, [message])

Asserts that `value` is a function.

    function serveTea() { return 'cup of tea'; };
    assert.isFunction(serveTea, 'great, we can have tea now');
### .isNotFunction(value, [message])

Asserts that `value` is _not_ a function.

    var serveTea = [ 'heat', 'pour', 'sip' ];
    assert.isNotFunction(serveTea, 'great, we have listed the steps');
### .isObject(value, [message])

Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
_The assertion does not match subclassed objects._

    var selection = { name: 'Chai', serve: 'with spices' };
    assert.isObject(selection, 'tea selection is an object');
### .isNotObject(value, [message])

Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).

    var selection = 'chai'
    assert.isNotObject(selection, 'tea selection is not an object');
    assert.isNotObject(null, 'null is not an object');
### .isArray(value, [message])

Asserts that `value` is an array.

    var menu = [ 'green', 'chai', 'oolong' ];
    assert.isArray(menu, 'what kind of tea do we want?');
### .isNotArray(value, [message])

Asserts that `value` is _not_ an array.

    var menu = 'green|chai|oolong';
    assert.isNotArray(menu, 'what kind of tea do we want?');
### .isString(value, [message])

Asserts that `value` is a string.

    var teaOrder = 'chai';
    assert.isString(teaOrder, 'order placed');
### .isNotString(value, [message])

Asserts that `value` is _not_ a string.

    var teaOrder = 4;
    assert.isNotString(teaOrder, 'order placed');
### .isNumber(value, [message])

Asserts that `value` is a number.

    var cups = 2;
    assert.isNumber(cups, 'how many cups');
### .isNotNumber(value, [message])

Asserts that `value` is _not_ a number.

    var cups = '2 cups please';
    assert.isNotNumber(cups, 'how many cups');
### .isFinite(value, [message])

Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.

    var cups = 2;
    assert.isFinite(cups, 'how many cups');

    assert.isFinite(NaN); // throws
### .isBoolean(value, [message])

Asserts that `value` is a boolean.

    var teaReady = true
      , teaServed = false;

    assert.isBoolean(teaReady, 'is the tea ready');
    assert.isBoolean(teaServed, 'has tea been served');
### .isNotBoolean(value, [message])

Asserts that `value` is _not_ a boolean.

    var teaReady = 'yep'
      , teaServed = 'nope';

    assert.isNotBoolean(teaReady, 'is the tea ready');
    assert.isNotBoolean(teaServed, 'has tea been served');
### .typeOf(value, name, [message])

Asserts that `value`'s type is `name`, as determined by
`Object.prototype.toString`.

    assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
    assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
    assert.typeOf('tea', 'string', 'we have a string');
    assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
    assert.typeOf(null, 'null', 'we have a null');
    assert.typeOf(undefined, 'undefined', 'we have an undefined');
### .notTypeOf(value, name, [message])

Asserts that `value`'s type is _not_ `name`, as determined by
`Object.prototype.toString`.

    assert.notTypeOf('tea', 'number', 'strings are not numbers');
### .instanceOf(object, constructor, [message])

Asserts that `value` is an instance of `constructor`.

    var Tea = function (name) { this.name = name; }
      , chai = new Tea('chai');

    assert.instanceOf(chai, Tea, 'chai is an instance of tea');
### .notInstanceOf(object, constructor, [message])

Asserts `value` is not an instance of `constructor`.

    var Tea = function (name) { this.name = name; }
      , chai = new String('chai');

    assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
### .include(haystack, needle, [message])

Asserts that `haystack` includes `needle`. Can be used to assert the
inclusion of a value in an array, a substring in a string, or a subset of
properties in an object.

    assert.include([1,2,3], 2, 'array contains value');
    assert.include('foobar', 'foo', 'string contains substring');
    assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');

Strict equality (===) is used. When asserting the inclusion of a value in
an array, the array is searched for an element that's strictly equal to the
given value. When asserting a subset of properties in an object, the object
is searched for the given property keys, checking that each one is present
and stricty equal to the given property value. For instance:

    var obj1 = {a: 1}
      , obj2 = {b: 2};
    assert.include([obj1, obj2], obj1);
    assert.include({foo: obj1, bar: obj2}, {foo: obj1});
    assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
### .notInclude(haystack, needle, [message])

Asserts that `haystack` does not include `needle`. Can be used to assert
the absence of a value in an array, a substring in a string, or a subset of
properties in an object.

    assert.notInclude([1,2,3], 4, 'array doesn't contain value');
    assert.notInclude('foobar', 'baz', 'string doesn't contain substring');
    assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');

Strict equality (===) is used. When asserting the absence of a value in an
array, the array is searched to confirm the absence of an element that's
strictly equal to the given value. When asserting a subset of properties in
an object, the object is searched to confirm that at least one of the given
property keys is either not present or not strictly equal to the given
property value. For instance:

    var obj1 = {a: 1}
      , obj2 = {b: 2};
    assert.notInclude([obj1, obj2], {a: 1});
    assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
    assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
### .deepInclude(haystack, needle, [message])

Asserts that `haystack` includes `needle`. Can be used to assert the
inclusion of a value in an array or a subset of properties in an object.
Deep equality is used.

    var obj1 = {a: 1}
      , obj2 = {b: 2};
    assert.deepInclude([obj1, obj2], {a: 1});
    assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
    assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
### .notDeepInclude(haystack, needle, [message])

Asserts that `haystack` does not include `needle`. Can be used to assert
the absence of a value in an array or a subset of properties in an object.
Deep equality is used.

    var obj1 = {a: 1}
      , obj2 = {b: 2};
    assert.notDeepInclude([obj1, obj2], {a: 9});
    assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
    assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
### .nestedInclude(haystack, needle, [message])

Asserts that 'haystack' includes 'needle'. 
Can be used to assert the inclusion of a subset of properties in an 
object.
Enables the use of dot- and bracket-notation for referencing nested 
properties.
'[]' and '.' in property names can be escaped using double backslashes.

    assert.nestedInclude({'.a': {'b': 'x'}}, {'\\.a.[b]': 'x'});
    assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'x'});
### .notNestedInclude(haystack, needle, [message])

Asserts that 'haystack' does not include 'needle'. 
Can be used to assert the absence of a subset of properties in an 
object.
Enables the use of dot- and bracket-notation for referencing nested 
properties. 
'[]' and '.' in property names can be escaped using double backslashes.

    assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\.a.b': 'y'});
    assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'y'});
### .deepNestedInclude(haystack, needle, [message])

Asserts that 'haystack' includes 'needle'.
Can be used to assert the inclusion of a subset of properties in an 
object while checking for deep equality.
Enables the use of dot- and bracket-notation for referencing nested 
properties.
'[]' and '.' in property names can be escaped using double backslashes.

    assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
    assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {x: 1}});
### .notDeepNestedInclude(haystack, needle, [message])

Asserts that 'haystack' does not include 'needle'.
Can be used to assert the absence of a subset of properties in an 
object while checking for deep equality.
Enables the use of dot- and bracket-notation for referencing nested 
properties.
'[]' and '.' in property names can be escaped using double backslashes.

    assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
    assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {y: 2}});
### .ownInclude(haystack, needle, [message])

Asserts that 'haystack' includes 'needle'.
Can be used to assert the inclusion of a subset of properties in an 
object while ignoring inherited properties.

    assert.ownInclude({ a: 1 }, { a: 1 });
### .notOwnInclude(haystack, needle, [message])

Asserts that 'haystack' includes 'needle'.
Can be used to assert the absence of a subset of properties in an 
object while ignoring inherited properties.

    Object.prototype.b = 2;

    assert.notOwnInclude({ a: 1 }, { b: 2 });
### .deepOwnInclude(haystack, needle, [message])

Asserts that 'haystack' includes 'needle'.
Can be used to assert the inclusion of a subset of properties in an 
object while ignoring inherited properties and checking for deep equality.

     assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
### .notDeepOwnInclude(haystack, needle, [message])

Asserts that 'haystack' includes 'needle'.
Can be used to assert the absence of a subset of properties in an 
object while ignoring inherited properties and checking for deep equality.

     assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
### .match(value, regexp, [message])

Asserts that `value` matches the regular expression `regexp`.

    assert.match('foobar', /^foo/, 'regexp matches');
### .notMatch(value, regexp, [message])

Asserts that `value` does not match the regular expression `regexp`.

    assert.notMatch('foobar', /^foo/, 'regexp does not match');
### .property(object, property, [message])

Asserts that `object` has a direct or inherited property named by
`property`.

    assert.property({ tea: { green: 'matcha' }}, 'tea');
    assert.property({ tea: { green: 'matcha' }}, 'toString');
### .notProperty(object, property, [message])

Asserts that `object` does _not_ have a direct or inherited property named
by `property`.

    assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
### .propertyVal(object, property, value, [message])

Asserts that `object` has a direct or inherited property named by
`property` with a value given by `value`. Uses a strict equality check
(===).

    assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
### .notPropertyVal(object, property, value, [message])

Asserts that `object` does _not_ have a direct or inherited property named
by `property` with value given by `value`. Uses a strict equality check
(===).

    assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
    assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
### .deepPropertyVal(object, property, value, [message])

Asserts that `object` has a direct or inherited property named by
`property` with a value given by `value`. Uses a deep equality check.

    assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
### .notDeepPropertyVal(object, property, value, [message])

Asserts that `object` does _not_ have a direct or inherited property named
by `property` with value given by `value`. Uses a deep equality check.

    assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
    assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
    assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
### .ownProperty(object, property, [message])

Asserts that `object` has a direct property named by `property`. Inherited
properties aren't checked.

    assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');
### .notOwnProperty(object, property, [message])

Asserts that `object` does _not_ have a direct property named by
`property`. Inherited properties aren't checked.

    assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');
    assert.notOwnProperty({}, 'toString');
### .ownPropertyVal(object, property, value, [message])

Asserts that `object` has a direct property named by `property` and a value
equal to the provided `value`. Uses a strict equality check (===).
Inherited properties aren't checked.

    assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');
### .notOwnPropertyVal(object, property, value, [message])

Asserts that `object` does _not_ have a direct property named by `property`
with a value equal to the provided `value`. Uses a strict equality check
(===). Inherited properties aren't checked.

    assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');
    assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);
### .deepOwnPropertyVal(object, property, value, [message])

Asserts that `object` has a direct property named by `property` and a value
equal to the provided `value`. Uses a deep equality check. Inherited
properties aren't checked.

    assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
### .notDeepOwnPropertyVal(object, property, value, [message])

Asserts that `object` does _not_ have a direct property named by `property`
with a value equal to the provided `value`. Uses a deep equality check.
Inherited properties aren't checked.

    assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
    assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
    assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
    assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);
### .nestedProperty(object, property, [message])

Asserts that `object` has a direct or inherited property named by
`property`, which can be a string using dot- and bracket-notation for
nested reference.

    assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
### .notNestedProperty(object, property, [message])

Asserts that `object` does _not_ have a property named by `property`, which
can be a string using dot- and bracket-notation for nested reference. The
property cannot exist on the object nor anywhere in its prototype chain.

    assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
### .nestedPropertyVal(object, property, value, [message])

Asserts that `object` has a property named by `property` with value given
by `value`. `property` can use dot- and bracket-notation for nested
reference. Uses a strict equality check (===).

    assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
### .notNestedPropertyVal(object, property, value, [message])

Asserts that `object` does _not_ have a property named by `property` with
value given by `value`. `property` can use dot- and bracket-notation for
nested reference. Uses a strict equality check (===).

    assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
    assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
### .deepNestedPropertyVal(object, property, value, [message])

Asserts that `object` has a property named by `property` with a value given
by `value`. `property` can use dot- and bracket-notation for nested
reference. Uses a deep equality check.

    assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
### .notDeepNestedPropertyVal(object, property, value, [message])

Asserts that `object` does _not_ have a property named by `property` with
value given by `value`. `property` can use dot- and bracket-notation for
nested reference. Uses a deep equality check.

    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
### .lengthOf(object, length, [message])

Asserts that `object` has a `length` property with the expected value.

    assert.lengthOf([1,2,3], 3, 'array has length of 3');
    assert.lengthOf('foobar', 6, 'string has length of 6');
### .hasAnyKeys(object, [keys], [message])

Asserts that `object` has at least one of the `keys` provided.
You can also provide a single object instead of a `keys` array and its keys
will be used as the expected set of keys.

    assert.hasAnyKey({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
    assert.hasAnyKey({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337]);
    assert.hasAnyKey(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'thisKeyDoesNotExist']);
    assert.hasAnyKey(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'thisKeyDoesNotExist']);
### .hasAllKeys(object, [keys], [message])

Asserts that `object` has all and only all of the `keys` provided.
You can also provide a single object instead of a `keys` array and its keys
will be used as the expected set of keys.

    assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
    assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
    assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
    assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
### .containsAllKeys(object, [keys], [message])

Asserts that `object` has all of the `keys` provided but may have more keys not listed.
You can also provide a single object instead of a `keys` array and its keys
will be used as the expected set of keys.

    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
    assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
    assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
    assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
    assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
### .doesNotHaveAnyKeys(object, [keys], [message])

Asserts that `object` has none of the `keys` provided.
You can also provide a single object instead of a `keys` array and its keys
will be used as the expected set of keys.

    assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
    assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
    assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
    assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
### .doesNotHaveAllKeys(object, [keys], [message])

Asserts that `object` does not have at least one of the `keys` provided.
You can also provide a single object instead of a `keys` array and its keys
will be used as the expected set of keys.

    assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
    assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
    assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
    assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
### .hasAnyDeepKeys(object, [keys], [message])

Asserts that `object` has at least one of the `keys` provided.
Since Sets and Maps can have objects as keys you can use this assertion to perform
a deep comparison.
You can also provide a single object instead of a `keys` array and its keys
will be used as the expected set of keys.

    assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
    assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
    assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
    assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
    assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
### .hasAllDeepKeys(object, [keys], [message])

Asserts that `object` has all and only all of the `keys` provided.
Since Sets and Maps can have objects as keys you can use this assertion to perform
a deep comparison.
You can also provide a single object instead of a `keys` array and its keys
will be used as the expected set of keys.

    assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
    assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
    assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
### .containsAllDeepKeys(object, [keys], [message])

Asserts that `object` contains all of the `keys` provided.
Since Sets and Maps can have objects as keys you can use this assertion to perform
a deep comparison.
You can also provide a single object instead of a `keys` array and its keys
will be used as the expected set of keys.

    assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
    assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
    assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
### .doesNotHaveAnyDeepKeys(object, [keys], [message])

Asserts that `object` has none of the `keys` provided.
Since Sets and Maps can have objects as keys you can use this assertion to perform
a deep comparison.
You can also provide a single object instead of a `keys` array and its keys
will be used as the expected set of keys.

    assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
### .doesNotHaveAllDeepKeys(object, [keys], [message])

Asserts that `object` does not have at least one of the `keys` provided.
Since Sets and Maps can have objects as keys you can use this assertion to perform
a deep comparison.
You can also provide a single object instead of a `keys` array and its keys
will be used as the expected set of keys.

    assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
    assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])

If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an
instance of `errorLike`.
If `errorLike` is an `Error` instance, asserts that the error thrown is the same
instance as `errorLike`.
If `errMsgMatcher` is provided, it also asserts that the error thrown will have a
message matching `errMsgMatcher`.

    assert.throws(fn, 'function throws a reference error');
    assert.throws(fn, /function throws a reference error/);
    assert.throws(fn, ReferenceError);
    assert.throws(fn, errorInstance);
    assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
    assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
    assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
    assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])

If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an
instance of `errorLike`.
If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same
instance as `errorLike`.
If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a
message matching `errMsgMatcher`.

    assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
    assert.doesNotThrow(fn, /Any Error thrown must not match this/);
    assert.doesNotThrow(fn, Error);
    assert.doesNotThrow(fn, errorInstance);
    assert.doesNotThrow(fn, Error, 'Error must not have this message');
    assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
    assert.doesNotThrow(fn, Error, /Error must not match this/);
    assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
### .operator(val1, operator, val2, [message])

Compares two values using `operator`.

    assert.operator(1, '<', 2, 'everything is ok');
    assert.operator(1, '>', 2, 'this will fail');
### .closeTo(actual, expected, delta, [message])

Asserts that the target is equal `expected`, to within a +/- `delta` range.

    assert.closeTo(1.5, 1, 0.5, 'numbers are close');
### .approximately(actual, expected, delta, [message])

Asserts that the target is equal `expected`, to within a +/- `delta` range.

    assert.approximately(1.5, 1, 0.5, 'numbers are close');
### .sameMembers(set1, set2, [message])

Asserts that `set1` and `set2` have the same members in any order. Uses a
strict equality check (===).

    assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
### .notSameMembers(set1, set2, [message])

Asserts that `set1` and `set2` don't have the same members in any order.
Uses a strict equality check (===).

    assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
### .sameDeepMembers(set1, set2, [message])

Asserts that `set1` and `set2` have the same members in any order. Uses a
deep equality check.

    assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
### .notSameDeepMembers(set1, set2, [message])

Asserts that `set1` and `set2` don't have the same members in any order.
Uses a deep equality check.

    assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
### .sameOrderedMembers(set1, set2, [message])

Asserts that `set1` and `set2` have the same members in the same order.
Uses a strict equality check (===).

    assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
### .notSameOrderedMembers(set1, set2, [message])

Asserts that `set1` and `set2` don't have the same members in the same
order. Uses a strict equality check (===).

    assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
### .sameDeepOrderedMembers(set1, set2, [message])

Asserts that `set1` and `set2` have the same members in the same order.
Uses a deep equality check.

assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
### .notSameDeepOrderedMembers(set1, set2, [message])

Asserts that `set1` and `set2` don't have the same members in the same
order. Uses a deep equality check.

assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
### .includeMembers(superset, subset, [message])

Asserts that `subset` is included in `superset` in any order. Uses a
strict equality check (===). Duplicates are ignored.

    assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
### .notIncludeMembers(superset, subset, [message])

Asserts that `subset` isn't included in `superset` in any order. Uses a
strict equality check (===). Duplicates are ignored.

    assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
### .includeDeepMembers(superset, subset, [message])

Asserts that `subset` is included in `superset` in any order. Uses a deep
equality check. Duplicates are ignored.

    assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
### .notIncludeDeepMembers(superset, subset, [message])

Asserts that `subset` isn't included in `superset` in any order. Uses a
deep equality check. Duplicates are ignored.

    assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
### .includeOrderedMembers(superset, subset, [message])

Asserts that `subset` is included in `superset` in the same order
beginning with the first element in `superset`. Uses a strict equality
check (===).

    assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
### .notIncludeOrderedMembers(superset, subset, [message])

Asserts that `subset` isn't included in `superset` in the same order
beginning with the first element in `superset`. Uses a strict equality
check (===).

    assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
    assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
### .includeDeepOrderedMembers(superset, subset, [message])

Asserts that `subset` is included in `superset` in the same order
beginning with the first element in `superset`. Uses a deep equality
check.

    assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
### .notIncludeDeepOrderedMembers(superset, subset, [message])

Asserts that `subset` isn't included in `superset` in the same order
beginning with the first element in `superset`. Uses a deep equality
check.

    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
### .oneOf(inList, list, [message])

Asserts that non-object, non-array value `inList` appears in the flat array `list`.

    assert.oneOf(1, [ 2, 1 ], 'Not found in list');
### .changes(function, object, property, [message])

Asserts that a function changes the value of a property.

    var obj = { val: 10 };
    var fn = function() { obj.val = 22 };
    assert.changes(fn, obj, 'val');
### .changesBy(function, object, property, delta, [message])

Asserts that a function changes the value of a property by an amount (delta).

    var obj = { val: 10 };
    var fn = function() { obj.val += 2 };
    assert.changesBy(fn, obj, 'val', 2);
### .doesNotChange(function, object, property, [message])

Asserts that a function does not change the value of a property.

    var obj = { val: 10 };
    var fn = function() { console.log('foo'); };
    assert.doesNotChange(fn, obj, 'val');
### .changesButNotBy(function, object, property, delta, [message])

Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)

    var obj = { val: 10 };
    var fn = function() { obj.val += 10 };
    assert.changesButNotBy(fn, obj, 'val', 5);
### .increases(function, object, property, [message])

Asserts that a function increases a numeric object property.

    var obj = { val: 10 };
    var fn = function() { obj.val = 13 };
    assert.increases(fn, obj, 'val');
### .increasesBy(function, object, property, delta, [message])

Asserts that a function increases a numeric object property or a function's return value by an amount (delta).

    var obj = { val: 10 };
    var fn = function() { obj.val += 10 };
    assert.increasesBy(fn, obj, 'val', 10);
### .doesNotIncrease(function, object, property, [message])

Asserts that a function does not increase a numeric object property.

    var obj = { val: 10 };
    var fn = function() { obj.val = 8 };
    assert.doesNotIncrease(fn, obj, 'val');
### .increasesButNotBy(function, object, property, [message])

Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).

    var obj = { val: 10 };
    var fn = function() { obj.val = 15 };
    assert.increasesButNotBy(fn, obj, 'val', 10);
### .decreases(function, object, property, [message])

Asserts that a function decreases a numeric object property.

    var obj = { val: 10 };
    var fn = function() { obj.val = 5 };
    assert.decreases(fn, obj, 'val');
### .decreasesBy(function, object, property, delta, [message])

Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)

    var obj = { val: 10 };
    var fn = function() { obj.val -= 5 };
    assert.decreasesBy(fn, obj, 'val', 5);
### .doesNotDecrease(function, object, property, [message])

Asserts that a function does not decreases a numeric object property.

    var obj = { val: 10 };
    var fn = function() { obj.val = 15 };
    assert.doesNotDecrease(fn, obj, 'val');
### .doesNotDecreaseBy(function, object, property, delta, [message])

Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)

    var obj = { val: 10 };
    var fn = function() { obj.val = 5 };
    assert.doesNotDecreaseBy(fn, obj, 'val', 1);
### .decreasesButNotBy(function, object, property, delta, [message])

Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)

    var obj = { val: 10 };
    var fn = function() { obj.val = 5 };
    assert.decreasesButNotBy(fn, obj, 'val', 1);
### .ifError(object)

Asserts if value is not a false value, and throws if it is a true value.
This is added to allow for chai to be a drop-in replacement for Node's
assert class.

    var err = new Error('I am a custom error');
    assert.ifError(err); // Rethrows err!
### .isExtensible(object)

Asserts that `object` is extensible (can have new properties added to it).

    assert.isExtensible({});
### .isNotExtensible(object)

Asserts that `object` is _not_ extensible.

    var nonExtensibleObject = Object.preventExtensions({});
    var sealedObject = Object.seal({});
    var frozenObject = Object.freeze({});

    assert.isNotExtensible(nonExtensibleObject);
    assert.isNotExtensible(sealedObject);
    assert.isNotExtensible(frozenObject);
### .isSealed(object)

Asserts that `object` is sealed (cannot have new properties added to it
and its existing properties cannot be removed).

    var sealedObject = Object.seal({});
    var frozenObject = Object.seal({});

    assert.isSealed(sealedObject);
    assert.isSealed(frozenObject);
### .isNotSealed(object)

Asserts that `object` is _not_ sealed.

    assert.isNotSealed({});
### .isFrozen(object)

Asserts that `object` is frozen (cannot have new properties added to it
and its existing properties cannot be modified).

    var frozenObject = Object.freeze({});
    assert.frozen(frozenObject);
### .isNotFrozen(object)

Asserts that `object` is _not_ frozen.

    assert.isNotFrozen({});
### .isEmpty(target)

Asserts that the target does not contain any values.
For arrays and strings, it checks the `length` property.
For `Map` and `Set` instances, it checks the `size` property.
For non-function objects, it gets the count of own
enumerable string keys.

    assert.isEmpty([]);
    assert.isEmpty('');
    assert.isEmpty(new Map);
    assert.isEmpty({});
### .isNotEmpty(target)

Asserts that the target contains values.
For arrays and strings, it checks the `length` property.
For `Map` and `Set` instances, it checks the `size` property.
For non-function objects, it gets the count of own
enumerable string keys.

    assert.isNotEmpty([1, 2]);
    assert.isNotEmpty('34');
    assert.isNotEmpty(new Set([5, 6]));
    assert.isNotEmpty({ key: 7 });
Aliases.
chai
Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .fail(actual, expected, [message], [operator])

Throw a failure.
chai
Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .fail(actual, expected, [message], [operator])

Throw a failure.
### .equal(actual, expected, [message])

Asserts non-strict equality (`==`) of `actual` and `expected`.

    should.equal(3, '3', '== coerces values to strings');
### .throw(function, [constructor/string/regexp], [string/regexp], [message])

Asserts that `function` will throw an error that is an instance of
`constructor`, or alternately that it will throw an error with message
matching `regexp`.

    should.throw(fn, 'function throws a reference error');
    should.throw(fn, /function throws a reference error/);
    should.throw(fn, ReferenceError);
    should.throw(fn, ReferenceError, 'function throws a reference error');
    should.throw(fn, ReferenceError, /function throws a reference error/);
### .exist

Asserts that the target is neither `null` nor `undefined`.

    var foo = 'hi';

    should.exist(foo, 'foo exists');
### .not.equal(actual, expected, [message])

Asserts non-strict inequality (`!=`) of `actual` and `expected`.

    should.not.equal(3, 4, 'these numbers are not equal');
### .throw(function, [constructor/regexp], [message])

Asserts that `function` will _not_ throw an error that is an instance of
`constructor`, or alternately that it will not throw an error with message
matching `regexp`.

    should.not.throw(fn, Error, 'function does not throw');
### .not.exist

Asserts that the target is neither `null` nor `undefined`.

    var bar = null;

    should.not.exist(bar, 'bar does not exist');
Chai - addChainingMethod utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
Module dependencies
Module variables
### .addChainableMethod(ctx, name, method, chainingBehavior)

Adds a method to an object, such that the method can also be chained.

    utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
      var obj = utils.flag(this, 'object');
      new chai.Assertion(obj).to.be.equal(str);
    });

Can also be accessed directly from `chai.Assertion`.

    chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);

The result can then be used as both a method assertion, executing both `method` and
`chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.

    expect(fooStr).to.be.foo('bar');
    expect(fooStr).to.be.foo.equal('foo');
Chai - addLengthGuard utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .addLengthGuard(fn, assertionName, isChainable)

Define `length` as a getter on the given uninvoked method assertion. The
getter acts as a guard against chaining `length` directly off of an uninvoked
method assertion, which is a problem because it references `function`'s
built-in `length` property instead of Chai's `length` assertion. When the
getter catches the user making this mistake, it throws an error with a
helpful message.

There are two ways in which this mistake can be made. The first way is by
chaining the `length` assertion directly off of an uninvoked chainable
method. In this case, Chai suggests that the user use `lengthOf` instead. The
second way is by chaining the `length` assertion directly off of an uninvoked
non-chainable method. Non-chainable methods must be invoked prior to
chaining. In this case, Chai suggests that the user consult the docs for the
given assertion.

If the `length` property of functions is unconfigurable, then return `fn`
without modification.

Note that in ES6, the function's `length` property is configurable, so once
support for legacy environments is dropped, Chai's `length` property can
replace the built-in function's `length` property, and this length guard will
no longer be necessary. In the mean time, maintaining consistency across all
environments is the priority.
Chai - addMethod utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .addMethod(ctx, name, method)

Adds a method to the prototype of an object.

    utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
      var obj = utils.flag(this, 'object');
      new chai.Assertion(obj).to.be.equal(str);
    });

Can also be accessed directly from `chai.Assertion`.

    chai.Assertion.addMethod('foo', fn);

Then can be used as any other assertion.

    expect(fooStr).to.be.foo('bar');
Chai - addProperty utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .addProperty(ctx, name, getter)

Adds a property to the prototype of an object.

    utils.addProperty(chai.Assertion.prototype, 'foo', function () {
      var obj = utils.flag(this, 'object');
      new chai.Assertion(obj).to.be.instanceof(Foo);
    });

Can also be accessed directly from `chai.Assertion`.

    chai.Assertion.addProperty('foo', fn);

Then can be used as any other assertion.

    expect(myFoo).to.be.foo;
Chai - compareByInspect utility
Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
Module dependancies
### .compareByInspect(mixed, mixed)

To be used as a compareFunction with Array.prototype.sort. Compares elements
using inspect instead of default behavior of using toString so that Symbols
and objects with irregular/missing toString can still be sorted without a
TypeError.
Chai - expectTypes utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .expectTypes(obj, types)

Ensures that the object being tested against is of a valid type.

    utils.expectTypes(this, ['array', 'object', 'string']);
Chai - flag utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .flag(object, key, [value])

Get or set a flag value on an object. If a
value is provided it will be set, else it will
return the currently set value or `undefined` if
the value is not set.

    utils.flag(this, 'foo', 'bar'); // setter
    utils.flag(this, 'foo'); // getter, returns `bar`
Chai - getActual utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .getActual(object, [actual])

Returns the `actual` value for an Assertion.
Chai - getEnumerableProperties utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .getEnumerableProperties(object)

This allows the retrieval of enumerable property names of an object,
inherited or not.
Chai - message composition utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
Module dependancies
### .getMessage(object, message, negateMessage)

Construct the error message based on flags
and template tags. Template tags will return
a stringified inspection of the object referenced.

Message template tags:
- `#{this}` current asserted object
- `#{act}` actual value
- `#{exp}` expected value
Chai - getOwnEnumerableProperties utility
Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
Module dependancies
### .getOwnEnumerableProperties(object)

This allows the retrieval of directly-owned enumerable property names and
symbols of an object. This function is necessary because Object.keys only
returns enumerable property names, not enumerable property symbols.
Chai - getOwnEnumerablePropertySymbols utility
Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .getOwnEnumerablePropertySymbols(object)

This allows the retrieval of directly-owned enumerable property symbols of an
object. This function is necessary because Object.getOwnPropertySymbols
returns both enumerable and non-enumerable property symbols.
Chai - getProperties utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .getProperties(object)

This allows the retrieval of property names of an object, enumerable or not,
inherited or not.
chai
Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
Dependencies that are used for multiple exports are required here only once
test utility
type utility
expectTypes utility
message utility
actual utility
Inspect util
Object Display util
Flag utility
Flag transferring utility
Deep equal utility
Deep path info
Check if a property exists
Function name
add Property
add Method
overwrite Property
overwrite Method
Add a chainable method
Overwrite chainable method
Compare by inspect method
Get own enumerable property symbols method
Get own enumerable properties method
Checks error against a given set of criteria
Proxify util
addLengthGuard util
isProxyEnabled helper
isNaN method
### .inspect(obj, [showHidden], [depth], [colors])

Echoes the value of a value. Tries to print the value out
in the best way possible given the different types.
Chai - isNaN utility
Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
MIT Licensed
### .isNaN(value)

Checks if the given value is NaN or not.

    utils.isNaN(NaN); // true
Chai - isProxyEnabled helper
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .isProxyEnabled()

Helper function to check if Chai's proxy protection feature is enabled. If
proxies are unsupported or disabled via the user's Chai config, then return
false. Otherwise, return true.
Chai - flag utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
Module dependancies
### .objDisplay(object)

Determines if an object or an array matches
criteria to be inspected in-line for error
messages or should be truncated.
Chai - overwriteChainableMethod utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .overwriteChainableMethod(ctx, name, method, chainingBehavior)

Overwites an already existing chainable method
and provides access to the previous function or
property.  Must return functions to be used for
name.

    utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
      function (_super) {
      }
    , function (_super) {
      }
    );

Can also be accessed directly from `chai.Assertion`.

    chai.Assertion.overwriteChainableMethod('foo', fn, fn);

Then can be used as any other assertion.

    expect(myFoo).to.have.lengthOf(3);
    expect(myFoo).to.have.lengthOf.above(3);
Chai - overwriteMethod utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .overwriteMethod(ctx, name, fn)

Overwites an already existing method and provides
access to previous function. Must return function
to be used for name.

    utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
      return function (str) {
        var obj = utils.flag(this, 'object');
        if (obj instanceof Foo) {
          new chai.Assertion(obj.value).to.equal(str);
        } else {
          _super.apply(this, arguments);
        }
      }
    });

Can also be accessed directly from `chai.Assertion`.

    chai.Assertion.overwriteMethod('foo', fn);

Then can be used as any other assertion.

    expect(myFoo).to.equal('bar');
Chai - overwriteProperty utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .overwriteProperty(ctx, name, fn)

Overwites an already existing property getter and provides
access to previous value. Must return function to use as getter.

    utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
      return function () {
        var obj = utils.flag(this, 'object');
        if (obj instanceof Foo) {
          new chai.Assertion(obj.name).to.equal('bar');
        } else {
          _super.call(this);
        }
      }
    });


Can also be accessed directly from `chai.Assertion`.

    chai.Assertion.overwriteProperty('foo', fn);

Then can be used as any other assertion.

    expect(myFoo).to.be.ok;
Chai - proxify utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .proxify(object)

Return a proxy of given object that throws an error when a non-existent
property is read. By default, the root cause is assumed to be a misspelled
property, and thus an attempt is made to offer a reasonable suggestion from
the list of existing properties. However, if a nonChainableMethodName is
provided, then the root cause is instead a failure to invoke a non-chainable
method prior to reading the non-existent property.

If proxies are unsupported or disabled via the user's Chai config, then
return object without modification.
# stringDistance(strA, strB)
Return the Levenshtein distance between two strings.
Chai - test utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
Module dependancies
### .test(object, expression)

Test and object for expression.
Chai - transferFlags utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .transferFlags(assertion, object, includeAll = true)

Transfer all the flags for `assertion` to `object`. If
`includeAll` is set to `false`, then the base Chai
assertion flags (namely `object`, `ssfi`, `lockSsfi`,
and `message`) will not be transferred.


    var newAssertion = new Assertion();
    utils.transferFlags(assertion, newAssertion);

    var anotherAsseriton = new Assertion(myObj);
    utils.transferFlags(assertion, anotherAssertion, false);
assertion-error
Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
MIT Licensed
Return a function that will copy properties from
one object to another excluding any originally
listed. Returned function will create a new `{}`.
Primary Exports
### AssertionError

An extension of the JavaScript `Error` constructor for
assertion and validation scenarios.
Inherit from Error.prototype
Statically set name
Ensure correct constructor
Allow errors to be converted to JSON for static transfer.
!
Chai - checkError utility
Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .checkError

Checks that an error conforms to a given set of criteria and/or retrieves information about it.
### .compatibleInstance(thrown, errorLike)

Checks if two instances are compatible (strict equal).
Returns false if errorLike is not an instance of Error, because instances
can only be compatible if they're both error instances.
### .compatibleConstructor(thrown, errorLike)

Checks if two constructors are compatible.
This function can receive either an error constructor or
an error instance as the `errorLike` argument.
Constructors are compatible if they're the same or if one is
an instance of another.
### .compatibleMessage(thrown, errMatcher)

Checks if an error's message is compatible with a matcher (String or RegExp).
If the message contains the String or passes the RegExp test,
it is considered compatible.
### .getFunctionName(constructorFn)

Returns the name of a function.
This also includes a polyfill function if `constructorFn.name` is not defined.
### .getConstructorName(errorLike)

Gets the constructor name for an Error instance or constructor itself.
### .getMessage(errorLike)

Gets the error message from an error.
If `err` is a String itself, we return it.
If the error has no message, we return an empty string.
globals Symbol: true, Uint8Array: true, WeakMap: true
deep-eql
Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
Module dependencies
Check to see if the MemoizeMap has recorded a result of the two operands
Set the result of the equality into the MemoizeMap
Primary Export
Assert deeply nested sameValue equality between two objects of any type.
Many comparisons can be canceled out early via simple equality or primitive checks.
The main logic of the `deepEqual` function.
Compare two Regular Expressions for equality.
Compare two Sets/Maps for equality. Faster than other equality functions.
Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
Simple equality for generator objects such as those returned by generator functions.
Determine if the given object has an @@iterator function.
Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
This will consume the iterator - which could have side effects depending on the @@iterator implementation.
Gets all entries from a Generator. This will consume the generator - which could have side effects.
Gets all own and inherited enumerable keys from a target.
Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
each key. If any value of the given key is not equal, the function will return false (early).
Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
for each enumerable key in the object.
Returns true if the argument is a primitive.

This intentionally returns true for all objects that can be compared by reference,
including functions and symbols.
!
type-detect
Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
MIT Licensed
### typeOf (obj)

Uses `Object.prototype.toString` to determine the type of an object,
normalising behaviour across engine versions & well optimised.
! Speed optimisation
Pre:
  string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
  boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
  number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
  undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
  function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
Post:
  string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
  boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
  number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
  undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
  function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
! Speed optimisation
Pre:
  null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
Post:
  null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
! Spec Conformance
Test: `Object.prototype.toString.call(window)``
 - Node === "[object global]"
 - Chrome === "[object global]"
 - Firefox === "[object Window]"
 - PhantomJS === "[object Window]"
 - Safari === "[object Window]"
 - IE 11 === "[object Window]"
 - IE Edge === "[object Window]"
Test: `Object.prototype.toString.call(this)``
 - Chrome Worker === "[object global]"
 - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
 - Safari Worker === "[object DedicatedWorkerGlobalScope]"
 - IE 11 Worker === "[object WorkerGlobalScope]"
 - IE Edge Worker === "[object WorkerGlobalScope]"
! Speed optimisation
Pre:
  array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
Post:
  array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
! Spec Conformance
(https://html.spec.whatwg.org/multipage/browsers.html#location)
WhatWG HTML$7.7.3 - The `Location` interface
Test: `Object.prototype.toString.call(window.location)``
 - IE <=11 === "[object Object]"
 - IE Edge <=13 === "[object Object]"
! Spec Conformance
(https://html.spec.whatwg.org/#document)
WhatWG HTML$3.1.1 - The `Document` object
Note: Most browsers currently adher to the W3C DOM Level 2 spec
      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
      which suggests that browsers should use HTMLTableCellElement for
      both TD and TH elements. WhatWG separates these.
      WhatWG HTML states:
        > For historical reasons, Window objects must also have a
        > writable, configurable, non-enumerable property named
        > HTMLDocument whose value is the Document interface object.
Test: `Object.prototype.toString.call(document)``
 - Chrome === "[object HTMLDocument]"
 - Firefox === "[object HTMLDocument]"
 - Safari === "[object HTMLDocument]"
 - IE <=10 === "[object Document]"
 - IE 11 === "[object HTMLDocument]"
 - IE Edge <=13 === "[object HTMLDocument]"
! Spec Conformance
(https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
Test: `Object.prototype.toString.call(navigator.mimeTypes)``
 - IE <=10 === "[object MSMimeTypesCollection]"
! Spec Conformance
(https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
Test: `Object.prototype.toString.call(navigator.plugins)``
 - IE <=10 === "[object MSPluginsCollection]"
! Spec Conformance
(https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
 - IE <=10 === "[object HTMLBlockElement]"
! Spec Conformance
(https://html.spec.whatwg.org/#htmltabledatacellelement)
WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
Note: Most browsers currently adher to the W3C DOM Level 2 spec
      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
      which suggests that browsers should use HTMLTableCellElement for
      both TD and TH elements. WhatWG separates these.
Test: Object.prototype.toString.call(document.createElement('td'))
 - Chrome === "[object HTMLTableCellElement]"
 - Firefox === "[object HTMLTableCellElement]"
 - Safari === "[object HTMLTableCellElement]"
! Spec Conformance
(https://html.spec.whatwg.org/#htmltableheadercellelement)
WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
Note: Most browsers currently adher to the W3C DOM Level 2 spec
      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
      which suggests that browsers should use HTMLTableCellElement for
      both TD and TH elements. WhatWG separates these.
Test: Object.prototype.toString.call(document.createElement('th'))
 - Chrome === "[object HTMLTableCellElement]"
 - Firefox === "[object HTMLTableCellElement]"
 - Safari === "[object HTMLTableCellElement]"
! Speed optimisation
Pre:
  Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
  Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
  Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
  Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
  Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
  Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
  Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
  Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
  Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
Post:
  Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
  Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
  Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
  Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
  Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
  Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
  Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
  Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
  Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
! Speed optimisation
Pre:
  regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
  regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
Post:
  regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
  regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
! Speed optimisation
Pre:
  date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
Post:
  date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
Test: `Object.prototype.toString.call(Promise.resolve())``
 - Chrome <=47 === "[object Object]"
 - Edge <=20 === "[object Object]"
 - Firefox 29-Latest === "[object Promise]"
 - Safari 7.1-Latest === "[object Promise]"
! Speed optimisation
Pre:
  set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
Post:
  set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
! Speed optimisation
Pre:
  map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
Post:
  map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
! Speed optimisation
Pre:
  weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
Post:
  weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
! Speed optimisation
Pre:
  weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
Post:
  weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
 - Edge <=13 === "[object Object]"
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
Test: `Object.prototype.toString.call(new Map().entries())``
 - Edge <=13 === "[object Object]"
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
Test: `Object.prototype.toString.call(new Set().entries())``
 - Edge <=13 === "[object Object]"
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
Test: `Object.prototype.toString.call([][Symbol.iterator]())``
 - Edge <=13 === "[object Object]"
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
 - Edge <=13 === "[object Object]"
! Speed optimisation
Pre:
  object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
Post:
  object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
!
Chai - getFuncName utility
Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
MIT Licensed
### .getFuncName(constructorFn)

Returns the name of a function.
When a non-function instance is passed, returns `null`.
This also includes a polyfill function if `aFunc.name` is not defined.
!
Chai - pathval utility
Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
### .hasProperty(object, name)

This allows checking whether an object has own
or inherited from prototype chain named property.

Basically does the same thing as the `in`
operator but works properly with null/undefined values
and other primitives.

    var obj = {
        arr: ['a', 'b', 'c']
      , str: 'Hello'
    }

The following would be the results.

    hasProperty(obj, 'str');  // true
    hasProperty(obj, 'constructor');  // true
    hasProperty(obj, 'bar');  // false

    hasProperty(obj.str, 'length'); // true
    hasProperty(obj.str, 1);  // true
    hasProperty(obj.str, 5);  // false

    hasProperty(obj.arr, 'length');  // true
    hasProperty(obj.arr, 2);  // true
    hasProperty(obj.arr, 3);  // false
!
## parsePath(path)

Helper function used to parse string object
paths. Use in conjunction with `internalGetPathValue`.

     var parsed = parsePath('myobject.property.subprop');

### Paths:

* Can be infinitely deep and nested.
* Arrays are also valid using the formal `myobject.document[3].property`.
* Literal dots and brackets (not delimiter) must be backslash-escaped.
!
## internalGetPathValue(obj, parsed[, pathDepth])

Helper companion function for `.parsePath` that returns
the value located at the parsed address.

     var value = getPathValue(obj, parsed);
!
## internalSetPathValue(obj, value, parsed)

Companion function for `parsePath` that sets
the value located at a parsed address.

 internalSetPathValue(obj, 'value', parsed);
### .getPathInfo(object, path)

This allows the retrieval of property info in an
object given a string path.

The path info consists of an object with the
following properties:

* parent - The parent object of the property referenced by `path`
* name - The name of the final property, a number if it was an array indexer
* value - The value of the property, if it exists, otherwise `undefined`
* exists - Whether the property exists or not
### .getPathValue(object, path)

This allows the retrieval of values in an
object given a string path.

    var obj = {
        prop1: {
            arr: ['a', 'b', 'c']
          , str: 'Hello'
        }
      , prop2: {
            arr: [ { nested: 'Universe' } ]
          , str: 'Hello again!'
        }
    }

The following would be the results.

    getPathValue(obj, 'prop1.str'); // Hello
    getPathValue(obj, 'prop1.att[2]'); // b
    getPathValue(obj, 'prop2.arr[0].nested'); // Universe
### .setPathValue(object, path, value)

Define the value in an object at a given string path.

```js
var obj = {
    prop1: {
        arr: ['a', 'b', 'c']
      , str: 'Hello'
    }
  , prop2: {
        arr: [ { nested: 'Universe' } ]
      , str: 'Hello again!'
    }
};
```

The following would be acceptable.

```js
var properties = require('tea-properties');
properties.set(obj, 'prop1.str', 'Hello Universe!');
properties.set(obj, 'prop1.arr[2]', 'B');
properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
```
!
type-detect
Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
MIT Licensed
### typeOf (obj)

Uses `Object.prototype.toString` to determine the type of an object,
normalising behaviour across engine versions & well optimised.
! Speed optimisation
Pre:
  string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
  boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
  number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
  undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
  function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
Post:
  string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
  boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
  number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
  undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
  function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
! Speed optimisation
Pre:
  null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
Post:
  null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
! Spec Conformance
Test: `Object.prototype.toString.call(window)``
 - Node === "[object global]"
 - Chrome === "[object global]"
 - Firefox === "[object Window]"
 - PhantomJS === "[object Window]"
 - Safari === "[object Window]"
 - IE 11 === "[object Window]"
 - IE Edge === "[object Window]"
Test: `Object.prototype.toString.call(this)``
 - Chrome Worker === "[object global]"
 - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
 - Safari Worker === "[object DedicatedWorkerGlobalScope]"
 - IE 11 Worker === "[object WorkerGlobalScope]"
 - IE Edge Worker === "[object WorkerGlobalScope]"
! Speed optimisation
Pre:
  array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
Post:
  array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
! Spec Conformance
(https://html.spec.whatwg.org/multipage/browsers.html#location)
WhatWG HTML$7.7.3 - The `Location` interface
Test: `Object.prototype.toString.call(window.location)``
 - IE <=11 === "[object Object]"
 - IE Edge <=13 === "[object Object]"
! Spec Conformance
(https://html.spec.whatwg.org/#document)
WhatWG HTML$3.1.1 - The `Document` object
Note: Most browsers currently adher to the W3C DOM Level 2 spec
      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
      which suggests that browsers should use HTMLTableCellElement for
      both TD and TH elements. WhatWG separates these.
      WhatWG HTML states:
        > For historical reasons, Window objects must also have a
        > writable, configurable, non-enumerable property named
        > HTMLDocument whose value is the Document interface object.
Test: `Object.prototype.toString.call(document)``
 - Chrome === "[object HTMLDocument]"
 - Firefox === "[object HTMLDocument]"
 - Safari === "[object HTMLDocument]"
 - IE <=10 === "[object Document]"
 - IE 11 === "[object HTMLDocument]"
 - IE Edge <=13 === "[object HTMLDocument]"
! Spec Conformance
(https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
Test: `Object.prototype.toString.call(navigator.mimeTypes)``
 - IE <=10 === "[object MSMimeTypesCollection]"
! Spec Conformance
(https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
Test: `Object.prototype.toString.call(navigator.plugins)``
 - IE <=10 === "[object MSPluginsCollection]"
! Spec Conformance
(https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
 - IE <=10 === "[object HTMLBlockElement]"
! Spec Conformance
(https://html.spec.whatwg.org/#htmltabledatacellelement)
WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
Note: Most browsers currently adher to the W3C DOM Level 2 spec
      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
      which suggests that browsers should use HTMLTableCellElement for
      both TD and TH elements. WhatWG separates these.
Test: Object.prototype.toString.call(document.createElement('td'))
 - Chrome === "[object HTMLTableCellElement]"
 - Firefox === "[object HTMLTableCellElement]"
 - Safari === "[object HTMLTableCellElement]"
! Spec Conformance
(https://html.spec.whatwg.org/#htmltableheadercellelement)
WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
Note: Most browsers currently adher to the W3C DOM Level 2 spec
      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
      which suggests that browsers should use HTMLTableCellElement for
      both TD and TH elements. WhatWG separates these.
Test: Object.prototype.toString.call(document.createElement('th'))
 - Chrome === "[object HTMLTableCellElement]"
 - Firefox === "[object HTMLTableCellElement]"
 - Safari === "[object HTMLTableCellElement]"
! Speed optimisation
Pre:
  Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
  Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
  Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
  Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
  Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
  Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
  Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
  Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
  Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
Post:
  Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
  Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
  Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
  Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
  Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
  Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
  Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
  Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
  Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
! Speed optimisation
Pre:
  regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
  regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
Post:
  regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
  regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
! Speed optimisation
Pre:
  date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
Post:
  date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
Test: `Object.prototype.toString.call(Promise.resolve())``
 - Chrome <=47 === "[object Object]"
 - Edge <=20 === "[object Object]"
 - Firefox 29-Latest === "[object Promise]"
 - Safari 7.1-Latest === "[object Promise]"
! Speed optimisation
Pre:
  set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
Post:
  set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
! Speed optimisation
Pre:
  map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
Post:
  map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
! Speed optimisation
Pre:
  weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
Post:
  weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
! Speed optimisation
Pre:
  weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
Post:
  weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
 - Edge <=13 === "[object Object]"
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
Test: `Object.prototype.toString.call(new Map().entries())``
 - Edge <=13 === "[object Object]"
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
Test: `Object.prototype.toString.call(new Set().entries())``
 - Edge <=13 === "[object Object]"
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
Test: `Object.prototype.toString.call([][Symbol.iterator]())``
 - Edge <=13 === "[object Object]"
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
 - Edge <=13 === "[object Object]"
! Speed optimisation
Pre:
  object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
Post:
  object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)









```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
```

```shell
# With shell, you can just pass the correct header with each request
curl "api_endpoint_here"
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require('kittn');

let api = kittn.authorize('meowmeowmeow');
```

> Make sure to replace `meowmeowmeow` with your API key.

Kittn uses API keys to allow access to the API. You can register a new Kittn API key at our [developer portal](http://example.com/developers).

Kittn expects for the API key to be included in all API requests to the server in a header that looks like the following:

`Authorization: meowmeowmeow`

<aside class="notice">
You must replace <code>meowmeowmeow</code> with your personal API key.
</aside>

# Kittens

## Get All Kittens

```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
api.kittens.get
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
api.kittens.get()
```

```shell
curl "http://example.com/api/kittens"
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require('kittn');

let api = kittn.authorize('meowmeowmeow');
let kittens = api.kittens.get();
```

> The above command returns JSON structured like this:

```json
[
  {
    "id": 1,
    "name": "Fluffums",
    "breed": "calico",
    "fluffiness": 6,
    "cuteness": 7
  },
  {
    "id": 2,
    "name": "Max",
    "breed": "unknown",
    "fluffiness": 5,
    "cuteness": 10
  }
]
```

This endpoint retrieves all kittens.

### HTTP Request

`GET http://example.com/api/kittens`

### Query Parameters

Parameter | Default | Description
--------- | ------- | -----------
include_cats | false | If set to true, the result will also include cats.
available | true | If set to false, the result will include kittens that have already been adopted.

<aside class="success">
Remember — a happy kitten is an authenticated kitten!
</aside>

## Get a Specific Kitten

```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
api.kittens.get(2)
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
api.kittens.get(2)
```

```shell
curl "http://example.com/api/kittens/2"
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require('kittn');

let api = kittn.authorize('meowmeowmeow');
let max = api.kittens.get(2);
```

> The above command returns JSON structured like this:

```json
{
  "id": 2,
  "name": "Max",
  "breed": "unknown",
  "fluffiness": 5,
  "cuteness": 10
}
```

This endpoint retrieves a specific kitten.

<aside class="warning">Inside HTML code blocks like this one, you can't use Markdown, so use <code>&lt;code&gt;</code> blocks to denote code.</aside>

### HTTP Request

`GET http://example.com/kittens/<ID>`

### URL Parameters

Parameter | Description
--------- | -----------
ID | The ID of the kitten to retrieve

