<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Reference</title>

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .cd {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .nl {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[&quot;shell&quot;,&quot;ruby&quot;,&quot;python&quot;,&quot;javascript&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <img src="images/logo.png" alt="Logo" />
        <div class="lang-selector">
              <a href="#" data-language-name="shell">shell</a>
              <a href="#" data-language-name="ruby">ruby</a>
              <a href="#" data-language-name="python">python</a>
              <a href="#" data-language-name="javascript">javascript</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href='#'>Sign Up for a Developer Key</a></li>
            <li><a href='https://github.com/tripit/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="introduction">Introduction</h1>

<p>The Chai API is broken down by style or task.</p>

<h2 id="assertion-styles">Assertion Styles</h2>

<p>The Expect / Should API covers the BDD assertion styles.
The Assert API covers the TDD assertion style.</p>

<h3 id="plugins">Plugins</h3>

<p>The Plugin API will be of use to anyone interested in building plugins as helpers to DRY up your tests, or for release to the community.</p>

<h3 id="tools">Tools</h3>

<p>The Online Test Suite is a live run of Chai’s test suite. Use it to ensure browser compatibility.</p>

<h1 id="assert">Assert</h1>

<p>The assert style is very similar to node.js’ included assert module, with a bit of extra sugar. 
Of the three style options, assert is the only one that is not chainable. Check out the <a href="http://chaijs.com/guide/styles/">Style Guide</a> for a comparison.</p>

<h2 id="api-reference">API Reference</h2>

<h3 id="assert-expression-message">assert(expression, message)</h3>

<ul>
<li>@param { Mixed } expression to test for truthiness</li>
<li>@param { String } message to display on error
Write your own test expressions.</li>
</ul>
<pre class="highlight javascript tab-javascript"><code><span class="nx">assert</span><span class="p">(</span><span class="s1">'foo'</span> <span class="o">!==</span> <span class="s1">'bar'</span><span class="p">,</span> <span class="s1">'foo is not bar'</span><span class="p">);</span>
<span class="nx">assert</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">([]),</span> <span class="s1">'empty arrays are arrays'</span><span class="p">);</span>
</code></pre>
<h3 id="fail-actual-expected-message-operator">.fail(actual, expected, [message], [operator])</h3>

<ul>
<li>@param { Mixed } actual</li>
<li>@param { Mixed } expected</li>
<li>@param { String } message</li>
<li>@param { String } operator</li>
</ul>

<p>Throw a failure. Node.js assert module-compatible.</p>

<h3 id="isok-object-message">.isOk(object, [message])</h3>

<ul>
<li>@param { Mixed } object to test</li>
<li>@param { String } message
Asserts that object is truthy.</li>
</ul>
<pre class="highlight javascript tab-javascript"><code><span class="nx">assert</span><span class="p">.</span><span class="nx">isOk</span><span class="p">(</span><span class="s1">'everything'</span><span class="p">,</span> <span class="s1">'everything is ok'</span><span class="p">);</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">isOk</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="s1">'this will fail'</span><span class="p">);</span>
</code></pre>
<p>chai
Copyright&copy; 2011-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed
Chai version
Assertion Error
Utils for plugins (not exported)</p>

<h1 id="use-function">.use(function)</h1>

<p>Provides a way to extend the internals of Chai.
Utility Functions
Configuration
Primary <code class="prettyprint">Assertion</code> prototype
Core Assertions
Expect interface
Should interface
Assert interface
chai
http://chaijs.com
Copyright&copy; 2011-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed
Module dependencies.
Module export.
Assertion Constructor</p>

<p>Creates object for chaining.</p>

<p><code class="prettyprint">Assertion</code> objects contain metadata in the form of flags. Three flags can
be assigned during instantiation by passing arguments to this constructor:</p>

<ul>
<li><p><code class="prettyprint">object</code>: This flag contains the target of the assertion. For example, in
the assertion <code class="prettyprint">expect(numKittens).to.equal(7);</code>, the <code class="prettyprint">object</code> flag will
contain <code class="prettyprint">numKittens</code> so that the <code class="prettyprint">equal</code> assertion can reference it when
needed.</p></li>
<li><p><code class="prettyprint">message</code>: This flag contains an optional custom error message to be
prepended to the error message that&rsquo;s generated by the assertion when it
fails.</p></li>
<li><p><code class="prettyprint">ssfi</code>: This flag stands for &ldquo;start stack function indicator&rdquo;. It
contains a function reference that serves as the starting point for
removing frames from the stack trace of the error that&rsquo;s created by the
assertion when it fails. The goal is to provide a cleaner stack trace to
end users by removing Chai&rsquo;s internal functions. Note that it only works
in environments that support <code class="prettyprint">Error.captureStackTrace</code>, and only when
<code class="prettyprint">Chai.config.includeStack</code> hasn&rsquo;t been set to <code class="prettyprint">false</code>.</p></li>
<li><p><code class="prettyprint">lockSsfi</code>: This flag controls whether or not the given <code class="prettyprint">ssfi</code> flag
should retain its current value, even as assertions are chained off of
this object. This is usually set to <code class="prettyprint">true</code> when creating a new assertion
from within another assertion. It&rsquo;s also temporarily set to <code class="prettyprint">true</code> before
an overwritten assertion gets called by the overwriting assertion.</p>

<h2 id="assert-expression-message-negatemessage-expected-actual-showdiff">.assert(expression, message, negateMessage, expected, actual, showDiff)</h2></li>
</ul>

<p>Executes an expression and check expectations. Throws AssertionError for reporting if test doesn&rsquo;t pass.</p>

<h2 id="_obj">._obj</h2>

<p>Quick reference to stored <code class="prettyprint">actual</code> value for plugin developers.</p>

<h2 id="config-includestack">config.includeStack</h2>

<p>User configurable property, influences whether stack trace
is included in Assertion error message. Default of false
suppresses stack trace in the error message.</p>

<p>chai.config.includeStack = true;  // enable stack on error</p>

<h2 id="config-showdiff">config.showDiff</h2>

<p>User configurable property, influences whether or not
the <code class="prettyprint">showDiff</code> flag should be included in the thrown
AssertionErrors. <code class="prettyprint">false</code> will always be <code class="prettyprint">false</code>; <code class="prettyprint">true</code>
will be true when the assertion has requested a diff
be shown.</p>

<h2 id="config-truncatethreshold">config.truncateThreshold</h2>

<p>User configurable property, sets length threshold for actual and
expected values in assertion errors. If this threshold is exceeded, for
example for large data structures, the value is replaced with something
like <code class="prettyprint">[ Array(3) ]</code> or <code class="prettyprint">{ Object (prop1, prop2) }</code>.</p>

<p>Set it to zero if you want to disable truncating altogether.</p>

<p>This is especially userful when doing assertions on arrays: having this
set to a reasonable large value makes the failure messages readily
inspectable.</p>

<p>chai.config.truncateThreshold = 0;  // disable truncating</p>

<h2 id="config-useproxy">config.useProxy</h2>

<p>User configurable property, defines if chai will use a Proxy to throw
an error when a non-existent property is read, which protects users
from typos when using property-based assertions.</p>

<p>Set it to false if you want to disable this feature.</p>

<p>chai.config.useProxy = false;  // disable use of Proxy</p>

<p>This feature is automatically disabled regardless of this config value
in environments that don&rsquo;t support proxies.</p>

<h2 id="config-proxyexcludedkeys">config.proxyExcludedKeys</h2>

<p>User configurable property, defines which properties should be ignored
instead of throwing an error if they do not exist on the assertion.
This is only applied if the environment Chai is running in supports proxies and
if the <code class="prettyprint">useProxy</code> configuration setting is enabled.
By default, <code class="prettyprint">then</code> and <code class="prettyprint">inspect</code> will not throw an error if they do not exist on the
assertion object because the <code class="prettyprint">.inspect</code> property is read by <code class="prettyprint">util.inspect</code> (for example, when
using <code class="prettyprint">console.log</code> on the assertion object) and <code class="prettyprint">.then</code> is necessary for promise type-checking.</p>

<p>// By default these keys will not throw an error if they do not exist on the assertion object
    chai.config.proxyExcludedKeys = [&lsquo;then&rsquo;, &lsquo;inspect&rsquo;];
chai
http://chaijs.com
Copyright&copy; 2011-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="language-chains">Language Chains</h2>

<p>The following are provided as chainable getters to improve the readability
of your assertions.</p>

<p><strong>Chains</strong></p>

<ul>
<li>to</li>
<li>be</li>
<li>been</li>
<li>is</li>
<li>that</li>
<li>which</li>
<li>and</li>
<li>has</li>
<li>have</li>
<li>with</li>
<li>at</li>
<li>of</li>
<li>same</li>
<li>but</li>
<li>does
## .not</li>
</ul>

<p>Negates all assertions that follow in the chain.</p>

<p>expect(function () {}).to.not.throw();
    expect({a: 1}).to.not.have.property(&lsquo;b&rsquo;);
    expect([1, 2]).to.be.an(&lsquo;array&rsquo;).that.does.not.include(3);</p>

<p>Just because you can negate any assertion with <code class="prettyprint">.not</code> doesn&rsquo;t mean you
should. With great power comes great responsibility. It&rsquo;s often best to
assert that the one expected output was produced, rather than asserting
that one of countless unexpected outputs wasn&rsquo;t produced. See individual
assertions for specific guidance.</p>

<p>expect(2).to.equal(2); // Recommended
    expect(2).to.not.equal(1); // Not recommended</p>

<h2 id="deep">.deep</h2>

<p>Causes all <code class="prettyprint">.equal</code>, <code class="prettyprint">.include</code>, <code class="prettyprint">.members</code>, <code class="prettyprint">.keys</code>, and <code class="prettyprint">.property</code>
assertions that follow in the chain to use deep equality instead of strict
(<code class="prettyprint">===</code>) equality. See the <code class="prettyprint">deep-eql</code> project page for info on the deep
equality algorithm: https://github.com/chaijs/deep-eql.</p>

<p>// Target object deeply (but not strictly) equals <code class="prettyprint">{a: 1}</code>
    expect({a: 1}).to.deep.equal({a: 1});
    expect({a: 1}).to.not.equal({a: 1});</p>

<p>// Target array deeply (but not strictly) includes <code class="prettyprint">{a: 1}</code>
    expect([{a: 1}]).to.deep.include({a: 1});
    expect([{a: 1}]).to.not.include({a: 1});</p>

<p>// Target object deeply (but not strictly) includes <code class="prettyprint">x: {a: 1}</code>
    expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
    expect({x: {a: 1}}).to.not.include({x: {a: 1}});</p>

<p>// Target array deeply (but not strictly) has member <code class="prettyprint">{a: 1}</code>
    expect([{a: 1}]).to.have.deep.members([{a: 1}]);
    expect([{a: 1}]).to.not.have.members([{a: 1}]);</p>

<p>// Target set deeply (but not strictly) has key <code class="prettyprint">{a: 1}</code>
    expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
    expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);</p>

<p>// Target object deeply (but not strictly) has property <code class="prettyprint">x: {a: 1}</code>
    expect({x: {a: 1}}).to.have.deep.property(&lsquo;x&rsquo;, {a: 1});
    expect({x: {a: 1}}).to.not.have.property(&lsquo;x&rsquo;, {a: 1});</p>

<h2 id="nested">.nested</h2>

<p>Enables dot- and bracket-notation in all <code class="prettyprint">.property</code> and <code class="prettyprint">.include</code>
assertions that follow in the chain.</p>

<p>expect({a: {b: [&lsquo;x&rsquo;, &lsquo;y&rsquo;]}}).to.have.nested.property(&lsquo;a.b[1]&rsquo;);
    expect({a: {b: [&lsquo;x&rsquo;, &lsquo;y&rsquo;]}}).to.nested.include({&lsquo;a.b[1]&rsquo;: &lsquo;y&rsquo;});</p>

<p>If <code class="prettyprint">.</code> or <code class="prettyprint">[]</code> are part of an actual property name, they can be escaped by
adding two backslashes before them.</p>

<p>expect({&lsquo;.a&rsquo;: {&lsquo;[b]&rsquo;: &lsquo;x&rsquo;}}).to.have.nested.property(&lsquo;.a.\[b\]&rsquo;);
    expect({&lsquo;.a&rsquo;: {&lsquo;[b]&rsquo;: &lsquo;x&rsquo;}}).to.nested.include({&lsquo;.a.\[b\]&rsquo;: &lsquo;x&rsquo;});</p>

<p><code class="prettyprint">.nested</code> cannot be combined with <code class="prettyprint">.own</code>.</p>

<h2 id="own">.own</h2>

<p>Causes all <code class="prettyprint">.property</code> and <code class="prettyprint">.include</code> assertions that follow in the chain
to ignore inherited properties.</p>

<p>Object.prototype.b = 2;</p>

<p>expect({a: 1}).to.have.own.property(&lsquo;a&rsquo;);
    expect({a: 1}).to.have.property(&lsquo;b&rsquo;).but.not.own.property(&lsquo;b&rsquo;); </p>

<p>expect({a: 1}).to.own.include({a: 1});
    expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});</p>

<p><code class="prettyprint">.own</code> cannot be combined with <code class="prettyprint">.nested</code>.</p>

<h2 id="ordered">.ordered</h2>

<p>Causes all <code class="prettyprint">.members</code> assertions that follow in the chain to require that
members be in the same order.</p>

<p>expect([1, 2]).to.have.ordered.members([1, 2])
      .but.not.have.ordered.members([2, 1]);</p>

<p>When <code class="prettyprint">.include</code> and <code class="prettyprint">.ordered</code> are combined, the ordering begins at the
start of both arrays.</p>

<p>expect([1, 2, 3]).to.include.ordered.members([1, 2])
      .but.not.include.ordered.members([2, 3]);</p>

<h2 id="any">.any</h2>

<p>Causes all <code class="prettyprint">.keys</code> assertions that follow in the chain to only require that
the target have at least one of the given keys. This is the opposite of
<code class="prettyprint">.all</code>, which requires that the target have all of the given keys.</p>

<p>expect({a: 1, b: 2}).to.not.have.any.keys(&lsquo;c&rsquo;, &lsquo;d&rsquo;);</p>

<p>See the <code class="prettyprint">.keys</code> doc for guidance on when to use <code class="prettyprint">.any</code> or <code class="prettyprint">.all</code>.</p>

<h2 id="all">.all</h2>

<p>Causes all <code class="prettyprint">.keys</code> assertions that follow in the chain to require that the
target have all of the given keys. This is the opposite of <code class="prettyprint">.any</code>, which
only requires that the target have at least one of the given keys.</p>

<p>expect({a: 1, b: 2}).to.have.all.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);</p>

<p>Note that <code class="prettyprint">.all</code> is used by default when neither <code class="prettyprint">.all</code> nor <code class="prettyprint">.any</code> are
added earlier in the chain. However, it&rsquo;s often best to add <code class="prettyprint">.all</code> anyway
because it improves readability.</p>

<p>See the <code class="prettyprint">.keys</code> doc for guidance on when to use <code class="prettyprint">.any</code> or <code class="prettyprint">.all</code>.</p>

<h2 id="a-type-msg">.a(type[, msg])</h2>

<p>Asserts that the target&rsquo;s type is equal to the given string <code class="prettyprint">type</code>. Types
are case insensitive. See the <code class="prettyprint">type-detect</code> project page for info on the
type detection algorithm: https://github.com/chaijs/type-detect.</p>

<p>expect(&lsquo;foo&rsquo;).to.be.a(&lsquo;string&rsquo;);
    expect({a: 1}).to.be.an(&lsquo;object&rsquo;);
    expect(null).to.be.a(&lsquo;null&rsquo;);
    expect(undefined).to.be.an(&lsquo;undefined&rsquo;);
    expect(new Error).to.be.an(&lsquo;error&rsquo;);
    expect(Promise.resolve()).to.be.a(&lsquo;promise&rsquo;);
    expect(new Float32Array).to.be.a(&lsquo;float32array&rsquo;);
    expect(Symbol()).to.be.a(&lsquo;symbol&rsquo;);</p>

<p><code class="prettyprint">.a</code> supports objects that have a custom type set via <code class="prettyprint">Symbol.toStringTag</code>.</p>

<p>var myObj = {
      [Symbol.toStringTag]: &lsquo;myCustomType&rsquo;
    };</p>

<p>expect(myObj).to.be.a(&lsquo;myCustomType&rsquo;).but.not.an(&lsquo;object&rsquo;);</p>

<p>It&rsquo;s often best to use <code class="prettyprint">.a</code> to check a target&rsquo;s type before making more
assertions on the same target. That way, you avoid unexpected behavior from
any assertion that does different things based on the target&rsquo;s type.</p>

<p>expect([1, 2, 3]).to.be.an(&lsquo;array&rsquo;).that.includes(2);
    expect([]).to.be.an(&lsquo;array&rsquo;).that.is.empty;</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.a</code>. However, it&rsquo;s often best to
assert that the target is the expected type, rather than asserting that it
isn&rsquo;t one of many unexpected types.</p>

<p>expect(&lsquo;foo&rsquo;).to.be.a(&lsquo;string&rsquo;); // Recommended
    expect(&lsquo;foo&rsquo;).to.not.be.an(&lsquo;array&rsquo;); // Not recommended</p>

<p><code class="prettyprint">.a</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error message to
show when the assertion fails. The message can also be given as the second
argument to <code class="prettyprint">expect</code>.</p>

<p>expect(1).to.be.a(&lsquo;string&rsquo;, &lsquo;nooo why fail??&rsquo;);
    expect(1, &lsquo;nooo why fail??&rsquo;).to.be.a(&lsquo;string&rsquo;);</p>

<p><code class="prettyprint">.a</code> can also be used as a language chain to improve the readability of
your assertions. </p>

<p>expect({b: 2}).to.have.a.property(&lsquo;b&rsquo;);</p>

<p>The alias <code class="prettyprint">.an</code> can be used interchangeably with <code class="prettyprint">.a</code>.</p>

<h2 id="include-val-msg">.include(val[, msg])</h2>

<p>When the target is a string, <code class="prettyprint">.include</code> asserts that the given string <code class="prettyprint">val</code>
is a substring of the target.</p>

<p>expect(&lsquo;foobar&rsquo;).to.include(&lsquo;foo&rsquo;);</p>

<p>When the target is an array, <code class="prettyprint">.include</code> asserts that the given <code class="prettyprint">val</code> is a
member of the target.</p>

<p>expect([1, 2, 3]).to.include(2);</p>

<p>When the target is an object, <code class="prettyprint">.include</code> asserts that the given object
<code class="prettyprint">val</code>&lsquo;s properties are a subset of the target&rsquo;s properties.</p>

<p>expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});</p>

<p>When the target is a Set or WeakSet, <code class="prettyprint">.include</code> asserts that the given <code class="prettyprint">val</code> is a
member of the target. SameValueZero equality algorithm is used.</p>

<p>expect(new Set([1, 2])).to.include(2);</p>

<p>When the target is a Map, <code class="prettyprint">.include</code> asserts that the given <code class="prettyprint">val</code> is one of
the values of the target. SameValueZero equality algorithm is used.</p>

<p>expect(new Map([[&#39;a&rsquo;, 1], [&lsquo;b&rsquo;, 2]])).to.include(2);</p>

<p>Because <code class="prettyprint">.include</code> does different things based on the target&rsquo;s type, it&rsquo;s
important to check the target&rsquo;s type before using <code class="prettyprint">.include</code>. See the <code class="prettyprint">.a</code>
doc for info on testing a target&rsquo;s type.</p>

<p>expect([1, 2, 3]).to.be.an(&lsquo;array&rsquo;).that.includes(2);</p>

<p>By default, strict (<code class="prettyprint">===</code>) equality is used to compare array members and
object properties. Add <code class="prettyprint">.deep</code> earlier in the chain to use deep equality
instead (WeakSet targets are not supported). See the <code class="prettyprint">deep-eql</code> project
page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p>

<p>// Target array deeply (but not strictly) includes <code class="prettyprint">{a: 1}</code>
    expect([{a: 1}]).to.deep.include({a: 1});
    expect([{a: 1}]).to.not.include({a: 1});</p>

<p>// Target object deeply (but not strictly) includes <code class="prettyprint">x: {a: 1}</code>
    expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
    expect({x: {a: 1}}).to.not.include({x: {a: 1}});</p>

<p>By default, all of the target&rsquo;s properties are searched when working with
objects. This includes properties that are inherited and/or non-enumerable.
Add <code class="prettyprint">.own</code> earlier in the chain to exclude the target&rsquo;s inherited
properties from the search.</p>

<p>Object.prototype.b = 2;</p>

<p>expect({a: 1}).to.own.include({a: 1});
    expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});</p>

<p>Note that a target object is always only searched for <code class="prettyprint">val</code>&lsquo;s own
enumerable properties.</p>

<p><code class="prettyprint">.deep</code> and <code class="prettyprint">.own</code> can be combined.</p>

<p>expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});</p>

<p>Add <code class="prettyprint">.nested</code> earlier in the chain to enable dot- and bracket-notation when
referencing nested properties.</p>

<p>expect({a: {b: [&#39;x&rsquo;, &lsquo;y&rsquo;]}}).to.nested.include({&lsquo;a.b[1]&rsquo;: &lsquo;y&rsquo;});</p>

<p>If <code class="prettyprint">.</code> or <code class="prettyprint">[]</code> are part of an actual property name, they can be escaped by
adding two backslashes before them.</p>

<p>expect({&lsquo;.a&rsquo;: {&lsquo;[b]&rsquo;: 2}}).to.nested.include({&lsquo;.a.\[b\]&rsquo;: 2});</p>

<p><code class="prettyprint">.deep</code> and <code class="prettyprint">.nested</code> can be combined.</p>

<p>expect({a: {b: [{c: 3}]}}).to.deep.nested.include({&lsquo;a.b[0]&rsquo;: {c: 3}});</p>

<p><code class="prettyprint">.own</code> and <code class="prettyprint">.nested</code> cannot be combined.</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.include</code>.</p>

<p>expect(&lsquo;foobar&rsquo;).to.not.include(&lsquo;taco&rsquo;);
    expect([1, 2, 3]).to.not.include(4);</p>

<p>However, it&rsquo;s dangerous to negate <code class="prettyprint">.include</code> when the target is an object.
The problem is that it creates uncertain expectations by asserting that the
target object doesn&rsquo;t have all of <code class="prettyprint">val</code>&lsquo;s key/value pairs but may or may
not have some of them. It&rsquo;s often best to identify the exact output that&rsquo;s
expected, and then write an assertion that only accepts that exact output.</p>

<p>When the target object isn&rsquo;t even expected to have <code class="prettyprint">val</code>&rsquo;s keys, it&rsquo;s
often best to assert exactly that.</p>

<p>expect({c: 3}).to.not.have.any.keys(&#39;a&rsquo;, &lsquo;b&rsquo;); // Recommended
    expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended</p>

<p>When the target object is expected to have <code class="prettyprint">val</code>&lsquo;s keys, it&rsquo;s often best to
assert that each of the properties has its expected value, rather than
asserting that each property doesn&rsquo;t have one of many unexpected values.</p>

<p>expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
    expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended</p>

<p><code class="prettyprint">.include</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect([1, 2, 3]).to.include(4, &#39;nooo why fail??&rsquo;);
    expect([1, 2, 3], &lsquo;nooo why fail??&rsquo;).to.include(4);</p>

<p><code class="prettyprint">.include</code> can also be used as a language chain, causing all <code class="prettyprint">.members</code> and
<code class="prettyprint">.keys</code> assertions that follow in the chain to require the target to be a
superset of the expected set, rather than an identical set. Note that
<code class="prettyprint">.members</code> ignores duplicates in the subset when <code class="prettyprint">.include</code> is added.</p>

<p>// Target object&rsquo;s keys are a superset of [&lsquo;a&rsquo;, &lsquo;b&rsquo;] but not identical
    expect({a: 1, b: 2, c: 3}).to.include.all.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);
    expect({a: 1, b: 2, c: 3}).to.not.have.all.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);</p>

<p>// Target array is a superset of [1, 2] but not identical
    expect([1, 2, 3]).to.include.members([1, 2]);
    expect([1, 2, 3]).to.not.have.members([1, 2]);</p>

<p>// Duplicates in the subset are ignored
    expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);</p>

<p>Note that adding <code class="prettyprint">.any</code> earlier in the chain causes the <code class="prettyprint">.keys</code> assertion
to ignore <code class="prettyprint">.include</code>.</p>

<p>// Both assertions are identical
    expect({a: 1}).to.include.any.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);
    expect({a: 1}).to.have.any.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);</p>

<p>The aliases <code class="prettyprint">.includes</code>, <code class="prettyprint">.contain</code>, and <code class="prettyprint">.contains</code> can be used
interchangeably with <code class="prettyprint">.include</code>.</p>

<h2 id="ok">.ok</h2>

<p>Asserts that the target is loosely (<code class="prettyprint">==</code>) equal to <code class="prettyprint">true</code>. However, it&rsquo;s
often best to assert that the target is strictly (<code class="prettyprint">===</code>) or deeply equal to
its expected value.</p>

<p>expect(1).to.equal(1); // Recommended
    expect(1).to.be.ok; // Not recommended</p>

<p>expect(true).to.be.true; // Recommended
    expect(true).to.be.ok; // Not recommended</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.ok</code>.</p>

<p>expect(0).to.equal(0); // Recommended
    expect(0).to.not.be.ok; // Not recommended</p>

<p>expect(false).to.be.false; // Recommended
    expect(false).to.not.be.ok; // Not recommended</p>

<p>expect(null).to.be.null; // Recommended
    expect(null).to.not.be.ok; // Not recommended</p>

<p>expect(undefined).to.be.undefined; // Recommended
    expect(undefined).to.not.be.ok; // Not recommended</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(false, &lsquo;nooo why fail??&rsquo;).to.be.ok;</p>

<h2 id="true">.true</h2>

<p>Asserts that the target is strictly (<code class="prettyprint">===</code>) equal to <code class="prettyprint">true</code>.</p>

<p>expect(true).to.be.true;</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.true</code>. However, it&rsquo;s often best
to assert that the target is equal to its expected value, rather than not
equal to <code class="prettyprint">true</code>.</p>

<p>expect(false).to.be.false; // Recommended
    expect(false).to.not.be.true; // Not recommended</p>

<p>expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.true; // Not recommended</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(false, &lsquo;nooo why fail??&rsquo;).to.be.true;</p>

<h2 id="false">.false</h2>

<p>Asserts that the target is strictly (<code class="prettyprint">===</code>) equal to <code class="prettyprint">false</code>.</p>

<p>expect(false).to.be.false;</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.false</code>. However, it&rsquo;s often
best to assert that the target is equal to its expected value, rather than
not equal to <code class="prettyprint">false</code>.</p>

<p>expect(true).to.be.true; // Recommended
    expect(true).to.not.be.false; // Not recommended</p>

<p>expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.false; // Not recommended</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(true, &lsquo;nooo why fail??&rsquo;).to.be.false;</p>

<h2 id="null">.null</h2>

<p>Asserts that the target is strictly (<code class="prettyprint">===</code>) equal to <code class="prettyprint">null</code>.</p>

<p>expect(null).to.be.null;</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.null</code>. However, it&rsquo;s often best
to assert that the target is equal to its expected value, rather than not
equal to <code class="prettyprint">null</code>.</p>

<p>expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.null; // Not recommended</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(42, &lsquo;nooo why fail??&rsquo;).to.be.null;</p>

<h2 id="undefined">.undefined</h2>

<p>Asserts that the target is strictly (<code class="prettyprint">===</code>) equal to <code class="prettyprint">undefined</code>.</p>

<p>expect(undefined).to.be.undefined;</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.undefined</code>. However, it&rsquo;s often
best to assert that the target is equal to its expected value, rather than
not equal to <code class="prettyprint">undefined</code>.</p>

<p>expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.undefined; // Not recommended</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(42, &lsquo;nooo why fail??&rsquo;).to.be.undefined;</p>

<h2 id="nan">.NaN</h2>

<p>Asserts that the target is exactly <code class="prettyprint">NaN</code>.</p>

<p>expect(NaN).to.be.NaN;</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.NaN</code>. However, it&rsquo;s often best
to assert that the target is equal to its expected value, rather than not
equal to <code class="prettyprint">NaN</code>.</p>

<p>expect(&lsquo;foo&rsquo;).to.equal(&lsquo;foo&rsquo;); // Recommended
    expect(&lsquo;foo&rsquo;).to.not.be.NaN; // Not recommended</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(42, &lsquo;nooo why fail??&rsquo;).to.be.NaN;</p>

<h2 id="exist">.exist</h2>

<p>Asserts that the target is not strictly (<code class="prettyprint">===</code>) equal to either <code class="prettyprint">null</code> or
<code class="prettyprint">undefined</code>. However, it&rsquo;s often best to assert that the target is equal to
its expected value.</p>

<p>expect(1).to.equal(1); // Recommended
    expect(1).to.exist; // Not recommended</p>

<p>expect(0).to.equal(0); // Recommended
    expect(0).to.exist; // Not recommended</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.exist</code>.</p>

<p>expect(null).to.be.null; // Recommended
    expect(null).to.not.exist; // Not recommended</p>

<p>expect(undefined).to.be.undefined; // Recommended
    expect(undefined).to.not.exist; // Not recommended</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(null, &lsquo;nooo why fail??&rsquo;).to.exist;</p>

<h2 id="empty">.empty</h2>

<p>When the target is a string or array, <code class="prettyprint">.empty</code> asserts that the target&rsquo;s
<code class="prettyprint">length</code> property is strictly (<code class="prettyprint">===</code>) equal to <code class="prettyprint">0</code>.</p>

<p>expect([]).to.be.empty;
    expect(&ldquo;).to.be.empty;</p>

<p>When the target is a map or set, <code class="prettyprint">.empty</code> asserts that the target&rsquo;s <code class="prettyprint">size</code>
property is strictly equal to <code class="prettyprint">0</code>.</p>

<p>expect(new Set()).to.be.empty;
    expect(new Map()).to.be.empty;</p>

<p>When the target is a non-function object, <code class="prettyprint">.empty</code> asserts that the target
doesn&rsquo;t have any own enumerable properties. Properties with Symbol-based
keys are excluded from the count.</p>

<p>expect({}).to.be.empty;</p>

<p>Because <code class="prettyprint">.empty</code> does different things based on the target&rsquo;s type, it&rsquo;s
important to check the target&rsquo;s type before using <code class="prettyprint">.empty</code>. See the <code class="prettyprint">.a</code>
doc for info on testing a target&rsquo;s type.</p>

<p>expect([]).to.be.an(&lsquo;array&rsquo;).that.is.empty;</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.empty</code>. However, it&rsquo;s often
best to assert that the target contains its expected number of values,
rather than asserting that it&rsquo;s not empty.</p>

<p>expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.not.be.empty; // Not recommended</p>

<p>expect(new Set([1, 2, 3])).to.have.property(&lsquo;size&rsquo;, 3); // Recommended
    expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended</p>

<p>expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
    expect({a: 1}).to.not.be.empty; // Not recommended</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect([1, 2, 3], &lsquo;nooo why fail??&rsquo;).to.be.empty;</p>

<h2 id="arguments">.arguments</h2>

<p>Asserts that the target is an <code class="prettyprint">arguments</code> object.</p>

<p>function test () {
      expect(arguments).to.be.arguments;
    }</p>

<p>test();</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.arguments</code>. However, it&rsquo;s often
best to assert which type the target is expected to be, rather than
asserting that its not an <code class="prettyprint">arguments</code> object.</p>

<p>expect(&lsquo;foo&rsquo;).to.be.a(&lsquo;string&rsquo;); // Recommended
    expect(&lsquo;foo&rsquo;).to.not.be.arguments; // Not recommended</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect({}, &lsquo;nooo why fail??&rsquo;).to.be.arguments;</p>

<p>The alias <code class="prettyprint">.Arguments</code> can be used interchangeably with <code class="prettyprint">.arguments</code>.</p>

<h2 id="equal-val-msg">.equal(val[, msg])</h2>

<p>Asserts that the target is strictly (<code class="prettyprint">===</code>) equal to the given <code class="prettyprint">val</code>.</p>

<p>expect(1).to.equal(1);
    expect(&lsquo;foo&rsquo;).to.equal(&lsquo;foo&rsquo;);</p>

<p>Add <code class="prettyprint">.deep</code> earlier in the chain to use deep equality instead. See the
<code class="prettyprint">deep-eql</code> project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>

<p>// Target object deeply (but not strictly) equals <code class="prettyprint">{a: 1}</code>
    expect({a: 1}).to.deep.equal({a: 1});
    expect({a: 1}).to.not.equal({a: 1});</p>

<p>// Target array deeply (but not strictly) equals <code class="prettyprint">[1, 2]</code>
    expect([1, 2]).to.deep.equal([1, 2]);
    expect([1, 2]).to.not.equal([1, 2]);</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.equal</code>. However, it&rsquo;s often
best to assert that the target is equal to its expected value, rather than
not equal to one of countless unexpected values.</p>

<p>expect(1).to.equal(1); // Recommended
    expect(1).to.not.equal(2); // Not recommended</p>

<p><code class="prettyprint">.equal</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(1).to.equal(2, &lsquo;nooo why fail??&rsquo;);
    expect(1, &lsquo;nooo why fail??&rsquo;).to.equal(2);</p>

<p>The aliases <code class="prettyprint">.equals</code> and <code class="prettyprint">eq</code> can be used interchangeably with <code class="prettyprint">.equal</code>.</p>

<h2 id="eql-obj-msg">.eql(obj[, msg])</h2>

<p>Asserts that the target is deeply equal to the given <code class="prettyprint">obj</code>. See the
<code class="prettyprint">deep-eql</code> project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>

<p>// Target object is deeply (but not strictly) equal to {a: 1}
    expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});</p>

<p>// Target array is deeply (but not strictly) equal to [1, 2]
    expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.eql</code>. However, it&rsquo;s often best
to assert that the target is deeply equal to its expected value, rather
than not deeply equal to one of countless unexpected values.</p>

<p>expect({a: 1}).to.eql({a: 1}); // Recommended
    expect({a: 1}).to.not.eql({b: 2}); // Not recommended</p>

<p><code class="prettyprint">.eql</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code class="prettyprint">expect</code>.</p>

<p>expect({a: 1}).to.eql({b: 2}, &lsquo;nooo why fail??&rsquo;);
    expect({a: 1}, &lsquo;nooo why fail??&rsquo;).to.eql({b: 2});</p>

<p>The alias <code class="prettyprint">.eqls</code> can be used interchangeably with <code class="prettyprint">.eql</code>.</p>

<p>The <code class="prettyprint">.deep.equal</code> assertion is almost identical to <code class="prettyprint">.eql</code> but with one
difference: <code class="prettyprint">.deep.equal</code> causes deep equality comparisons to also be used
for any other assertions that follow in the chain.</p>

<h2 id="above-n-msg">.above(n[, msg])</h2>

<p>Asserts that the target is a number or a date greater than the given number or date <code class="prettyprint">n</code> respectively.
However, it&rsquo;s often best to assert that the target is equal to its expected
value.</p>

<p>expect(2).to.equal(2); // Recommended
    expect(2).to.be.above(1); // Not recommended</p>

<p>Add <code class="prettyprint">.lengthOf</code> earlier in the chain to assert that the value of the
target&rsquo;s <code class="prettyprint">length</code> property is greater than the given number <code class="prettyprint">n</code>.</p>

<p>expect(&lsquo;foo&rsquo;).to.have.lengthOf(3); // Recommended
    expect(&lsquo;foo&rsquo;).to.have.lengthOf.above(2); // Not recommended</p>

<p>expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.above</code>.</p>

<p>expect(2).to.equal(2); // Recommended
    expect(1).to.not.be.above(2); // Not recommended</p>

<p><code class="prettyprint">.above</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(1).to.be.above(2, &lsquo;nooo why fail??&rsquo;);
    expect(1, &lsquo;nooo why fail??&rsquo;).to.be.above(2);</p>

<p>The aliases <code class="prettyprint">.gt</code> and <code class="prettyprint">.greaterThan</code> can be used interchangeably with
<code class="prettyprint">.above</code>.</p>

<h2 id="least-n-msg">.least(n[, msg])</h2>

<p>Asserts that the target is a number or a date greater than or equal to the given
number or date <code class="prettyprint">n</code> respectively. However, it&rsquo;s often best to assert that the target is equal to
its expected value.</p>

<p>expect(2).to.equal(2); // Recommended
    expect(2).to.be.at.least(1); // Not recommended
    expect(2).to.be.at.least(2); // Not recommended</p>

<p>Add <code class="prettyprint">.lengthOf</code> earlier in the chain to assert that the value of the
target&rsquo;s <code class="prettyprint">length</code> property is greater than or equal to the given number
<code class="prettyprint">n</code>.</p>

<p>expect(&lsquo;foo&rsquo;).to.have.lengthOf(3); // Recommended
    expect(&lsquo;foo&rsquo;).to.have.lengthOf.at.least(2); // Not recommended</p>

<p>expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.least</code>.</p>

<p>expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.at.least(2); // Not recommended</p>

<p><code class="prettyprint">.least</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(1).to.be.at.least(2, &lsquo;nooo why fail??&rsquo;);
    expect(1, &lsquo;nooo why fail??&rsquo;).to.be.at.least(2);</p>

<p>The alias <code class="prettyprint">.gte</code> can be used interchangeably with <code class="prettyprint">.least</code>.</p>

<h2 id="below-n-msg">.below(n[, msg])</h2>

<p>Asserts that the target is a number or a date less than the given number or date <code class="prettyprint">n</code> respectively.
However, it&rsquo;s often best to assert that the target is equal to its expected
value.</p>

<p>expect(1).to.equal(1); // Recommended
    expect(1).to.be.below(2); // Not recommended</p>

<p>Add <code class="prettyprint">.lengthOf</code> earlier in the chain to assert that the value of the
target&rsquo;s <code class="prettyprint">length</code> property is less than the given number <code class="prettyprint">n</code>.</p>

<p>expect(&lsquo;foo&rsquo;).to.have.lengthOf(3); // Recommended
    expect(&lsquo;foo&rsquo;).to.have.lengthOf.below(4); // Not recommended</p>

<p>expect([1, 2, 3]).to.have.length(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.below</code>.</p>

<p>expect(2).to.equal(2); // Recommended
    expect(2).to.not.be.below(1); // Not recommended</p>

<p><code class="prettyprint">.below</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(2).to.be.below(1, &lsquo;nooo why fail??&rsquo;);
    expect(2, &lsquo;nooo why fail??&rsquo;).to.be.below(1);</p>

<p>The aliases <code class="prettyprint">.lt</code> and <code class="prettyprint">.lessThan</code> can be used interchangeably with
<code class="prettyprint">.below</code>.</p>

<h2 id="most-n-msg">.most(n[, msg])</h2>

<p>Asserts that the target is a number or a date less than or equal to the given number
or date <code class="prettyprint">n</code> respectively. However, it&rsquo;s often best to assert that the target is equal to its
expected value.</p>

<p>expect(1).to.equal(1); // Recommended
    expect(1).to.be.at.most(2); // Not recommended
    expect(1).to.be.at.most(1); // Not recommended</p>

<p>Add <code class="prettyprint">.lengthOf</code> earlier in the chain to assert that the value of the
target&rsquo;s <code class="prettyprint">length</code> property is less than or equal to the given number <code class="prettyprint">n</code>.</p>

<p>expect(&lsquo;foo&rsquo;).to.have.lengthOf(3); // Recommended
    expect(&lsquo;foo&rsquo;).to.have.lengthOf.at.most(4); // Not recommended</p>

<p>expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.most</code>.</p>

<p>expect(2).to.equal(2); // Recommended
    expect(2).to.not.be.at.most(1); // Not recommended</p>

<p><code class="prettyprint">.most</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(2).to.be.at.most(1, &lsquo;nooo why fail??&rsquo;);
    expect(2, &lsquo;nooo why fail??&rsquo;).to.be.at.most(1);</p>

<p>The alias <code class="prettyprint">.lte</code> can be used interchangeably with <code class="prettyprint">.most</code>.</p>

<h2 id="within-start-finish-msg">.within(start, finish[, msg])</h2>

<p>Asserts that the target is a number or a date greater than or equal to the given
number or date <code class="prettyprint">start</code>, and less than or equal to the given number or date <code class="prettyprint">finish</code> respectively.
However, it&rsquo;s often best to assert that the target is equal to its expected
value.</p>

<p>expect(2).to.equal(2); // Recommended
    expect(2).to.be.within(1, 3); // Not recommended
    expect(2).to.be.within(2, 3); // Not recommended
    expect(2).to.be.within(1, 2); // Not recommended</p>

<p>Add <code class="prettyprint">.lengthOf</code> earlier in the chain to assert that the value of the
target&rsquo;s <code class="prettyprint">length</code> property is greater than or equal to the given number
<code class="prettyprint">start</code>, and less than or equal to the given number <code class="prettyprint">finish</code>.</p>

<p>expect(&lsquo;foo&rsquo;).to.have.lengthOf(3); // Recommended
    expect(&lsquo;foo&rsquo;).to.have.lengthOf.within(2, 4); // Not recommended</p>

<p>expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.within</code>.</p>

<p>expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.within(2, 4); // Not recommended</p>

<p><code class="prettyprint">.within</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(4).to.be.within(1, 3, &lsquo;nooo why fail??&rsquo;);
    expect(4, &lsquo;nooo why fail??&rsquo;).to.be.within(1, 3);</p>

<h2 id="instanceof-constructor-msg">.instanceof(constructor[, msg])</h2>

<p>Asserts that the target is an instance of the given <code class="prettyprint">constructor</code>.</p>

<p>function Cat () { }</p>

<p>expect(new Cat()).to.be.an.instanceof(Cat);
    expect([1, 2]).to.be.an.instanceof(Array);</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.instanceof</code>.</p>

<p>expect({a: 1}).to.not.be.an.instanceof(Array);</p>

<p><code class="prettyprint">.instanceof</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(1).to.be.an.instanceof(Array, &lsquo;nooo why fail??&rsquo;);
    expect(1, &lsquo;nooo why fail??&rsquo;).to.be.an.instanceof(Array);</p>

<p>Due to limitations in ES5, <code class="prettyprint">.instanceof</code> may not always work as expected
when using a transpiler such as Babel or TypeScript. In particular, it may
produce unexpected results when subclassing built-in object such as
<code class="prettyprint">Array</code>, <code class="prettyprint">Error</code>, and <code class="prettyprint">Map</code>. See your transpiler&rsquo;s docs for details:</p>

<ul>
<li>(<a href="https://babeljs.io/docs/usage/caveats/#classes">Babel</a>)</li>
<li>(<a href="https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work">TypeScript</a>)</li>
</ul>

<p>The alias <code class="prettyprint">.instanceOf</code> can be used interchangeably with <code class="prettyprint">.instanceof</code>.</p>

<h2 id="property-name-val-msg">.property(name[, val[, msg]])</h2>

<p>Asserts that the target has a property with the given key <code class="prettyprint">name</code>.</p>

<p>expect({a: 1}).to.have.property(&lsquo;a&rsquo;);</p>

<p>When <code class="prettyprint">val</code> is provided, <code class="prettyprint">.property</code> also asserts that the property&rsquo;s value
is equal to the given <code class="prettyprint">val</code>.</p>

<p>expect({a: 1}).to.have.property(&lsquo;a&rsquo;, 1);</p>

<p>By default, strict (<code class="prettyprint">===</code>) equality is used. Add <code class="prettyprint">.deep</code> earlier in the
chain to use deep equality instead. See the <code class="prettyprint">deep-eql</code> project page for
info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p>

<p>// Target object deeply (but not strictly) has property <code class="prettyprint">x: {a: 1}</code>
    expect({x: {a: 1}}).to.have.deep.property(&lsquo;x&rsquo;, {a: 1});
    expect({x: {a: 1}}).to.not.have.property(&lsquo;x&rsquo;, {a: 1});</p>

<p>The target&rsquo;s enumerable and non-enumerable properties are always included
in the search. By default, both own and inherited properties are included.
Add <code class="prettyprint">.own</code> earlier in the chain to exclude inherited properties from the
search.</p>

<p>Object.prototype.b = 2;</p>

<p>expect({a: 1}).to.have.own.property(&lsquo;a&rsquo;);
    expect({a: 1}).to.have.own.property(&lsquo;a&rsquo;, 1);
    expect({a: 1}).to.have.property(&lsquo;b&rsquo;).but.not.own.property(&lsquo;b&rsquo;); </p>

<p><code class="prettyprint">.deep</code> and <code class="prettyprint">.own</code> can be combined.</p>

<p>expect({x: {a: 1}}).to.have.deep.own.property(&lsquo;x&rsquo;, {a: 1});</p>

<p>Add <code class="prettyprint">.nested</code> earlier in the chain to enable dot- and bracket-notation when
referencing nested properties.</p>

<p>expect({a: {b: [&lsquo;x&rsquo;, &lsquo;y&rsquo;]}}).to.have.nested.property(&lsquo;a.b[1]&rsquo;);
    expect({a: {b: [&lsquo;x&rsquo;, &lsquo;y&rsquo;]}}).to.have.nested.property(&lsquo;a.b[1]&rsquo;, &lsquo;y&rsquo;);</p>

<p>If <code class="prettyprint">.</code> or <code class="prettyprint">[]</code> are part of an actual property name, they can be escaped by
adding two backslashes before them.</p>

<p>expect({&lsquo;.a&rsquo;: {&lsquo;[b]&rsquo;: &lsquo;x&rsquo;}}).to.have.nested.property(&lsquo;.a.\[b\]&rsquo;);</p>

<p><code class="prettyprint">.deep</code> and <code class="prettyprint">.nested</code> can be combined.</p>

<p>expect({a: {b: [{c: 3}]}})
      .to.have.deep.nested.property(&lsquo;a.b[0]&rsquo;, {c: 3});</p>

<p><code class="prettyprint">.own</code> and <code class="prettyprint">.nested</code> cannot be combined.</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.property</code>.</p>

<p>expect({a: 1}).to.not.have.property(&lsquo;b&rsquo;);</p>

<p>However, it&rsquo;s dangerous to negate <code class="prettyprint">.property</code> when providing <code class="prettyprint">val</code>. The
problem is that it creates uncertain expectations by asserting that the
target either doesn&rsquo;t have a property with the given key <code class="prettyprint">name</code>, or that it
does have a property with the given key <code class="prettyprint">name</code> but its value isn&rsquo;t equal to
the given <code class="prettyprint">val</code>. It&rsquo;s often best to identify the exact output that&rsquo;s
expected, and then write an assertion that only accepts that exact output.</p>

<p>When the target isn&rsquo;t expected to have a property with the given key
<code class="prettyprint">name</code>, it&rsquo;s often best to assert exactly that.</p>

<p>expect({b: 2}).to.not.have.property(&lsquo;a&rsquo;); // Recommended
    expect({b: 2}).to.not.have.property(&lsquo;a&rsquo;, 1); // Not recommended</p>

<p>When the target is expected to have a property with the given key <code class="prettyprint">name</code>,
it&rsquo;s often best to assert that the property has its expected value, rather
than asserting that it doesn&rsquo;t have one of many unexpected values.</p>

<p>expect({a: 3}).to.have.property(&lsquo;a&rsquo;, 3); // Recommended
    expect({a: 3}).to.not.have.property(&lsquo;a&rsquo;, 1); // Not recommended</p>

<p><code class="prettyprint">.property</code> changes the target of any assertions that follow in the chain
to be the value of the property from the original target object.</p>

<p>expect({a: 1}).to.have.property(&lsquo;a&rsquo;).that.is.a(&lsquo;number&rsquo;);</p>

<p><code class="prettyprint">.property</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code class="prettyprint">expect</code>. When not providing <code class="prettyprint">val</code>, only use the
second form.</p>

<p>// Recommended
    expect({a: 1}).to.have.property(&lsquo;a&rsquo;, 2, &lsquo;nooo why fail??&rsquo;);
    expect({a: 1}, &lsquo;nooo why fail??&rsquo;).to.have.property(&lsquo;a&rsquo;, 2);
    expect({a: 1}, &lsquo;nooo why fail??&rsquo;).to.have.property(&lsquo;b&rsquo;);</p>

<p>// Not recommended
    expect({a: 1}).to.have.property(&lsquo;b&rsquo;, undefined, &lsquo;nooo why fail??&rsquo;);</p>

<p>The above assertion isn&rsquo;t the same thing as not providing <code class="prettyprint">val</code>. Instead,
it&rsquo;s asserting that the target object has a <code class="prettyprint">b</code> property that&rsquo;s equal to
<code class="prettyprint">undefined</code>.</p>

<p>The assertions <code class="prettyprint">.ownProperty</code> and <code class="prettyprint">.haveOwnProperty</code> can be used
interchangeably with <code class="prettyprint">.own.property</code>.</p>

<h2 id="ownpropertydescriptor-name-descriptor-msg">.ownPropertyDescriptor(name[, descriptor[, msg]])</h2>

<p>Asserts that the target has its own property descriptor with the given key
<code class="prettyprint">name</code>. Enumerable and non-enumerable properties are included in the
search.</p>

<p>expect({a: 1}).to.have.ownPropertyDescriptor(&lsquo;a&rsquo;);</p>

<p>When <code class="prettyprint">descriptor</code> is provided, <code class="prettyprint">.ownPropertyDescriptor</code> also asserts that
the property&rsquo;s descriptor is deeply equal to the given <code class="prettyprint">descriptor</code>. See
the <code class="prettyprint">deep-eql</code> project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>

<p>expect({a: 1}).to.have.ownPropertyDescriptor(&lsquo;a&rsquo;, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 1,
    });</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.ownPropertyDescriptor</code>.</p>

<p>expect({a: 1}).to.not.have.ownPropertyDescriptor(&lsquo;b&rsquo;);</p>

<p>However, it&rsquo;s dangerous to negate <code class="prettyprint">.ownPropertyDescriptor</code> when providing
a <code class="prettyprint">descriptor</code>. The problem is that it creates uncertain expectations by
asserting that the target either doesn&rsquo;t have a property descriptor with
the given key <code class="prettyprint">name</code>, or that it does have a property descriptor with the
given key <code class="prettyprint">name</code> but its not deeply equal to the given <code class="prettyprint">descriptor</code>. It&rsquo;s
often best to identify the exact output that&rsquo;s expected, and then write an
assertion that only accepts that exact output.</p>

<p>When the target isn&rsquo;t expected to have a property descriptor with the given
key <code class="prettyprint">name</code>, it&rsquo;s often best to assert exactly that.</p>

<p>// Recommended
    expect({b: 2}).to.not.have.ownPropertyDescriptor(&lsquo;a&rsquo;);</p>

<p>// Not recommended
    expect({b: 2}).to.not.have.ownPropertyDescriptor(&lsquo;a&rsquo;, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 1,
    });</p>

<p>When the target is expected to have a property descriptor with the given
key <code class="prettyprint">name</code>, it&rsquo;s often best to assert that the property has its expected
descriptor, rather than asserting that it doesn&rsquo;t have one of many
unexpected descriptors.</p>

<p>// Recommended
    expect({a: 3}).to.have.ownPropertyDescriptor(&lsquo;a&rsquo;, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 3,
    });</p>

<p>// Not recommended
    expect({a: 3}).to.not.have.ownPropertyDescriptor(&lsquo;a&rsquo;, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 1,
    });</p>

<p><code class="prettyprint">.ownPropertyDescriptor</code> changes the target of any assertions that follow
in the chain to be the value of the property descriptor from the original
target object.</p>

<p>expect({a: 1}).to.have.ownPropertyDescriptor(&lsquo;a&rsquo;)
      .that.has.property(&lsquo;enumerable&rsquo;, true);</p>

<p><code class="prettyprint">.ownPropertyDescriptor</code> accepts an optional <code class="prettyprint">msg</code> argument which is a
custom error message to show when the assertion fails. The message can also
be given as the second argument to <code class="prettyprint">expect</code>. When not providing
<code class="prettyprint">descriptor</code>, only use the second form.</p>

<p>// Recommended
    expect({a: 1}).to.have.ownPropertyDescriptor(&lsquo;a&rsquo;, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 2,
    }, &lsquo;nooo why fail??&rsquo;);</p>

<p>// Recommended
    expect({a: 1}, &lsquo;nooo why fail??&rsquo;).to.have.ownPropertyDescriptor(&lsquo;a&rsquo;, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 2,
    });</p>

<p>// Recommended
    expect({a: 1}, &lsquo;nooo why fail??&rsquo;).to.have.ownPropertyDescriptor(&lsquo;b&rsquo;);</p>

<p>// Not recommended
    expect({a: 1})
      .to.have.ownPropertyDescriptor(&lsquo;b&rsquo;, undefined, &lsquo;nooo why fail??&rsquo;);</p>

<p>The above assertion isn&rsquo;t the same thing as not providing <code class="prettyprint">descriptor</code>.
Instead, it&rsquo;s asserting that the target object has a <code class="prettyprint">b</code> property
descriptor that&rsquo;s deeply equal to <code class="prettyprint">undefined</code>.</p>

<p>The alias <code class="prettyprint">.haveOwnPropertyDescriptor</code> can be used interchangeably with
<code class="prettyprint">.ownPropertyDescriptor</code>.</p>

<h2 id="lengthof-n-msg">.lengthOf(n[, msg])</h2>

<p>Asserts that the target&rsquo;s <code class="prettyprint">length</code> property is equal to the given number
<code class="prettyprint">n</code>.</p>

<p>expect([1, 2, 3]).to.have.lengthOf(3);
    expect(&lsquo;foo&rsquo;).to.have.lengthOf(3);</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.lengthOf</code>. However, it&rsquo;s often
best to assert that the target&rsquo;s <code class="prettyprint">length</code> property is equal to its expected
value, rather than not equal to one of many unexpected values.</p>

<p>expect(&lsquo;foo&rsquo;).to.have.lengthOf(3); // Recommended
    expect(&lsquo;foo&rsquo;).to.not.have.lengthOf(4); // Not recommended</p>

<p><code class="prettyprint">.lengthOf</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect([1, 2, 3]).to.have.lengthOf(2, &lsquo;nooo why fail??&rsquo;);
    expect([1, 2, 3], &lsquo;nooo why fail??&rsquo;).to.have.lengthOf(2);</p>

<p><code class="prettyprint">.lengthOf</code> can also be used as a language chain, causing all <code class="prettyprint">.above</code>,
<code class="prettyprint">.below</code>, <code class="prettyprint">.least</code>, <code class="prettyprint">.most</code>, and <code class="prettyprint">.within</code> assertions that follow in the
chain to use the target&rsquo;s <code class="prettyprint">length</code> property as the target. However, it&rsquo;s
often best to assert that the target&rsquo;s <code class="prettyprint">length</code> property is equal to its
expected length, rather than asserting that its <code class="prettyprint">length</code> property falls
within some range of values.</p>

<p>// Recommended
    expect([1, 2, 3]).to.have.lengthOf(3);</p>

<p>// Not recommended
    expect([1, 2, 3]).to.have.lengthOf.above(2);
    expect([1, 2, 3]).to.have.lengthOf.below(4);
    expect([1, 2, 3]).to.have.lengthOf.at.least(3);
    expect([1, 2, 3]).to.have.lengthOf.at.most(3);
    expect([1, 2, 3]).to.have.lengthOf.within(2,4);</p>

<p>Due to a compatibility issue, the alias <code class="prettyprint">.length</code> can&rsquo;t be chained directly
off of an uninvoked method such as <code class="prettyprint">.a</code>. Therefore, <code class="prettyprint">.length</code> can&rsquo;t be used
interchangeably with <code class="prettyprint">.lengthOf</code> in every situation. It&rsquo;s recommended to
always use <code class="prettyprint">.lengthOf</code> instead of <code class="prettyprint">.length</code>.</p>

<p>expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
    expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected</p>

<h2 id="match-re-msg">.match(re[, msg])</h2>

<p>Asserts that the target matches the given regular expression <code class="prettyprint">re</code>.</p>

<p>expect(&lsquo;foobar&rsquo;).to.match(/^foo/);</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.match</code>.</p>

<p>expect(&lsquo;foobar&rsquo;).to.not.match(/taco/);</p>

<p><code class="prettyprint">.match</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(&lsquo;foobar&rsquo;).to.match(/taco/, &lsquo;nooo why fail??&rsquo;);
    expect(&lsquo;foobar&rsquo;, &lsquo;nooo why fail??&rsquo;).to.match(/taco/);</p>

<p>The alias <code class="prettyprint">.matches</code> can be used interchangeably with <code class="prettyprint">.match</code>.</p>

<h2 id="string-str-msg">.string(str[, msg])</h2>

<p>Asserts that the target string contains the given substring <code class="prettyprint">str</code>.</p>

<p>expect(&lsquo;foobar&rsquo;).to.have.string(&lsquo;bar&rsquo;);</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.string</code>.</p>

<p>expect(&lsquo;foobar&rsquo;).to.not.have.string(&lsquo;taco&rsquo;);</p>

<p><code class="prettyprint">.string</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(&lsquo;foobar&rsquo;).to.have.string(/taco/, &lsquo;nooo why fail??&rsquo;);
    expect(&lsquo;foobar&rsquo;, &lsquo;nooo why fail??&rsquo;).to.have.string(/taco/);</p>

<h2 id="keys-key1-key2">.keys(key1[, key2[, &hellip;]])</h2>

<p>Asserts that the target object, array, map, or set has the given keys. Only
the target&rsquo;s own inherited properties are included in the search. </p>

<p>When the target is an object or array, keys can be provided as one or more
string arguments, a single array argument, or a single object argument. In
the latter case, only the keys in the given object matter; the values are
ignored.</p>

<p>expect({a: 1, b: 2}).to.have.all.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);
    expect([&lsquo;x&rsquo;, &lsquo;y&rsquo;]).to.have.all.keys(0, 1);</p>

<p>expect({a: 1, b: 2}).to.have.all.keys([&lsquo;a&rsquo;, &lsquo;b&rsquo;]);
    expect([&lsquo;x&rsquo;, &lsquo;y&rsquo;]).to.have.all.keys([0, 1]);</p>

<p>expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
    expect([&lsquo;x&rsquo;, &lsquo;y&rsquo;]).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5</p>

<p>When the target is a map or set, each key must be provided as a separate
argument.</p>

<p>expect(new Map([[&lsquo;a&rsquo;, 1], [&lsquo;b&rsquo;, 2]])).to.have.all.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);
    expect(new Set([&lsquo;a&rsquo;, &lsquo;b&rsquo;])).to.have.all.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);</p>

<p>Because <code class="prettyprint">.keys</code> does different things based on the target&rsquo;s type, it&rsquo;s
important to check the target&rsquo;s type before using <code class="prettyprint">.keys</code>. See the <code class="prettyprint">.a</code> doc
for info on testing a target&rsquo;s type.</p>

<p>expect({a: 1, b: 2}).to.be.an(&lsquo;object&rsquo;).that.has.all.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);</p>

<p>By default, strict (<code class="prettyprint">===</code>) equality is used to compare keys of maps and
sets. Add <code class="prettyprint">.deep</code> earlier in the chain to use deep equality instead. See
the <code class="prettyprint">deep-eql</code> project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>

<p>// Target set deeply (but not strictly) has key <code class="prettyprint">{a: 1}</code>
    expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
    expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);</p>

<p>By default, the target must have all of the given keys and no more. Add
<code class="prettyprint">.any</code> earlier in the chain to only require that the target have at least
one of the given keys. Also, add <code class="prettyprint">.not</code> earlier in the chain to negate
<code class="prettyprint">.keys</code>. It&rsquo;s often best to add <code class="prettyprint">.any</code> when negating <code class="prettyprint">.keys</code>, and to use
<code class="prettyprint">.all</code> when asserting <code class="prettyprint">.keys</code> without negation.</p>

<p>When negating <code class="prettyprint">.keys</code>, <code class="prettyprint">.any</code> is preferred because <code class="prettyprint">.not.any.keys</code> asserts
exactly what&rsquo;s expected of the output, whereas <code class="prettyprint">.not.all.keys</code> creates
uncertain expectations.</p>

<p>// Recommended; asserts that target doesn&rsquo;t have any of the given keys
    expect({a: 1, b: 2}).to.not.have.any.keys(&lsquo;c&rsquo;, &lsquo;d&rsquo;);</p>

<p>// Not recommended; asserts that target doesn&rsquo;t have all of the given
    // keys but may or may not have some of them
    expect({a: 1, b: 2}).to.not.have.all.keys(&lsquo;c&rsquo;, &lsquo;d&rsquo;);</p>

<p>When asserting <code class="prettyprint">.keys</code> without negation, <code class="prettyprint">.all</code> is preferred because
<code class="prettyprint">.all.keys</code> asserts exactly what&rsquo;s expected of the output, whereas
<code class="prettyprint">.any.keys</code> creates uncertain expectations.</p>

<p>// Recommended; asserts that target has all the given keys
    expect({a: 1, b: 2}).to.have.all.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);</p>

<p>// Not recommended; asserts that target has at least one of the given
    // keys but may or may not have more of them
    expect({a: 1, b: 2}).to.have.any.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);</p>

<p>Note that <code class="prettyprint">.all</code> is used by default when neither <code class="prettyprint">.all</code> nor <code class="prettyprint">.any</code> appear
earlier in the chain. However, it&rsquo;s often best to add <code class="prettyprint">.all</code> anyway because
it improves readability.</p>

<p>// Both assertions are identical
    expect({a: 1, b: 2}).to.have.all.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;); // Recommended
    expect({a: 1, b: 2}).to.have.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;); // Not recommended</p>

<p>Add <code class="prettyprint">.include</code> earlier in the chain to require that the target&rsquo;s keys be a
superset of the expected keys, rather than identical sets.</p>

<p>// Target object&rsquo;s keys are a superset of [&lsquo;a&rsquo;, &lsquo;b&rsquo;] but not identical
    expect({a: 1, b: 2, c: 3}).to.include.all.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);
    expect({a: 1, b: 2, c: 3}).to.not.have.all.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);</p>

<p>However, if <code class="prettyprint">.any</code> and <code class="prettyprint">.include</code> are combined, only the <code class="prettyprint">.any</code> takes
effect. The <code class="prettyprint">.include</code> is ignored in this case.</p>

<p>// Both assertions are identical
    expect({a: 1}).to.have.any.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);
    expect({a: 1}).to.include.any.keys(&lsquo;a&rsquo;, &lsquo;b&rsquo;);</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect({a: 1}, &lsquo;nooo why fail??&rsquo;).to.have.key(&lsquo;b&rsquo;);</p>

<p>The alias <code class="prettyprint">.key</code> can be used interchangeably with <code class="prettyprint">.keys</code>.</p>

<h2 id="throw-errorlike-errmsgmatcher-msg">.throw([errorLike], [errMsgMatcher], [msg])</h2>

<p>When no arguments are provided, <code class="prettyprint">.throw</code> invokes the target function and
asserts that an error is thrown.</p>

<p>var badFn = function () { throw new TypeError(&lsquo;Illegal salmon!&rsquo;); };</p>

<p>expect(badFn).to.throw();</p>

<p>When one argument is provided, and it&rsquo;s an error constructor, <code class="prettyprint">.throw</code>
invokes the target function and asserts that an error is thrown that&rsquo;s an
instance of that error constructor.</p>

<p>var badFn = function () { throw new TypeError(&lsquo;Illegal salmon!&rsquo;); };</p>

<p>expect(badFn).to.throw(TypeError);</p>

<p>When one argument is provided, and it&rsquo;s an error instance, <code class="prettyprint">.throw</code> invokes
the target function and asserts that an error is thrown that&rsquo;s strictly
(<code class="prettyprint">===</code>) equal to that error instance.</p>

<p>var err = new TypeError(&lsquo;Illegal salmon!&rsquo;);
    var badFn = function () { throw err; };</p>

<p>expect(badFn).to.throw(err);</p>

<p>When one argument is provided, and it&rsquo;s a string, <code class="prettyprint">.throw</code> invokes the
target function and asserts that an error is thrown with a message that
contains that string.</p>

<p>var badFn = function () { throw new TypeError(&lsquo;Illegal salmon!&rsquo;); };</p>

<p>expect(badFn).to.throw(&lsquo;salmon&rsquo;);</p>

<p>When one argument is provided, and it&rsquo;s a regular expression, <code class="prettyprint">.throw</code>
invokes the target function and asserts that an error is thrown with a
message that matches that regular expression.</p>

<p>var badFn = function () { throw new TypeError(&lsquo;Illegal salmon!&rsquo;); };</p>

<p>expect(badFn).to.throw(/salmon/);</p>

<p>When two arguments are provided, and the first is an error instance or
constructor, and the second is a string or regular expression, <code class="prettyprint">.throw</code>
invokes the function and asserts that an error is thrown that fulfills both
conditions as described above.</p>

<p>var err = new TypeError(&lsquo;Illegal salmon!&rsquo;);
    var badFn = function () { throw err; };</p>

<p>expect(badFn).to.throw(TypeError, &lsquo;salmon&rsquo;);
    expect(badFn).to.throw(TypeError, /salmon/);
    expect(badFn).to.throw(err, &lsquo;salmon&rsquo;);
    expect(badFn).to.throw(err, /salmon/);</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.throw</code>.</p>

<p>var goodFn = function () {};</p>

<p>expect(goodFn).to.not.throw();</p>

<p>However, it&rsquo;s dangerous to negate <code class="prettyprint">.throw</code> when providing any arguments.
The problem is that it creates uncertain expectations by asserting that the
target either doesn&rsquo;t throw an error, or that it throws an error but of a
different type than the given type, or that it throws an error of the given
type but with a message that doesn&rsquo;t include the given string. It&rsquo;s often
best to identify the exact output that&rsquo;s expected, and then write an
assertion that only accepts that exact output.</p>

<p>When the target isn&rsquo;t expected to throw an error, it&rsquo;s often best to assert
exactly that.</p>

<p>var goodFn = function () {};</p>

<p>expect(goodFn).to.not.throw(); // Recommended
    expect(goodFn).to.not.throw(ReferenceError, &lsquo;x&rsquo;); // Not recommended</p>

<p>When the target is expected to throw an error, it&rsquo;s often best to assert
that the error is of its expected type, and has a message that includes an
expected string, rather than asserting that it doesn&rsquo;t have one of many
unexpected types, and doesn&rsquo;t have a message that includes some string.</p>

<p>var badFn = function () { throw new TypeError(&lsquo;Illegal salmon!&rsquo;); };</p>

<p>expect(badFn).to.throw(TypeError, &lsquo;salmon&rsquo;); // Recommended
    expect(badFn).to.not.throw(ReferenceError, &lsquo;x&rsquo;); // Not recommended</p>

<p><code class="prettyprint">.throw</code> changes the target of any assertions that follow in the chain to
be the error object that&rsquo;s thrown.</p>

<p>var err = new TypeError(&lsquo;Illegal salmon!&rsquo;);
    err.code = 42;
    var badFn = function () { throw err; };</p>

<p>expect(badFn).to.throw(TypeError).with.property(&lsquo;code&rsquo;, 42);</p>

<p><code class="prettyprint">.throw</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code class="prettyprint">expect</code>. When not providing two arguments, always use
the second form.</p>

<p>var goodFn = function () {};</p>

<p>expect(goodFn).to.throw(TypeError, &lsquo;x&rsquo;, &lsquo;nooo why fail??&rsquo;);
    expect(goodFn, &lsquo;nooo why fail??&rsquo;).to.throw();</p>

<p>Due to limitations in ES5, <code class="prettyprint">.throw</code> may not always work as expected when
using a transpiler such as Babel or TypeScript. In particular, it may
produce unexpected results when subclassing the built-in <code class="prettyprint">Error</code> object and
then passing the subclassed constructor to <code class="prettyprint">.throw</code>. See your transpiler&rsquo;s
docs for details:</p>

<ul>
<li>(<a href="https://babeljs.io/docs/usage/caveats/#classes">Babel</a>)</li>
<li>(<a href="https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work">TypeScript</a>)</li>
</ul>

<p>Beware of some common mistakes when using the <code class="prettyprint">throw</code> assertion. One common
mistake is to accidentally invoke the function yourself instead of letting
the <code class="prettyprint">throw</code> assertion invoke the function for you. For example, when
testing if a function named <code class="prettyprint">fn</code> throws, provide <code class="prettyprint">fn</code> instead of <code class="prettyprint">fn()</code> as
the target for the assertion.</p>

<p>expect(fn).to.throw();     // Good! Tests <code class="prettyprint">fn</code> as desired
    expect(fn()).to.throw();   // Bad! Tests result of <code class="prettyprint">fn()</code>, not <code class="prettyprint">fn</code></p>

<p>If you need to assert that your function <code class="prettyprint">fn</code> throws when passed certain
arguments, then wrap a call to <code class="prettyprint">fn</code> inside of another function.</p>

<p>expect(function () { fn(42); }).to.throw();  // Function expression
    expect(() =&gt; fn(42)).to.throw();             // ES6 arrow function</p>

<p>Another common mistake is to provide an object method (or any stand-alone
function that relies on <code class="prettyprint">this</code>) as the target of the assertion. Doing so is
problematic because the <code class="prettyprint">this</code> context will be lost when the function is
invoked by <code class="prettyprint">.throw</code>; there&rsquo;s no way for it to know what <code class="prettyprint">this</code> is supposed
to be. There are two ways around this problem. One solution is to wrap the
method or function call inside of another function. Another solution is to
use <code class="prettyprint">bind</code>.</p>

<p>expect(function () { cat.meow(); }).to.throw();  // Function expression
    expect(() =&gt; cat.meow()).to.throw();             // ES6 arrow function
    expect(cat.meow.bind(cat)).to.throw();           // Bind</p>

<p>Finally, it&rsquo;s worth mentioning that it&rsquo;s a best practice in JavaScript to
only throw <code class="prettyprint">Error</code> and derivatives of <code class="prettyprint">Error</code> such as <code class="prettyprint">ReferenceError</code>,
<code class="prettyprint">TypeError</code>, and user-defined objects that extend <code class="prettyprint">Error</code>. No other type of
value will generate a stack trace when initialized. With that said, the
<code class="prettyprint">throw</code> assertion does technically support any type of value being thrown,
not just <code class="prettyprint">Error</code> and its derivatives.</p>

<p>The aliases <code class="prettyprint">.throws</code> and <code class="prettyprint">.Throw</code> can be used interchangeably with
<code class="prettyprint">.throw</code>.</p>

<h2 id="respondto-method-msg">.respondTo(method[, msg])</h2>

<p>When the target is a non-function object, <code class="prettyprint">.respondTo</code> asserts that the
target has a method with the given name <code class="prettyprint">method</code>. The method can be own or
inherited, and it can be enumerable or non-enumerable.</p>

<p>function Cat () {}
    Cat.prototype.meow = function () {};</p>

<p>expect(new Cat()).to.respondTo(&lsquo;meow&rsquo;);</p>

<p>When the target is a function, <code class="prettyprint">.respondTo</code> asserts that the target&rsquo;s
<code class="prettyprint">prototype</code> property has a method with the given name <code class="prettyprint">method</code>. Again, the
method can be own or inherited, and it can be enumerable or non-enumerable.</p>

<p>function Cat () {}
    Cat.prototype.meow = function () {};</p>

<p>expect(Cat).to.respondTo(&lsquo;meow&rsquo;);</p>

<p>Add <code class="prettyprint">.itself</code> earlier in the chain to force <code class="prettyprint">.respondTo</code> to treat the
target as a non-function object, even if it&rsquo;s a function. Thus, it asserts
that the target has a method with the given name <code class="prettyprint">method</code>, rather than
asserting that the target&rsquo;s <code class="prettyprint">prototype</code> property has a method with the
given name <code class="prettyprint">method</code>.</p>

<p>function Cat () {}
    Cat.prototype.meow = function () {};
    Cat.hiss = function () {};</p>

<p>expect(Cat).itself.to.respondTo(&lsquo;hiss&rsquo;).but.not.respondTo(&lsquo;meow&rsquo;);</p>

<p>When not adding <code class="prettyprint">.itself</code>, it&rsquo;s important to check the target&rsquo;s type before
using <code class="prettyprint">.respondTo</code>. See the <code class="prettyprint">.a</code> doc for info on checking a target&rsquo;s type.</p>

<p>function Cat () {}
    Cat.prototype.meow = function () {};</p>

<p>expect(new Cat()).to.be.an(&lsquo;object&rsquo;).that.respondsTo(&lsquo;meow&rsquo;);</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.respondTo</code>.</p>

<p>function Dog () {}
    Dog.prototype.bark = function () {};</p>

<p>expect(new Dog()).to.not.respondTo(&lsquo;meow&rsquo;);</p>

<p><code class="prettyprint">.respondTo</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect({}).to.respondTo(&lsquo;meow&rsquo;, &lsquo;nooo why fail??&rsquo;);
    expect({}, &lsquo;nooo why fail??&rsquo;).to.respondTo(&lsquo;meow&rsquo;);</p>

<p>The alias <code class="prettyprint">.respondsTo</code> can be used interchangeably with <code class="prettyprint">.respondTo</code>.</p>

<h2 id="itself">.itself</h2>

<p>Forces all <code class="prettyprint">.respondTo</code> assertions that follow in the chain to behave as if
the target is a non-function object, even if it&rsquo;s a function. Thus, it
causes <code class="prettyprint">.respondTo</code> to assert that the target has a method with the given
name, rather than asserting that the target&rsquo;s <code class="prettyprint">prototype</code> property has a
method with the given name.</p>

<p>function Cat () {}
    Cat.prototype.meow = function () {};
    Cat.hiss = function () {};</p>

<p>expect(Cat).itself.to.respondTo(&lsquo;hiss&rsquo;).but.not.respondTo(&lsquo;meow&rsquo;);</p>

<h2 id="satisfy-matcher-msg">.satisfy(matcher[, msg])</h2>

<p>Invokes the given <code class="prettyprint">matcher</code> function with the target being passed as the
first argument, and asserts that the value returned is truthy.</p>

<p>expect(1).to.satisfy(function(num) {
      return num &gt; 0; 
    });</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.satisfy</code>.</p>

<p>expect(1).to.not.satisfy(function(num) {
      return num &gt; 2;
    });</p>

<p><code class="prettyprint">.satisfy</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(1).to.satisfy(function(num) {
      return num &gt; 2;
    }, &lsquo;nooo why fail??&rsquo;);</p>

<p>expect(1, &lsquo;nooo why fail??&rsquo;).to.satisfy(function(num) {
      return num &gt; 2;
    });</p>

<p>The alias <code class="prettyprint">.satisfies</code> can be used interchangeably with <code class="prettyprint">.satisfy</code>.</p>

<h2 id="closeto-expected-delta-msg">.closeTo(expected, delta[, msg])</h2>

<p>Asserts that the target is a number that&rsquo;s within a given +/- <code class="prettyprint">delta</code> range
of the given number <code class="prettyprint">expected</code>. However, it&rsquo;s often best to assert that the
target is equal to its expected value.</p>

<p>// Recommended
    expect(1.5).to.equal(1.5);</p>

<p>// Not recommended
    expect(1.5).to.be.closeTo(1, 0.5);
    expect(1.5).to.be.closeTo(2, 0.5);
    expect(1.5).to.be.closeTo(1, 1);</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.closeTo</code>.</p>

<p>expect(1.5).to.equal(1.5); // Recommended
    expect(1.5).to.not.be.closeTo(3, 1); // Not recommended</p>

<p><code class="prettyprint">.closeTo</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(1.5).to.be.closeTo(3, 1, &lsquo;nooo why fail??&rsquo;);
    expect(1.5, &lsquo;nooo why fail??&rsquo;).to.be.closeTo(3, 1);</p>

<p>The alias <code class="prettyprint">.approximately</code> can be used interchangeably with <code class="prettyprint">.closeTo</code>.</p>

<h2 id="members-set-msg">.members(set[, msg])</h2>

<p>Asserts that the target array has the same members as the given array
<code class="prettyprint">set</code>.</p>

<p>expect([1, 2, 3]).to.have.members([2, 1, 3]);
    expect([1, 2, 2]).to.have.members([2, 1, 2]);</p>

<p>By default, members are compared using strict (<code class="prettyprint">===</code>) equality. Add <code class="prettyprint">.deep</code>
earlier in the chain to use deep equality instead. See the <code class="prettyprint">deep-eql</code>
project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>

<p>// Target array deeply (but not strictly) has member <code class="prettyprint">{a: 1}</code>
    expect([{a: 1}]).to.have.deep.members([{a: 1}]);
    expect([{a: 1}]).to.not.have.members([{a: 1}]);</p>

<p>By default, order doesn&rsquo;t matter. Add <code class="prettyprint">.ordered</code> earlier in the chain to
require that members appear in the same order.</p>

<p>expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
    expect([1, 2, 3]).to.have.members([2, 1, 3])
      .but.not.ordered.members([2, 1, 3]);</p>

<p>By default, both arrays must be the same size. Add <code class="prettyprint">.include</code> earlier in
the chain to require that the target&rsquo;s members be a superset of the
expected members. Note that duplicates are ignored in the subset when
<code class="prettyprint">.include</code> is added.</p>

<p>// Target array is a superset of [1, 2] but not identical
    expect([1, 2, 3]).to.include.members([1, 2]);
    expect([1, 2, 3]).to.not.have.members([1, 2]);</p>

<p>// Duplicates in the subset are ignored
    expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);</p>

<p><code class="prettyprint">.deep</code>, <code class="prettyprint">.ordered</code>, and <code class="prettyprint">.include</code> can all be combined. However, if
<code class="prettyprint">.include</code> and <code class="prettyprint">.ordered</code> are combined, the ordering begins at the start of
both arrays.</p>

<p>expect([{a: 1}, {b: 2}, {c: 3}])
      .to.include.deep.ordered.members([{a: 1}, {b: 2}])
      .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.members</code>. However, it&rsquo;s
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the target array doesn&rsquo;t have all of the same members as
the given array <code class="prettyprint">set</code> but may or may not have some of them. It&rsquo;s often best
to identify the exact output that&rsquo;s expected, and then write an assertion
that only accepts that exact output.</p>

<p>expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
    expect([1, 2]).to.not.have.members([3, 4]); // Not recommended</p>

<p><code class="prettyprint">.members</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect([1, 2]).to.have.members([1, 2, 3], &lsquo;nooo why fail??&rsquo;);
    expect([1, 2], &lsquo;nooo why fail??&rsquo;).to.have.members([1, 2, 3]);</p>

<h2 id="oneof-list-msg">.oneOf(list[, msg])</h2>

<p>Asserts that the target is a member of the given array <code class="prettyprint">list</code>. However,
it&rsquo;s often best to assert that the target is equal to its expected value.</p>

<p>expect(1).to.equal(1); // Recommended
    expect(1).to.be.oneOf([1, 2, 3]); // Not recommended</p>

<p>Comparisons are performed using strict (<code class="prettyprint">===</code>) equality.</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.oneOf</code>.</p>

<p>expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended</p>

<p><code class="prettyprint">.oneOf</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(1).to.be.oneOf([2, 3, 4], &lsquo;nooo why fail??&rsquo;);
    expect(1, &lsquo;nooo why fail??&rsquo;).to.be.oneOf([2, 3, 4]);</p>

<h2 id="change-subject-prop-msg">.change(subject[, prop[, msg]])</h2>

<p>When one argument is provided, <code class="prettyprint">.change</code> asserts that the given function
<code class="prettyprint">subject</code> returns a different value when it&rsquo;s invoked before the target
function compared to when it&rsquo;s invoked afterward. However, it&rsquo;s often best
to assert that <code class="prettyprint">subject</code> is equal to its expected value.</p>

<p>var dots = &rdquo;
      , addDot = function () { dots += &lsquo;.&rsquo;; }
      , getDots = function () { return dots; };</p>

<p>// Recommended
    expect(getDots()).to.equal(&ldquo;);
    addDot();
    expect(getDots()).to.equal(&lsquo;.&rsquo;);</p>

<p>// Not recommended
    expect(addDot).to.change(getDots);</p>

<p>When two arguments are provided, <code class="prettyprint">.change</code> asserts that the value of the
given object <code class="prettyprint">subject</code>&lsquo;s <code class="prettyprint">prop</code> property is different before invoking the
target function compared to afterward.</p>

<p>var myObj = {dots: &rdquo;}
      , addDot = function () { myObj.dots += &rsquo;.&lsquo;; };</p>

<p>// Recommended
    expect(myObj).to.have.property(&#39;dots&rsquo;, &ldquo;);
    addDot();
    expect(myObj).to.have.property(&lsquo;dots&rsquo;, &lsquo;.&rsquo;);</p>

<p>// Not recommended
    expect(addDot).to.change(myObj, &lsquo;dots&rsquo;);</p>

<p>Strict (<code class="prettyprint">===</code>) equality is used to compare before and after values.</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.change</code>.</p>

<p>var dots = &rdquo;
      , noop = function () {}
      , getDots = function () { return dots; };</p>

<p>expect(noop).to.not.change(getDots);</p>

<p>var myObj = {dots: &ldquo;}
      , noop = function () {};</p>

<p>expect(noop).to.not.change(myObj, &lsquo;dots&rsquo;);</p>

<p><code class="prettyprint">.change</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code class="prettyprint">expect</code>. When not providing two arguments, always
use the second form.</p>

<p>var myObj = {dots: &rdquo;}
      , addDot = function () { myObj.dots += &lsquo;.&rsquo;; };</p>

<p>expect(addDot).to.not.change(myObj, &lsquo;dots&rsquo;, &lsquo;nooo why fail??&rsquo;);</p>

<p>var dots = &ldquo;
      , addDot = function () { dots += &lsquo;.&rsquo;; }
      , getDots = function () { return dots; };</p>

<p>expect(addDot, &lsquo;nooo why fail??&rsquo;).to.not.change(getDots);</p>

<p><code class="prettyprint">.change</code> also causes all <code class="prettyprint">.by</code> assertions that follow in the chain to
assert how much a numeric subject was increased or decreased by. However,
it&rsquo;s dangerous to use <code class="prettyprint">.change.by</code>. The problem is that it creates
uncertain expectations by asserting that the subject either increases by
the given delta, or that it decreases by the given delta. It&rsquo;s often best
to identify the exact output that&rsquo;s expected, and then write an assertion
that only accepts that exact output.</p>

<p>var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; }
      , subtractTwo = function () { myObj.val -= 2; };</p>

<p>expect(addTwo).to.increase(myObj, &lsquo;val&rsquo;).by(2); // Recommended
    expect(addTwo).to.change(myObj, &lsquo;val&rsquo;).by(2); // Not recommended</p>

<p>expect(subtractTwo).to.decrease(myObj, &lsquo;val&rsquo;).by(2); // Recommended
    expect(subtractTwo).to.change(myObj, &lsquo;val&rsquo;).by(2); // Not recommended</p>

<p>The alias <code class="prettyprint">.changes</code> can be used interchangeably with <code class="prettyprint">.change</code>.</p>

<h2 id="increase-subject-prop-msg">.increase(subject[, prop[, msg]])</h2>

<p>When one argument is provided, <code class="prettyprint">.increase</code> asserts that the given function
<code class="prettyprint">subject</code> returns a greater number when it&rsquo;s invoked after invoking the
target function compared to when it&rsquo;s invoked beforehand. <code class="prettyprint">.increase</code> also
causes all <code class="prettyprint">.by</code> assertions that follow in the chain to assert how much
greater of a number is returned. It&rsquo;s often best to assert that the return
value increased by the expected amount, rather than asserting it increased
by any amount.</p>

<p>var val = 1
      , addTwo = function () { val += 2; }
      , getVal = function () { return val; };</p>

<p>expect(addTwo).to.increase(getVal).by(2); // Recommended
    expect(addTwo).to.increase(getVal); // Not recommended</p>

<p>When two arguments are provided, <code class="prettyprint">.increase</code> asserts that the value of the
given object <code class="prettyprint">subject</code>&lsquo;s <code class="prettyprint">prop</code> property is greater after invoking the
target function compared to beforehand.</p>

<p>var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };</p>

<p>expect(addTwo).to.increase(myObj, &#39;val&rsquo;).by(2); // Recommended
    expect(addTwo).to.increase(myObj, &lsquo;val&rsquo;); // Not recommended</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.increase</code>. However, it&rsquo;s
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the subject either decreases, or that it stays the same.
It&rsquo;s often best to identify the exact output that&rsquo;s expected, and then
write an assertion that only accepts that exact output.</p>

<p>When the subject is expected to decrease, it&rsquo;s often best to assert that it
decreased by the expected amount.</p>

<p>var myObj = {val: 1}
      , subtractTwo = function () { myObj.val -= 2; };</p>

<p>expect(subtractTwo).to.decrease(myObj, &lsquo;val&rsquo;).by(2); // Recommended
    expect(subtractTwo).to.not.increase(myObj, &lsquo;val&rsquo;); // Not recommended</p>

<p>When the subject is expected to stay the same, it&rsquo;s often best to assert
exactly that.</p>

<p>var myObj = {val: 1}
      , noop = function () {};</p>

<p>expect(noop).to.not.change(myObj, &lsquo;val&rsquo;); // Recommended
    expect(noop).to.not.increase(myObj, &lsquo;val&rsquo;); // Not recommended</p>

<p><code class="prettyprint">.increase</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code class="prettyprint">expect</code>. When not providing two arguments, always
use the second form.</p>

<p>var myObj = {val: 1}
      , noop = function () {};</p>

<p>expect(noop).to.increase(myObj, &lsquo;val&rsquo;, &lsquo;nooo why fail??&rsquo;);</p>

<p>var val = 1
      , noop = function () {}
      , getVal = function () { return val; };</p>

<p>expect(noop, &lsquo;nooo why fail??&rsquo;).to.increase(getVal);</p>

<p>The alias <code class="prettyprint">.increases</code> can be used interchangeably with <code class="prettyprint">.increase</code>.</p>

<h2 id="decrease-subject-prop-msg">.decrease(subject[, prop[, msg]])</h2>

<p>When one argument is provided, <code class="prettyprint">.decrease</code> asserts that the given function
<code class="prettyprint">subject</code> returns a lesser number when it&rsquo;s invoked after invoking the
target function compared to when it&rsquo;s invoked beforehand. <code class="prettyprint">.decrease</code> also
causes all <code class="prettyprint">.by</code> assertions that follow in the chain to assert how much
lesser of a number is returned. It&rsquo;s often best to assert that the return
value decreased by the expected amount, rather than asserting it decreased
by any amount.</p>

<p>var val = 1
      , subtractTwo = function () { val -= 2; }
      , getVal = function () { return val; };</p>

<p>expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
    expect(subtractTwo).to.decrease(getVal); // Not recommended</p>

<p>When two arguments are provided, <code class="prettyprint">.decrease</code> asserts that the value of the
given object <code class="prettyprint">subject</code>&lsquo;s <code class="prettyprint">prop</code> property is lesser after invoking the
target function compared to beforehand. </p>

<p>var myObj = {val: 1}
      , subtractTwo = function () { myObj.val -= 2; };</p>

<p>expect(subtractTwo).to.decrease(myObj, &#39;val&rsquo;).by(2); // Recommended
    expect(subtractTwo).to.decrease(myObj, &lsquo;val&rsquo;); // Not recommended</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.decrease</code>. However, it&rsquo;s
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the subject either increases, or that it stays the same.
It&rsquo;s often best to identify the exact output that&rsquo;s expected, and then
write an assertion that only accepts that exact output.</p>

<p>When the subject is expected to increase, it&rsquo;s often best to assert that it
increased by the expected amount.</p>

<p>var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };</p>

<p>expect(addTwo).to.increase(myObj, &lsquo;val&rsquo;).by(2); // Recommended
    expect(addTwo).to.not.decrease(myObj, &lsquo;val&rsquo;); // Not recommended</p>

<p>When the subject is expected to stay the same, it&rsquo;s often best to assert
exactly that.</p>

<p>var myObj = {val: 1}
      , noop = function () {};</p>

<p>expect(noop).to.not.change(myObj, &lsquo;val&rsquo;); // Recommended
    expect(noop).to.not.decrease(myObj, &lsquo;val&rsquo;); // Not recommended</p>

<p><code class="prettyprint">.decrease</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code class="prettyprint">expect</code>. When not providing two arguments, always
use the second form.</p>

<p>var myObj = {val: 1}
      , noop = function () {};</p>

<p>expect(noop).to.decrease(myObj, &lsquo;val&rsquo;, &lsquo;nooo why fail??&rsquo;);</p>

<p>var val = 1
      , noop = function () {}
      , getVal = function () { return val; };</p>

<p>expect(noop, &lsquo;nooo why fail??&rsquo;).to.decrease(getVal);</p>

<p>The alias <code class="prettyprint">.decreases</code> can be used interchangeably with <code class="prettyprint">.decrease</code>.</p>

<h2 id="by-delta-msg">.by(delta[, msg])</h2>

<p>When following an <code class="prettyprint">.increase</code> assertion in the chain, <code class="prettyprint">.by</code> asserts that
the subject of the <code class="prettyprint">.increase</code> assertion increased by the given <code class="prettyprint">delta</code>.</p>

<p>var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };</p>

<p>expect(addTwo).to.increase(myObj, &lsquo;val&rsquo;).by(2);</p>

<p>When following a <code class="prettyprint">.decrease</code> assertion in the chain, <code class="prettyprint">.by</code> asserts that the
subject of the <code class="prettyprint">.decrease</code> assertion decreased by the given <code class="prettyprint">delta</code>.</p>

<p>var myObj = {val: 1}
      , subtractTwo = function () { myObj.val -= 2; };</p>

<p>expect(subtractTwo).to.decrease(myObj, &lsquo;val&rsquo;).by(2);</p>

<p>When following a <code class="prettyprint">.change</code> assertion in the chain, <code class="prettyprint">.by</code> asserts that the
subject of the <code class="prettyprint">.change</code> assertion either increased or decreased by the
given <code class="prettyprint">delta</code>. However, it&rsquo;s dangerous to use <code class="prettyprint">.change.by</code>. The problem is
that it creates uncertain expectations. It&rsquo;s often best to identify the
exact output that&rsquo;s expected, and then write an assertion that only accepts
that exact output.</p>

<p>var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; }
      , subtractTwo = function () { myObj.val -= 2; };</p>

<p>expect(addTwo).to.increase(myObj, &lsquo;val&rsquo;).by(2); // Recommended
    expect(addTwo).to.change(myObj, &lsquo;val&rsquo;).by(2); // Not recommended</p>

<p>expect(subtractTwo).to.decrease(myObj, &lsquo;val&rsquo;).by(2); // Recommended
    expect(subtractTwo).to.change(myObj, &lsquo;val&rsquo;).by(2); // Not recommended</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.by</code>. However, it&rsquo;s often best
to assert that the subject changed by its expected delta, rather than
asserting that it didn&rsquo;t change by one of countless unexpected deltas.</p>

<p>var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };</p>

<p>// Recommended
    expect(addTwo).to.increase(myObj, &lsquo;val&rsquo;).by(2);</p>

<p>// Not recommended
    expect(addTwo).to.increase(myObj, &lsquo;val&rsquo;).but.not.by(3);</p>

<p><code class="prettyprint">.by</code> accepts an optional <code class="prettyprint">msg</code> argument which is a custom error message to
show when the assertion fails. The message can also be given as the second
argument to <code class="prettyprint">expect</code>.</p>

<p>var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };</p>

<p>expect(addTwo).to.increase(myObj, &lsquo;val&rsquo;).by(3, &lsquo;nooo why fail??&rsquo;);
    expect(addTwo, &lsquo;nooo why fail??&rsquo;).to.increase(myObj, &lsquo;val&rsquo;).by(3);</p>

<h2 id="extensible">.extensible</h2>

<p>Asserts that the target is extensible, which means that new properties can
be added to it. Primitives are never extensible.</p>

<p>expect({a: 1}).to.be.extensible;</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.extensible</code>.</p>

<p>var nonExtensibleObject = Object.preventExtensions({})
      , sealedObject = Object.seal({})
      , frozenObject = Object.freeze({});</p>

<p>expect(nonExtensibleObject).to.not.be.extensible;
    expect(sealedObject).to.not.be.extensible;
    expect(frozenObject).to.not.be.extensible;
    expect(1).to.not.be.extensible;</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(1, &lsquo;nooo why fail??&rsquo;).to.be.extensible;</p>

<h2 id="sealed">.sealed</h2>

<p>Asserts that the target is sealed, which means that new properties can&rsquo;t be
added to it, and its existing properties can&rsquo;t be reconfigured or deleted.
However, it&rsquo;s possible that its existing properties can still be reassigned
to different values. Primitives are always sealed.</p>

<p>var sealedObject = Object.seal({});
    var frozenObject = Object.freeze({});</p>

<p>expect(sealedObject).to.be.sealed;
    expect(frozenObject).to.be.sealed;
    expect(1).to.be.sealed;</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.sealed</code>.</p>

<p>expect({a: 1}).to.not.be.sealed;</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect({a: 1}, &lsquo;nooo why fail??&rsquo;).to.be.sealed;</p>

<h2 id="frozen">.frozen</h2>

<p>Asserts that the target is frozen, which means that new properties can&rsquo;t be
added to it, and its existing properties can&rsquo;t be reassigned to different
values, reconfigured, or deleted. Primitives are always frozen.</p>

<p>var frozenObject = Object.freeze({});</p>

<p>expect(frozenObject).to.be.frozen;
    expect(1).to.be.frozen;</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.frozen</code>.</p>

<p>expect({a: 1}).to.not.be.frozen;</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect({a: 1}, &lsquo;nooo why fail??&rsquo;).to.be.frozen;</p>

<h2 id="finite">.finite</h2>

<p>Asserts that the target is a number, and isn&rsquo;t <code class="prettyprint">NaN</code> or positive/negative
<code class="prettyprint">Infinity</code>.</p>

<p>expect(1).to.be.finite;</p>

<p>Add <code class="prettyprint">.not</code> earlier in the chain to negate <code class="prettyprint">.finite</code>. However, it&rsquo;s
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the subject either isn&rsquo;t a number, or that it&rsquo;s <code class="prettyprint">NaN</code>, or
that it&rsquo;s positive <code class="prettyprint">Infinity</code>, or that it&rsquo;s negative <code class="prettyprint">Infinity</code>. It&rsquo;s often
best to identify the exact output that&rsquo;s expected, and then write an
assertion that only accepts that exact output.</p>

<p>When the target isn&rsquo;t expected to be a number, it&rsquo;s often best to assert
that it&rsquo;s the expected type, rather than asserting that it isn&rsquo;t one of
many unexpected types.</p>

<p>expect(&lsquo;foo&rsquo;).to.be.a(&lsquo;string&rsquo;); // Recommended
    expect(&lsquo;foo&rsquo;).to.not.be.finite; // Not recommended</p>

<p>When the target is expected to be <code class="prettyprint">NaN</code>, it&rsquo;s often best to assert exactly
that.</p>

<p>expect(NaN).to.be.NaN; // Recommended
    expect(NaN).to.not.be.finite; // Not recommended</p>

<p>When the target is expected to be positive infinity, it&rsquo;s often best to
assert exactly that.</p>

<p>expect(Infinity).to.equal(Infinity); // Recommended
    expect(Infinity).to.not.be.finite; // Not recommended</p>

<p>When the target is expected to be negative infinity, it&rsquo;s often best to
assert exactly that.</p>

<p>expect(-Infinity).to.equal(-Infinity); // Recommended
    expect(-Infinity).to.not.be.finite; // Not recommended</p>

<p>A custom error message can be given as the second argument to <code class="prettyprint">expect</code>.</p>

<p>expect(&lsquo;foo&rsquo;, &lsquo;nooo why fail??&rsquo;).to.be.finite;
chai
Copyright&copy; 2011-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed
Chai dependencies.
Module export.</p>

<h2 id="assert-expression-message">assert(expression, message)</h2>

<p>Write your own test expressions.</p>

<p>assert(&lsquo;foo&rsquo; !== &lsquo;bar&rsquo;, &lsquo;foo is not bar&rsquo;);
    assert(Array.isArray([]), &lsquo;empty arrays are arrays&rsquo;);</p>

<h2 id="fail-actual-expected-message-operator">.fail(actual, expected, [message], [operator])</h2>

<p>Throw a failure. Node.js <code class="prettyprint">assert</code> module-compatible.</p>

<h2 id="isok-object-message">.isOk(object, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> is truthy.</p>

<p>assert.isOk(&lsquo;everything&rsquo;, &lsquo;everything is ok&rsquo;);
    assert.isOk(false, &lsquo;this will fail&rsquo;);</p>

<h2 id="isnotok-object-message">.isNotOk(object, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> is falsy.</p>

<p>assert.isNotOk(&lsquo;everything&rsquo;, &lsquo;this will fail&rsquo;);
    assert.isNotOk(false, &lsquo;this will pass&rsquo;);</p>

<h2 id="equal-actual-expected-message">.equal(actual, expected, [message])</h2>

<p>Asserts non-strict equality (<code class="prettyprint">==</code>) of <code class="prettyprint">actual</code> and <code class="prettyprint">expected</code>.</p>

<p>assert.equal(3, &lsquo;3&rsquo;, &lsquo;== coerces values to strings&rsquo;);</p>

<h2 id="notequal-actual-expected-message">.notEqual(actual, expected, [message])</h2>

<p>Asserts non-strict inequality (<code class="prettyprint">!=</code>) of <code class="prettyprint">actual</code> and <code class="prettyprint">expected</code>.</p>

<p>assert.notEqual(3, 4, &lsquo;these numbers are not equal&rsquo;);</p>

<h2 id="strictequal-actual-expected-message">.strictEqual(actual, expected, [message])</h2>

<p>Asserts strict equality (<code class="prettyprint">===</code>) of <code class="prettyprint">actual</code> and <code class="prettyprint">expected</code>.</p>

<p>assert.strictEqual(true, true, &lsquo;these booleans are strictly equal&rsquo;);</p>

<h2 id="notstrictequal-actual-expected-message">.notStrictEqual(actual, expected, [message])</h2>

<p>Asserts strict inequality (<code class="prettyprint">!==</code>) of <code class="prettyprint">actual</code> and <code class="prettyprint">expected</code>.</p>

<p>assert.notStrictEqual(3, &lsquo;3&rsquo;, &lsquo;no coercion for strict equality&rsquo;);</p>

<h2 id="deepequal-actual-expected-message">.deepEqual(actual, expected, [message])</h2>

<p>Asserts that <code class="prettyprint">actual</code> is deeply equal to <code class="prettyprint">expected</code>.</p>

<p>assert.deepEqual({ tea: &lsquo;green&rsquo; }, { tea: &lsquo;green&rsquo; });</p>

<h2 id="notdeepequal-actual-expected-message">.notDeepEqual(actual, expected, [message])</h2>

<p>Assert that <code class="prettyprint">actual</code> is not deeply equal to <code class="prettyprint">expected</code>.</p>

<p>assert.notDeepEqual({ tea: &lsquo;green&rsquo; }, { tea: &lsquo;jasmine&rsquo; });</p>

<h2 id="isabove-valuetocheck-valuetobeabove-message">.isAbove(valueToCheck, valueToBeAbove, [message])</h2>

<p>Asserts <code class="prettyprint">valueToCheck</code> is strictly greater than (&gt;) <code class="prettyprint">valueToBeAbove</code>.</p>

<p>assert.isAbove(5, 2, &lsquo;5 is strictly greater than 2&rsquo;);</p>

<h2 id="isatleast-valuetocheck-valuetobeatleast-message">.isAtLeast(valueToCheck, valueToBeAtLeast, [message])</h2>

<p>Asserts <code class="prettyprint">valueToCheck</code> is greater than or equal to (&gt;=) <code class="prettyprint">valueToBeAtLeast</code>.</p>

<p>assert.isAtLeast(5, 2, &lsquo;5 is greater or equal to 2&rsquo;);
    assert.isAtLeast(3, 3, &lsquo;3 is greater or equal to 3&rsquo;);</p>

<h2 id="isbelow-valuetocheck-valuetobebelow-message">.isBelow(valueToCheck, valueToBeBelow, [message])</h2>

<p>Asserts <code class="prettyprint">valueToCheck</code> is strictly less than (&lt;) <code class="prettyprint">valueToBeBelow</code>.</p>

<p>assert.isBelow(3, 6, &lsquo;3 is strictly less than 6&rsquo;);</p>

<h2 id="isatmost-valuetocheck-valuetobeatmost-message">.isAtMost(valueToCheck, valueToBeAtMost, [message])</h2>

<p>Asserts <code class="prettyprint">valueToCheck</code> is less than or equal to (&lt;=) <code class="prettyprint">valueToBeAtMost</code>.</p>

<p>assert.isAtMost(3, 6, &lsquo;3 is less than or equal to 6&rsquo;);
    assert.isAtMost(4, 4, &lsquo;4 is less than or equal to 4&rsquo;);</p>

<h2 id="istrue-value-message">.isTrue(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is true.</p>

<p>var teaServed = true;
    assert.isTrue(teaServed, &lsquo;the tea has been served&rsquo;);</p>

<h2 id="isnottrue-value-message">.isNotTrue(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is not true.</p>

<p>var tea = &lsquo;tasty chai&rsquo;;
    assert.isNotTrue(tea, &lsquo;great, time for tea!&rsquo;);</p>

<h2 id="isfalse-value-message">.isFalse(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is false.</p>

<p>var teaServed = false;
    assert.isFalse(teaServed, &lsquo;no tea yet? hmm&hellip;&rsquo;);</p>

<h2 id="isnotfalse-value-message">.isNotFalse(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is not false.</p>

<p>var tea = &lsquo;tasty chai&rsquo;;
    assert.isNotFalse(tea, &lsquo;great, time for tea!&rsquo;);</p>

<h2 id="isnull-value-message">.isNull(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is null.</p>

<p>assert.isNull(err, &lsquo;there was no error&rsquo;);</p>

<h2 id="isnotnull-value-message">.isNotNull(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is not null.</p>

<p>var tea = &lsquo;tasty chai&rsquo;;
    assert.isNotNull(tea, &lsquo;great, time for tea!&rsquo;);</p>

<h2 id="isnan">.isNaN</h2>

<p>Asserts that value is NaN.</p>

<p>assert.isNaN(NaN, &lsquo;NaN is NaN&rsquo;);</p>

<h2 id="isnotnan">.isNotNaN</h2>

<p>Asserts that value is not NaN.</p>

<p>assert.isNotNaN(4, &lsquo;4 is not NaN&rsquo;);</p>

<h2 id="exists">.exists</h2>

<p>Asserts that the target is neither <code class="prettyprint">null</code> nor <code class="prettyprint">undefined</code>.</p>

<p>var foo = &lsquo;hi&rsquo;;</p>

<p>assert.exists(foo, &lsquo;foo is neither <code class="prettyprint">null</code> nor <code class="prettyprint">undefined</code>&rsquo;);</p>

<h2 id="notexists">.notExists</h2>

<p>Asserts that the target is either <code class="prettyprint">null</code> or <code class="prettyprint">undefined</code>.</p>

<p>var bar = null
      , baz;</p>

<p>assert.notExists(bar);
    assert.notExists(baz, &lsquo;baz is either null or undefined&rsquo;);</p>

<h2 id="isundefined-value-message">.isUndefined(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is <code class="prettyprint">undefined</code>.</p>

<p>var tea;
    assert.isUndefined(tea, &lsquo;no tea defined&rsquo;);</p>

<h2 id="isdefined-value-message">.isDefined(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is not <code class="prettyprint">undefined</code>.</p>

<p>var tea = &lsquo;cup of chai&rsquo;;
    assert.isDefined(tea, &lsquo;tea has been defined&rsquo;);</p>

<h2 id="isfunction-value-message">.isFunction(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is a function.</p>

<p>function serveTea() { return &lsquo;cup of tea&rsquo;; };
    assert.isFunction(serveTea, &lsquo;great, we can have tea now&rsquo;);</p>

<h2 id="isnotfunction-value-message">.isNotFunction(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is <em>not</em> a function.</p>

<p>var serveTea = [ &lsquo;heat&rsquo;, &lsquo;pour&rsquo;, &lsquo;sip&rsquo; ];
    assert.isNotFunction(serveTea, &lsquo;great, we have listed the steps&rsquo;);</p>

<h2 id="isobject-value-message">.isObject(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is an object of type &lsquo;Object&rsquo; (as revealed by <code class="prettyprint">Object.prototype.toString</code>).
<em>The assertion does not match subclassed objects.</em></p>

<p>var selection = { name: &lsquo;Chai&rsquo;, serve: &lsquo;with spices&rsquo; };
    assert.isObject(selection, &lsquo;tea selection is an object&rsquo;);</p>

<h2 id="isnotobject-value-message">.isNotObject(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is <em>not</em> an object of type &lsquo;Object&rsquo; (as revealed by <code class="prettyprint">Object.prototype.toString</code>).</p>

<p>var selection = &lsquo;chai&rsquo;
    assert.isNotObject(selection, &lsquo;tea selection is not an object&rsquo;);
    assert.isNotObject(null, &lsquo;null is not an object&rsquo;);</p>

<h2 id="isarray-value-message">.isArray(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is an array.</p>

<p>var menu = [ &lsquo;green&rsquo;, &lsquo;chai&rsquo;, &lsquo;oolong&rsquo; ];
    assert.isArray(menu, &lsquo;what kind of tea do we want?&rsquo;);</p>

<h2 id="isnotarray-value-message">.isNotArray(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is <em>not</em> an array.</p>

<p>var menu = &lsquo;green|chai|oolong&rsquo;;
    assert.isNotArray(menu, &lsquo;what kind of tea do we want?&rsquo;);</p>

<h2 id="isstring-value-message">.isString(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is a string.</p>

<p>var teaOrder = &lsquo;chai&rsquo;;
    assert.isString(teaOrder, &lsquo;order placed&rsquo;);</p>

<h2 id="isnotstring-value-message">.isNotString(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is <em>not</em> a string.</p>

<p>var teaOrder = 4;
    assert.isNotString(teaOrder, &lsquo;order placed&rsquo;);</p>

<h2 id="isnumber-value-message">.isNumber(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is a number.</p>

<p>var cups = 2;
    assert.isNumber(cups, &lsquo;how many cups&rsquo;);</p>

<h2 id="isnotnumber-value-message">.isNotNumber(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is <em>not</em> a number.</p>

<p>var cups = &lsquo;2 cups please&rsquo;;
    assert.isNotNumber(cups, &lsquo;how many cups&rsquo;);</p>

<h2 id="isfinite-value-message">.isFinite(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is a finite number. Unlike <code class="prettyprint">.isNumber</code>, this will fail for <code class="prettyprint">NaN</code> and <code class="prettyprint">Infinity</code>.</p>

<p>var cups = 2;
    assert.isFinite(cups, &lsquo;how many cups&rsquo;);</p>

<p>assert.isFinite(NaN); // throws</p>

<h2 id="isboolean-value-message">.isBoolean(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is a boolean.</p>

<p>var teaReady = true
      , teaServed = false;</p>

<p>assert.isBoolean(teaReady, &lsquo;is the tea ready&rsquo;);
    assert.isBoolean(teaServed, &lsquo;has tea been served&rsquo;);</p>

<h2 id="isnotboolean-value-message">.isNotBoolean(value, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is <em>not</em> a boolean.</p>

<p>var teaReady = &lsquo;yep&rsquo;
      , teaServed = &lsquo;nope&rsquo;;</p>

<p>assert.isNotBoolean(teaReady, &lsquo;is the tea ready&rsquo;);
    assert.isNotBoolean(teaServed, &lsquo;has tea been served&rsquo;);</p>

<h2 id="typeof-value-name-message">.typeOf(value, name, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code>&lsquo;s type is <code class="prettyprint">name</code>, as determined by
<code class="prettyprint">Object.prototype.toString</code>.</p>

<p>assert.typeOf({ tea: &#39;chai&rsquo; }, &lsquo;object&rsquo;, &lsquo;we have an object&rsquo;);
    assert.typeOf([&lsquo;chai&rsquo;, &lsquo;jasmine&rsquo;], &lsquo;array&rsquo;, &lsquo;we have an array&rsquo;);
    assert.typeOf(&lsquo;tea&rsquo;, &lsquo;string&rsquo;, &lsquo;we have a string&rsquo;);
    assert.typeOf(/tea/, &lsquo;regexp&rsquo;, &lsquo;we have a regular expression&rsquo;);
    assert.typeOf(null, &lsquo;null&rsquo;, &lsquo;we have a null&rsquo;);
    assert.typeOf(undefined, &lsquo;undefined&rsquo;, &lsquo;we have an undefined&rsquo;);</p>

<h2 id="nottypeof-value-name-message">.notTypeOf(value, name, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code>&lsquo;s type is <em>not</em> <code class="prettyprint">name</code>, as determined by
<code class="prettyprint">Object.prototype.toString</code>.</p>

<p>assert.notTypeOf(&#39;tea&rsquo;, &lsquo;number&rsquo;, &lsquo;strings are not numbers&rsquo;);</p>

<h2 id="instanceof-object-constructor-message">.instanceOf(object, constructor, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> is an instance of <code class="prettyprint">constructor</code>.</p>

<p>var Tea = function (name) { this.name = name; }
      , chai = new Tea(&lsquo;chai&rsquo;);</p>

<p>assert.instanceOf(chai, Tea, &lsquo;chai is an instance of tea&rsquo;);</p>

<h2 id="notinstanceof-object-constructor-message">.notInstanceOf(object, constructor, [message])</h2>

<p>Asserts <code class="prettyprint">value</code> is not an instance of <code class="prettyprint">constructor</code>.</p>

<p>var Tea = function (name) { this.name = name; }
      , chai = new String(&lsquo;chai&rsquo;);</p>

<p>assert.notInstanceOf(chai, Tea, &lsquo;chai is not an instance of tea&rsquo;);</p>

<h2 id="include-haystack-needle-message">.include(haystack, needle, [message])</h2>

<p>Asserts that <code class="prettyprint">haystack</code> includes <code class="prettyprint">needle</code>. Can be used to assert the
inclusion of a value in an array, a substring in a string, or a subset of
properties in an object.</p>

<p>assert.include([1,2,3], 2, &lsquo;array contains value&rsquo;);
    assert.include(&lsquo;foobar&rsquo;, &lsquo;foo&rsquo;, &lsquo;string contains substring&rsquo;);
    assert.include({ foo: &lsquo;bar&rsquo;, hello: &lsquo;universe&rsquo; }, { foo: &lsquo;bar&rsquo; }, &lsquo;object contains property&rsquo;);</p>

<p>Strict equality (===) is used. When asserting the inclusion of a value in
an array, the array is searched for an element that&rsquo;s strictly equal to the
given value. When asserting a subset of properties in an object, the object
is searched for the given property keys, checking that each one is present
and stricty equal to the given property value. For instance:</p>

<p>var obj1 = {a: 1}
      , obj2 = {b: 2};
    assert.include([obj1, obj2], obj1);
    assert.include({foo: obj1, bar: obj2}, {foo: obj1});
    assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});</p>

<h2 id="notinclude-haystack-needle-message">.notInclude(haystack, needle, [message])</h2>

<p>Asserts that <code class="prettyprint">haystack</code> does not include <code class="prettyprint">needle</code>. Can be used to assert
the absence of a value in an array, a substring in a string, or a subset of
properties in an object.</p>

<p>assert.notInclude([1,2,3], 4, &lsquo;array doesn&rsquo;t contain value&rsquo;);
    assert.notInclude(&lsquo;foobar&rsquo;, &lsquo;baz&rsquo;, &lsquo;string doesn&rsquo;t contain substring&rsquo;);
    assert.notInclude({ foo: &lsquo;bar&rsquo;, hello: &lsquo;universe&rsquo; }, { foo: &lsquo;baz&rsquo; }, &lsquo;object doesn&rsquo;t contain property&rsquo;);</p>

<p>Strict equality (===) is used. When asserting the absence of a value in an
array, the array is searched to confirm the absence of an element that&rsquo;s
strictly equal to the given value. When asserting a subset of properties in
an object, the object is searched to confirm that at least one of the given
property keys is either not present or not strictly equal to the given
property value. For instance:</p>

<p>var obj1 = {a: 1}
      , obj2 = {b: 2};
    assert.notInclude([obj1, obj2], {a: 1});
    assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
    assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});</p>

<h2 id="deepinclude-haystack-needle-message">.deepInclude(haystack, needle, [message])</h2>

<p>Asserts that <code class="prettyprint">haystack</code> includes <code class="prettyprint">needle</code>. Can be used to assert the
inclusion of a value in an array or a subset of properties in an object.
Deep equality is used.</p>

<p>var obj1 = {a: 1}
      , obj2 = {b: 2};
    assert.deepInclude([obj1, obj2], {a: 1});
    assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
    assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});</p>

<h2 id="notdeepinclude-haystack-needle-message">.notDeepInclude(haystack, needle, [message])</h2>

<p>Asserts that <code class="prettyprint">haystack</code> does not include <code class="prettyprint">needle</code>. Can be used to assert
the absence of a value in an array or a subset of properties in an object.
Deep equality is used.</p>

<p>var obj1 = {a: 1}
      , obj2 = {b: 2};
    assert.notDeepInclude([obj1, obj2], {a: 9});
    assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
    assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});</p>

<h2 id="nestedinclude-haystack-needle-message">.nestedInclude(haystack, needle, [message])</h2>

<p>Asserts that &lsquo;haystack&rsquo; includes &lsquo;needle&rsquo;. 
Can be used to assert the inclusion of a subset of properties in an 
object.
Enables the use of dot- and bracket-notation for referencing nested 
properties.
&lsquo;[]&rsquo; and &lsquo;.&rsquo; in property names can be escaped using double backslashes.</p>

<p>assert.nestedInclude({&lsquo;.a&rsquo;: {&lsquo;b&rsquo;: &lsquo;x&rsquo;}}, {&lsquo;.a.[b]&rsquo;: &lsquo;x&rsquo;});
    assert.nestedInclude({&lsquo;a&rsquo;: {&lsquo;[b]&rsquo;: &lsquo;x&rsquo;}}, {&lsquo;a.\[b\]&rsquo;: &lsquo;x&rsquo;});</p>

<h2 id="notnestedinclude-haystack-needle-message">.notNestedInclude(haystack, needle, [message])</h2>

<p>Asserts that &lsquo;haystack&rsquo; does not include &lsquo;needle&rsquo;. 
Can be used to assert the absence of a subset of properties in an 
object.
Enables the use of dot- and bracket-notation for referencing nested 
properties. 
&lsquo;[]&rsquo; and &lsquo;.&rsquo; in property names can be escaped using double backslashes.</p>

<p>assert.notNestedInclude({&lsquo;.a&rsquo;: {&lsquo;b&rsquo;: &lsquo;x&rsquo;}}, {&lsquo;.a.b&rsquo;: &lsquo;y&rsquo;});
    assert.notNestedInclude({&lsquo;a&rsquo;: {&lsquo;[b]&rsquo;: &lsquo;x&rsquo;}}, {&lsquo;a.\[b\]&rsquo;: &lsquo;y&rsquo;});</p>

<h2 id="deepnestedinclude-haystack-needle-message">.deepNestedInclude(haystack, needle, [message])</h2>

<p>Asserts that &lsquo;haystack&rsquo; includes &lsquo;needle&rsquo;.
Can be used to assert the inclusion of a subset of properties in an 
object while checking for deep equality.
Enables the use of dot- and bracket-notation for referencing nested 
properties.
&lsquo;[]&rsquo; and &lsquo;.&rsquo; in property names can be escaped using double backslashes.</p>

<p>assert.deepNestedInclude({a: {b: [{x: 1}]}}, {&lsquo;a.b[0]&rsquo;: {x: 1}});
    assert.deepNestedInclude({&lsquo;.a&rsquo;: {&lsquo;[b]&rsquo;: {x: 1}}}, {&lsquo;.a.\[b\]&rsquo;: {x: 1}});</p>

<h2 id="notdeepnestedinclude-haystack-needle-message">.notDeepNestedInclude(haystack, needle, [message])</h2>

<p>Asserts that &lsquo;haystack&rsquo; does not include &lsquo;needle&rsquo;.
Can be used to assert the absence of a subset of properties in an 
object while checking for deep equality.
Enables the use of dot- and bracket-notation for referencing nested 
properties.
&lsquo;[]&rsquo; and &lsquo;.&rsquo; in property names can be escaped using double backslashes.</p>

<p>assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {&lsquo;a.b[0]&rsquo;: {y: 1}})
    assert.notDeepNestedInclude({&lsquo;.a&rsquo;: {&lsquo;[b]&rsquo;: {x: 1}}}, {&lsquo;.a.\[b\]&rsquo;: {y: 2}});</p>

<h2 id="owninclude-haystack-needle-message">.ownInclude(haystack, needle, [message])</h2>

<p>Asserts that &lsquo;haystack&rsquo; includes &lsquo;needle&rsquo;.
Can be used to assert the inclusion of a subset of properties in an 
object while ignoring inherited properties.</p>

<p>assert.ownInclude({ a: 1 }, { a: 1 });</p>

<h2 id="notowninclude-haystack-needle-message">.notOwnInclude(haystack, needle, [message])</h2>

<p>Asserts that &lsquo;haystack&rsquo; includes &lsquo;needle&rsquo;.
Can be used to assert the absence of a subset of properties in an 
object while ignoring inherited properties.</p>

<p>Object.prototype.b = 2;</p>

<p>assert.notOwnInclude({ a: 1 }, { b: 2 });</p>

<h2 id="deepowninclude-haystack-needle-message">.deepOwnInclude(haystack, needle, [message])</h2>

<p>Asserts that &lsquo;haystack&rsquo; includes &lsquo;needle&rsquo;.
Can be used to assert the inclusion of a subset of properties in an 
object while ignoring inherited properties and checking for deep equality.</p>

<p>assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});</p>

<h2 id="notdeepowninclude-haystack-needle-message">.notDeepOwnInclude(haystack, needle, [message])</h2>

<p>Asserts that &lsquo;haystack&rsquo; includes &lsquo;needle&rsquo;.
Can be used to assert the absence of a subset of properties in an 
object while ignoring inherited properties and checking for deep equality.</p>

<p>assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});</p>

<h2 id="match-value-regexp-message">.match(value, regexp, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> matches the regular expression <code class="prettyprint">regexp</code>.</p>

<p>assert.match(&lsquo;foobar&rsquo;, /^foo/, &lsquo;regexp matches&rsquo;);</p>

<h2 id="notmatch-value-regexp-message">.notMatch(value, regexp, [message])</h2>

<p>Asserts that <code class="prettyprint">value</code> does not match the regular expression <code class="prettyprint">regexp</code>.</p>

<p>assert.notMatch(&lsquo;foobar&rsquo;, /^foo/, &lsquo;regexp does not match&rsquo;);</p>

<h2 id="property-object-property-message">.property(object, property, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has a direct or inherited property named by
<code class="prettyprint">property</code>.</p>

<p>assert.property({ tea: { green: &lsquo;matcha&rsquo; }}, &lsquo;tea&rsquo;);
    assert.property({ tea: { green: &lsquo;matcha&rsquo; }}, &lsquo;toString&rsquo;);</p>

<h2 id="notproperty-object-property-message">.notProperty(object, property, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> does <em>not</em> have a direct or inherited property named
by <code class="prettyprint">property</code>.</p>

<p>assert.notProperty({ tea: { green: &lsquo;matcha&rsquo; }}, &lsquo;coffee&rsquo;);</p>

<h2 id="propertyval-object-property-value-message">.propertyVal(object, property, value, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has a direct or inherited property named by
<code class="prettyprint">property</code> with a value given by <code class="prettyprint">value</code>. Uses a strict equality check
(===).</p>

<p>assert.propertyVal({ tea: &lsquo;is good&rsquo; }, &lsquo;tea&rsquo;, &lsquo;is good&rsquo;);</p>

<h2 id="notpropertyval-object-property-value-message">.notPropertyVal(object, property, value, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> does <em>not</em> have a direct or inherited property named
by <code class="prettyprint">property</code> with value given by <code class="prettyprint">value</code>. Uses a strict equality check
(===).</p>

<p>assert.notPropertyVal({ tea: &lsquo;is good&rsquo; }, &lsquo;tea&rsquo;, &lsquo;is bad&rsquo;);
    assert.notPropertyVal({ tea: &lsquo;is good&rsquo; }, &lsquo;coffee&rsquo;, &lsquo;is good&rsquo;);</p>

<h2 id="deeppropertyval-object-property-value-message">.deepPropertyVal(object, property, value, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has a direct or inherited property named by
<code class="prettyprint">property</code> with a value given by <code class="prettyprint">value</code>. Uses a deep equality check.</p>

<p>assert.deepPropertyVal({ tea: { green: &lsquo;matcha&rsquo; } }, &lsquo;tea&rsquo;, { green: &lsquo;matcha&rsquo; });</p>

<h2 id="notdeeppropertyval-object-property-value-message">.notDeepPropertyVal(object, property, value, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> does <em>not</em> have a direct or inherited property named
by <code class="prettyprint">property</code> with value given by <code class="prettyprint">value</code>. Uses a deep equality check.</p>

<p>assert.notDeepPropertyVal({ tea: { green: &lsquo;matcha&rsquo; } }, &lsquo;tea&rsquo;, { black: &lsquo;matcha&rsquo; });
    assert.notDeepPropertyVal({ tea: { green: &lsquo;matcha&rsquo; } }, &lsquo;tea&rsquo;, { green: &lsquo;oolong&rsquo; });
    assert.notDeepPropertyVal({ tea: { green: &lsquo;matcha&rsquo; } }, &lsquo;coffee&rsquo;, { green: &lsquo;matcha&rsquo; });</p>

<h2 id="ownproperty-object-property-message">.ownProperty(object, property, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has a direct property named by <code class="prettyprint">property</code>. Inherited
properties aren&rsquo;t checked.</p>

<p>assert.ownProperty({ tea: { green: &lsquo;matcha&rsquo; }}, &lsquo;tea&rsquo;);</p>

<h2 id="notownproperty-object-property-message">.notOwnProperty(object, property, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> does <em>not</em> have a direct property named by
<code class="prettyprint">property</code>. Inherited properties aren&rsquo;t checked.</p>

<p>assert.notOwnProperty({ tea: { green: &lsquo;matcha&rsquo; }}, &lsquo;coffee&rsquo;);
    assert.notOwnProperty({}, &lsquo;toString&rsquo;);</p>

<h2 id="ownpropertyval-object-property-value-message">.ownPropertyVal(object, property, value, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has a direct property named by <code class="prettyprint">property</code> and a value
equal to the provided <code class="prettyprint">value</code>. Uses a strict equality check (===).
Inherited properties aren&rsquo;t checked.</p>

<p>assert.ownPropertyVal({ coffee: &lsquo;is good&rsquo;}, &lsquo;coffee&rsquo;, &lsquo;is good&rsquo;);</p>

<h2 id="notownpropertyval-object-property-value-message">.notOwnPropertyVal(object, property, value, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> does <em>not</em> have a direct property named by <code class="prettyprint">property</code>
with a value equal to the provided <code class="prettyprint">value</code>. Uses a strict equality check
(===). Inherited properties aren&rsquo;t checked.</p>

<p>assert.notOwnPropertyVal({ tea: &lsquo;is better&rsquo;}, &lsquo;tea&rsquo;, &lsquo;is worse&rsquo;);
    assert.notOwnPropertyVal({}, &lsquo;toString&rsquo;, Object.prototype.toString);</p>

<h2 id="deepownpropertyval-object-property-value-message">.deepOwnPropertyVal(object, property, value, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has a direct property named by <code class="prettyprint">property</code> and a value
equal to the provided <code class="prettyprint">value</code>. Uses a deep equality check. Inherited
properties aren&rsquo;t checked.</p>

<p>assert.deepOwnPropertyVal({ tea: { green: &lsquo;matcha&rsquo; } }, &lsquo;tea&rsquo;, { green: &lsquo;matcha&rsquo; });</p>

<h2 id="notdeepownpropertyval-object-property-value-message">.notDeepOwnPropertyVal(object, property, value, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> does <em>not</em> have a direct property named by <code class="prettyprint">property</code>
with a value equal to the provided <code class="prettyprint">value</code>. Uses a deep equality check.
Inherited properties aren&rsquo;t checked.</p>

<p>assert.notDeepOwnPropertyVal({ tea: { green: &lsquo;matcha&rsquo; } }, &lsquo;tea&rsquo;, { black: &lsquo;matcha&rsquo; });
    assert.notDeepOwnPropertyVal({ tea: { green: &lsquo;matcha&rsquo; } }, &lsquo;tea&rsquo;, { green: &lsquo;oolong&rsquo; });
    assert.notDeepOwnPropertyVal({ tea: { green: &lsquo;matcha&rsquo; } }, &lsquo;coffee&rsquo;, { green: &lsquo;matcha&rsquo; });
    assert.notDeepOwnPropertyVal({}, &lsquo;toString&rsquo;, Object.prototype.toString);</p>

<h2 id="nestedproperty-object-property-message">.nestedProperty(object, property, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has a direct or inherited property named by
<code class="prettyprint">property</code>, which can be a string using dot- and bracket-notation for
nested reference.</p>

<p>assert.nestedProperty({ tea: { green: &lsquo;matcha&rsquo; }}, &lsquo;tea.green&rsquo;);</p>

<h2 id="notnestedproperty-object-property-message">.notNestedProperty(object, property, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> does <em>not</em> have a property named by <code class="prettyprint">property</code>, which
can be a string using dot- and bracket-notation for nested reference. The
property cannot exist on the object nor anywhere in its prototype chain.</p>

<p>assert.notNestedProperty({ tea: { green: &lsquo;matcha&rsquo; }}, &lsquo;tea.oolong&rsquo;);</p>

<h2 id="nestedpropertyval-object-property-value-message">.nestedPropertyVal(object, property, value, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has a property named by <code class="prettyprint">property</code> with value given
by <code class="prettyprint">value</code>. <code class="prettyprint">property</code> can use dot- and bracket-notation for nested
reference. Uses a strict equality check (===).</p>

<p>assert.nestedPropertyVal({ tea: { green: &lsquo;matcha&rsquo; }}, &lsquo;tea.green&rsquo;, &lsquo;matcha&rsquo;);</p>

<h2 id="notnestedpropertyval-object-property-value-message">.notNestedPropertyVal(object, property, value, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> does <em>not</em> have a property named by <code class="prettyprint">property</code> with
value given by <code class="prettyprint">value</code>. <code class="prettyprint">property</code> can use dot- and bracket-notation for
nested reference. Uses a strict equality check (===).</p>

<p>assert.notNestedPropertyVal({ tea: { green: &lsquo;matcha&rsquo; }}, &lsquo;tea.green&rsquo;, &lsquo;konacha&rsquo;);
    assert.notNestedPropertyVal({ tea: { green: &lsquo;matcha&rsquo; }}, &lsquo;coffee.green&rsquo;, &lsquo;matcha&rsquo;);</p>

<h2 id="deepnestedpropertyval-object-property-value-message">.deepNestedPropertyVal(object, property, value, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has a property named by <code class="prettyprint">property</code> with a value given
by <code class="prettyprint">value</code>. <code class="prettyprint">property</code> can use dot- and bracket-notation for nested
reference. Uses a deep equality check.</p>

<p>assert.deepNestedPropertyVal({ tea: { green: { matcha: &lsquo;yum&rsquo; } } }, &lsquo;tea.green&rsquo;, { matcha: &lsquo;yum&rsquo; });</p>

<h2 id="notdeepnestedpropertyval-object-property-value-message">.notDeepNestedPropertyVal(object, property, value, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> does <em>not</em> have a property named by <code class="prettyprint">property</code> with
value given by <code class="prettyprint">value</code>. <code class="prettyprint">property</code> can use dot- and bracket-notation for
nested reference. Uses a deep equality check.</p>

<p>assert.notDeepNestedPropertyVal({ tea: { green: { matcha: &lsquo;yum&rsquo; } } }, &lsquo;tea.green&rsquo;, { oolong: &lsquo;yum&rsquo; });
    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: &lsquo;yum&rsquo; } } }, &lsquo;tea.green&rsquo;, { matcha: &lsquo;yuck&rsquo; });
    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: &lsquo;yum&rsquo; } } }, &lsquo;tea.black&rsquo;, { matcha: &lsquo;yum&rsquo; });</p>

<h2 id="lengthof-object-length-message">.lengthOf(object, length, [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has a <code class="prettyprint">length</code> property with the expected value.</p>

<p>assert.lengthOf([1,2,3], 3, &lsquo;array has length of 3&rsquo;);
    assert.lengthOf(&lsquo;foobar&rsquo;, 6, &lsquo;string has length of 6&rsquo;);</p>

<h2 id="hasanykeys-object-keys-message">.hasAnyKeys(object, [keys], [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has at least one of the <code class="prettyprint">keys</code> provided.
You can also provide a single object instead of a <code class="prettyprint">keys</code> array and its keys
will be used as the expected set of keys.</p>

<p>assert.hasAnyKey({foo: 1, bar: 2, baz: 3}, [&lsquo;foo&rsquo;, &lsquo;iDontExist&rsquo;, &lsquo;baz&rsquo;]);
    assert.hasAnyKey({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337]);
    assert.hasAnyKey(new Map([[{foo: 1}, &lsquo;bar&rsquo;], [&lsquo;key&rsquo;, &lsquo;value&rsquo;]]), [{foo: 1}, &lsquo;thisKeyDoesNotExist&rsquo;]);
    assert.hasAnyKey(new Set([{foo: &lsquo;bar&rsquo;}, &lsquo;anotherKey&rsquo;], [{foo: &lsquo;bar&rsquo;}, &lsquo;thisKeyDoesNotExist&rsquo;]);</p>

<h2 id="hasallkeys-object-keys-message">.hasAllKeys(object, [keys], [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has all and only all of the <code class="prettyprint">keys</code> provided.
You can also provide a single object instead of a <code class="prettyprint">keys</code> array and its keys
will be used as the expected set of keys.</p>

<p>assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, [&lsquo;foo&rsquo;, &lsquo;bar&rsquo;, &lsquo;baz&rsquo;]);
    assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
    assert.hasAllKeys(new Map([[{foo: 1}, &lsquo;bar&rsquo;], [&lsquo;key&rsquo;, &lsquo;value&rsquo;]]), [{foo: 1}, &lsquo;key&rsquo;]);
    assert.hasAllKeys(new Set([{foo: &lsquo;bar&rsquo;}, &lsquo;anotherKey&rsquo;], [{foo: &lsquo;bar&rsquo;}, &lsquo;anotherKey&rsquo;]);</p>

<h2 id="containsallkeys-object-keys-message">.containsAllKeys(object, [keys], [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has all of the <code class="prettyprint">keys</code> provided but may have more keys not listed.
You can also provide a single object instead of a <code class="prettyprint">keys</code> array and its keys
will be used as the expected set of keys.</p>

<p>assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, [&lsquo;foo&rsquo;, &lsquo;baz&rsquo;]);
    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, [&lsquo;foo&rsquo;, &lsquo;bar&rsquo;, &lsquo;baz&rsquo;]);
    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
    assert.containsAllKeys(new Map([[{foo: 1}, &lsquo;bar&rsquo;], [&lsquo;key&rsquo;, &lsquo;value&rsquo;]]), [{foo: 1}]);
    assert.containsAllKeys(new Map([[{foo: 1}, &lsquo;bar&rsquo;], [&lsquo;key&rsquo;, &lsquo;value&rsquo;]]), [{foo: 1}, &lsquo;key&rsquo;]);
    assert.containsAllKeys(new Set([{foo: &lsquo;bar&rsquo;}, &lsquo;anotherKey&rsquo;], [{foo: &lsquo;bar&rsquo;}]);
    assert.containsAllKeys(new Set([{foo: &lsquo;bar&rsquo;}, &lsquo;anotherKey&rsquo;], [{foo: &lsquo;bar&rsquo;}, &lsquo;anotherKey&rsquo;]);</p>

<h2 id="doesnothaveanykeys-object-keys-message">.doesNotHaveAnyKeys(object, [keys], [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has none of the <code class="prettyprint">keys</code> provided.
You can also provide a single object instead of a <code class="prettyprint">keys</code> array and its keys
will be used as the expected set of keys.</p>

<p>assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, [&lsquo;one&rsquo;, &lsquo;two&rsquo;, &lsquo;example&rsquo;]);
    assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: &lsquo;foo&rsquo;});
    assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, &lsquo;bar&rsquo;], [&lsquo;key&rsquo;, &lsquo;value&rsquo;]]), [{one: &lsquo;two&rsquo;}, &lsquo;example&rsquo;]);
    assert.doesNotHaveAnyKeys(new Set([{foo: &lsquo;bar&rsquo;}, &lsquo;anotherKey&rsquo;], [{one: &lsquo;two&rsquo;}, &lsquo;example&rsquo;]);</p>

<h2 id="doesnothaveallkeys-object-keys-message">.doesNotHaveAllKeys(object, [keys], [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> does not have at least one of the <code class="prettyprint">keys</code> provided.
You can also provide a single object instead of a <code class="prettyprint">keys</code> array and its keys
will be used as the expected set of keys.</p>

<p>assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, [&lsquo;one&rsquo;, &lsquo;two&rsquo;, &lsquo;example&rsquo;]);
    assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: &lsquo;foo&rsquo;});
    assert.doesNotHaveAllKeys(new Map([[{foo: 1}, &lsquo;bar&rsquo;], [&lsquo;key&rsquo;, &lsquo;value&rsquo;]]), [{one: &lsquo;two&rsquo;}, &lsquo;example&rsquo;]);
    assert.doesNotHaveAllKeys(new Set([{foo: &lsquo;bar&rsquo;}, &lsquo;anotherKey&rsquo;], [{one: &lsquo;two&rsquo;}, &lsquo;example&rsquo;]);</p>

<h2 id="hasanydeepkeys-object-keys-message">.hasAnyDeepKeys(object, [keys], [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has at least one of the <code class="prettyprint">keys</code> provided.
Since Sets and Maps can have objects as keys you can use this assertion to perform
a deep comparison.
You can also provide a single object instead of a <code class="prettyprint">keys</code> array and its keys
will be used as the expected set of keys.</p>

<p>assert.hasAnyDeepKeys(new Map([[{one: &lsquo;one&rsquo;}, &lsquo;valueOne&rsquo;], [1, 2]]), {one: &lsquo;one&rsquo;});
    assert.hasAnyDeepKeys(new Map([[{one: &lsquo;one&rsquo;}, &lsquo;valueOne&rsquo;], [1, 2]]), [{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]);
    assert.hasAnyDeepKeys(new Map([[{one: &lsquo;one&rsquo;}, &lsquo;valueOne&rsquo;], [{two: &lsquo;two&rsquo;}, &lsquo;valueTwo&rsquo;]]), [{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]);
    assert.hasAnyDeepKeys(new Set([{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]), {one: &lsquo;one&rsquo;});
    assert.hasAnyDeepKeys(new Set([{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]), [{one: &lsquo;one&rsquo;}, {three: &lsquo;three&rsquo;}]);
    assert.hasAnyDeepKeys(new Set([{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]), [{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]);</p>

<h2 id="hasalldeepkeys-object-keys-message">.hasAllDeepKeys(object, [keys], [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has all and only all of the <code class="prettyprint">keys</code> provided.
Since Sets and Maps can have objects as keys you can use this assertion to perform
a deep comparison.
You can also provide a single object instead of a <code class="prettyprint">keys</code> array and its keys
will be used as the expected set of keys.</p>

<p>assert.hasAllDeepKeys(new Map([[{one: &lsquo;one&rsquo;}, &lsquo;valueOne&rsquo;]]), {one: &lsquo;one&rsquo;});
    assert.hasAllDeepKeys(new Map([[{one: &lsquo;one&rsquo;}, &lsquo;valueOne&rsquo;], [{two: &lsquo;two&rsquo;}, &lsquo;valueTwo&rsquo;]]), [{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]);
    assert.hasAllDeepKeys(new Set([{one: &lsquo;one&rsquo;}]), {one: &lsquo;one&rsquo;});
    assert.hasAllDeepKeys(new Set([{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]), [{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]);</p>

<h2 id="containsalldeepkeys-object-keys-message">.containsAllDeepKeys(object, [keys], [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> contains all of the <code class="prettyprint">keys</code> provided.
Since Sets and Maps can have objects as keys you can use this assertion to perform
a deep comparison.
You can also provide a single object instead of a <code class="prettyprint">keys</code> array and its keys
will be used as the expected set of keys.</p>

<p>assert.containsAllDeepKeys(new Map([[{one: &lsquo;one&rsquo;}, &lsquo;valueOne&rsquo;], [1, 2]]), {one: &lsquo;one&rsquo;});
    assert.containsAllDeepKeys(new Map([[{one: &lsquo;one&rsquo;}, &lsquo;valueOne&rsquo;], [{two: &lsquo;two&rsquo;}, &lsquo;valueTwo&rsquo;]]), [{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]);
    assert.containsAllDeepKeys(new Set([{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]), {one: &lsquo;one&rsquo;});
    assert.containsAllDeepKeys(new Set([{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]), [{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]);</p>

<h2 id="doesnothaveanydeepkeys-object-keys-message">.doesNotHaveAnyDeepKeys(object, [keys], [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> has none of the <code class="prettyprint">keys</code> provided.
Since Sets and Maps can have objects as keys you can use this assertion to perform
a deep comparison.
You can also provide a single object instead of a <code class="prettyprint">keys</code> array and its keys
will be used as the expected set of keys.</p>

<p>assert.doesNotHaveAnyDeepKeys(new Map([[{one: &lsquo;one&rsquo;}, &lsquo;valueOne&rsquo;], [1, 2]]), {thisDoesNot: &lsquo;exist&rsquo;});
    assert.doesNotHaveAnyDeepKeys(new Map([[{one: &lsquo;one&rsquo;}, &lsquo;valueOne&rsquo;], [{two: &lsquo;two&rsquo;}, &lsquo;valueTwo&rsquo;]]), [{twenty: &lsquo;twenty&rsquo;}, {fifty: &lsquo;fifty&rsquo;}]);
    assert.doesNotHaveAnyDeepKeys(new Set([{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]), {twenty: &lsquo;twenty&rsquo;});
    assert.doesNotHaveAnyDeepKeys(new Set([{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]), [{twenty: &lsquo;twenty&rsquo;}, {fifty: &lsquo;fifty&rsquo;}]);</p>

<h2 id="doesnothavealldeepkeys-object-keys-message">.doesNotHaveAllDeepKeys(object, [keys], [message])</h2>

<p>Asserts that <code class="prettyprint">object</code> does not have at least one of the <code class="prettyprint">keys</code> provided.
Since Sets and Maps can have objects as keys you can use this assertion to perform
a deep comparison.
You can also provide a single object instead of a <code class="prettyprint">keys</code> array and its keys
will be used as the expected set of keys.</p>

<p>assert.doesNotHaveAllDeepKeys(new Map([[{one: &lsquo;one&rsquo;}, &lsquo;valueOne&rsquo;], [1, 2]]), {thisDoesNot: &lsquo;exist&rsquo;});
    assert.doesNotHaveAllDeepKeys(new Map([[{one: &lsquo;one&rsquo;}, &lsquo;valueOne&rsquo;], [{two: &lsquo;two&rsquo;}, &lsquo;valueTwo&rsquo;]]), [{twenty: &lsquo;twenty&rsquo;}, {one: &lsquo;one&rsquo;}]);
    assert.doesNotHaveAllDeepKeys(new Set([{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]), {twenty: &lsquo;twenty&rsquo;});
    assert.doesNotHaveAllDeepKeys(new Set([{one: &lsquo;one&rsquo;}, {two: &lsquo;two&rsquo;}]), [{one: &lsquo;one&rsquo;}, {fifty: &lsquo;fifty&rsquo;}]);</p>

<h2 id="throws-fn-errorlike-string-regexp-string-regexp-message">.throws(fn, [errorLike/string/regexp], [string/regexp], [message])</h2>

<p>If <code class="prettyprint">errorLike</code> is an <code class="prettyprint">Error</code> constructor, asserts that <code class="prettyprint">fn</code> will throw an error that is an
instance of <code class="prettyprint">errorLike</code>.
If <code class="prettyprint">errorLike</code> is an <code class="prettyprint">Error</code> instance, asserts that the error thrown is the same
instance as <code class="prettyprint">errorLike</code>.
If <code class="prettyprint">errMsgMatcher</code> is provided, it also asserts that the error thrown will have a
message matching <code class="prettyprint">errMsgMatcher</code>.</p>

<p>assert.throws(fn, &lsquo;function throws a reference error&rsquo;);
    assert.throws(fn, /function throws a reference error/);
    assert.throws(fn, ReferenceError);
    assert.throws(fn, errorInstance);
    assert.throws(fn, ReferenceError, &lsquo;Error thrown must be a ReferenceError and have this msg&rsquo;);
    assert.throws(fn, errorInstance, &lsquo;Error thrown must be the same errorInstance and have this msg&rsquo;);
    assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
    assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);</p>

<h2 id="doesnotthrow-fn-errorlike-string-regexp-string-regexp-message">.doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])</h2>

<p>If <code class="prettyprint">errorLike</code> is an <code class="prettyprint">Error</code> constructor, asserts that <code class="prettyprint">fn</code> will <em>not</em> throw an error that is an
instance of <code class="prettyprint">errorLike</code>.
If <code class="prettyprint">errorLike</code> is an <code class="prettyprint">Error</code> instance, asserts that the error thrown is <em>not</em> the same
instance as <code class="prettyprint">errorLike</code>.
If <code class="prettyprint">errMsgMatcher</code> is provided, it also asserts that the error thrown will <em>not</em> have a
message matching <code class="prettyprint">errMsgMatcher</code>.</p>

<p>assert.doesNotThrow(fn, &lsquo;Any Error thrown must not have this message&rsquo;);
    assert.doesNotThrow(fn, /Any Error thrown must not match this/);
    assert.doesNotThrow(fn, Error);
    assert.doesNotThrow(fn, errorInstance);
    assert.doesNotThrow(fn, Error, &lsquo;Error must not have this message&rsquo;);
    assert.doesNotThrow(fn, errorInstance, &lsquo;Error must not have this message&rsquo;);
    assert.doesNotThrow(fn, Error, /Error must not match this/);
    assert.doesNotThrow(fn, errorInstance, /Error must not match this/);</p>

<h2 id="operator-val1-operator-val2-message">.operator(val1, operator, val2, [message])</h2>

<p>Compares two values using <code class="prettyprint">operator</code>.</p>

<p>assert.operator(1, &lsquo;&lt;&rsquo;, 2, &lsquo;everything is ok&rsquo;);
    assert.operator(1, &lsquo;&gt;&rsquo;, 2, &lsquo;this will fail&rsquo;);</p>

<h2 id="closeto-actual-expected-delta-message">.closeTo(actual, expected, delta, [message])</h2>

<p>Asserts that the target is equal <code class="prettyprint">expected</code>, to within a +/- <code class="prettyprint">delta</code> range.</p>

<p>assert.closeTo(1.5, 1, 0.5, &lsquo;numbers are close&rsquo;);</p>

<h2 id="approximately-actual-expected-delta-message">.approximately(actual, expected, delta, [message])</h2>

<p>Asserts that the target is equal <code class="prettyprint">expected</code>, to within a +/- <code class="prettyprint">delta</code> range.</p>

<p>assert.approximately(1.5, 1, 0.5, &lsquo;numbers are close&rsquo;);</p>

<h2 id="samemembers-set1-set2-message">.sameMembers(set1, set2, [message])</h2>

<p>Asserts that <code class="prettyprint">set1</code> and <code class="prettyprint">set2</code> have the same members in any order. Uses a
strict equality check (===).</p>

<p>assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], &lsquo;same members&rsquo;);</p>

<h2 id="notsamemembers-set1-set2-message">.notSameMembers(set1, set2, [message])</h2>

<p>Asserts that <code class="prettyprint">set1</code> and <code class="prettyprint">set2</code> don&rsquo;t have the same members in any order.
Uses a strict equality check (===).</p>

<p>assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], &lsquo;not same members&rsquo;);</p>

<h2 id="samedeepmembers-set1-set2-message">.sameDeepMembers(set1, set2, [message])</h2>

<p>Asserts that <code class="prettyprint">set1</code> and <code class="prettyprint">set2</code> have the same members in any order. Uses a
deep equality check.</p>

<p>assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], &lsquo;same deep members&rsquo;);</p>

<h2 id="notsamedeepmembers-set1-set2-message">.notSameDeepMembers(set1, set2, [message])</h2>

<p>Asserts that <code class="prettyprint">set1</code> and <code class="prettyprint">set2</code> don&rsquo;t have the same members in any order.
Uses a deep equality check.</p>

<p>assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], &lsquo;not same deep members&rsquo;);</p>

<h2 id="sameorderedmembers-set1-set2-message">.sameOrderedMembers(set1, set2, [message])</h2>

<p>Asserts that <code class="prettyprint">set1</code> and <code class="prettyprint">set2</code> have the same members in the same order.
Uses a strict equality check (===).</p>

<p>assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], &lsquo;same ordered members&rsquo;);</p>

<h2 id="notsameorderedmembers-set1-set2-message">.notSameOrderedMembers(set1, set2, [message])</h2>

<p>Asserts that <code class="prettyprint">set1</code> and <code class="prettyprint">set2</code> don&rsquo;t have the same members in the same
order. Uses a strict equality check (===).</p>

<p>assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], &lsquo;not same ordered members&rsquo;);</p>

<h2 id="samedeeporderedmembers-set1-set2-message">.sameDeepOrderedMembers(set1, set2, [message])</h2>

<p>Asserts that <code class="prettyprint">set1</code> and <code class="prettyprint">set2</code> have the same members in the same order.
Uses a deep equality check.</p>

<p>assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], &lsquo;same deep ordered members&rsquo;);</p>

<h2 id="notsamedeeporderedmembers-set1-set2-message">.notSameDeepOrderedMembers(set1, set2, [message])</h2>

<p>Asserts that <code class="prettyprint">set1</code> and <code class="prettyprint">set2</code> don&rsquo;t have the same members in the same
order. Uses a deep equality check.</p>

<p>assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], &lsquo;not same deep ordered members&rsquo;);
assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], &lsquo;not same deep ordered members&rsquo;);</p>

<h2 id="includemembers-superset-subset-message">.includeMembers(superset, subset, [message])</h2>

<p>Asserts that <code class="prettyprint">subset</code> is included in <code class="prettyprint">superset</code> in any order. Uses a
strict equality check (===). Duplicates are ignored.</p>

<p>assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], &lsquo;include members&rsquo;);</p>

<h2 id="notincludemembers-superset-subset-message">.notIncludeMembers(superset, subset, [message])</h2>

<p>Asserts that <code class="prettyprint">subset</code> isn&rsquo;t included in <code class="prettyprint">superset</code> in any order. Uses a
strict equality check (===). Duplicates are ignored.</p>

<p>assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], &lsquo;not include members&rsquo;);</p>

<h2 id="includedeepmembers-superset-subset-message">.includeDeepMembers(superset, subset, [message])</h2>

<p>Asserts that <code class="prettyprint">subset</code> is included in <code class="prettyprint">superset</code> in any order. Uses a deep
equality check. Duplicates are ignored.</p>

<p>assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], &lsquo;include deep members&rsquo;);</p>

<h2 id="notincludedeepmembers-superset-subset-message">.notIncludeDeepMembers(superset, subset, [message])</h2>

<p>Asserts that <code class="prettyprint">subset</code> isn&rsquo;t included in <code class="prettyprint">superset</code> in any order. Uses a
deep equality check. Duplicates are ignored.</p>

<p>assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], &lsquo;not include deep members&rsquo;);</p>

<h2 id="includeorderedmembers-superset-subset-message">.includeOrderedMembers(superset, subset, [message])</h2>

<p>Asserts that <code class="prettyprint">subset</code> is included in <code class="prettyprint">superset</code> in the same order
beginning with the first element in <code class="prettyprint">superset</code>. Uses a strict equality
check (===).</p>

<p>assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], &lsquo;include ordered members&rsquo;);</p>

<h2 id="notincludeorderedmembers-superset-subset-message">.notIncludeOrderedMembers(superset, subset, [message])</h2>

<p>Asserts that <code class="prettyprint">subset</code> isn&rsquo;t included in <code class="prettyprint">superset</code> in the same order
beginning with the first element in <code class="prettyprint">superset</code>. Uses a strict equality
check (===).</p>

<p>assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], &lsquo;not include ordered members&rsquo;);
    assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], &lsquo;not include ordered members&rsquo;);</p>

<h2 id="includedeeporderedmembers-superset-subset-message">.includeDeepOrderedMembers(superset, subset, [message])</h2>

<p>Asserts that <code class="prettyprint">subset</code> is included in <code class="prettyprint">superset</code> in the same order
beginning with the first element in <code class="prettyprint">superset</code>. Uses a deep equality
check.</p>

<p>assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], &lsquo;include deep ordered members&rsquo;);</p>

<h2 id="notincludedeeporderedmembers-superset-subset-message">.notIncludeDeepOrderedMembers(superset, subset, [message])</h2>

<p>Asserts that <code class="prettyprint">subset</code> isn&rsquo;t included in <code class="prettyprint">superset</code> in the same order
beginning with the first element in <code class="prettyprint">superset</code>. Uses a deep equality
check.</p>

<p>assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], &lsquo;not include deep ordered members&rsquo;);
    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], &lsquo;not include deep ordered members&rsquo;);
    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], &lsquo;not include deep ordered members&rsquo;);</p>

<h2 id="oneof-inlist-list-message">.oneOf(inList, list, [message])</h2>

<p>Asserts that non-object, non-array value <code class="prettyprint">inList</code> appears in the flat array <code class="prettyprint">list</code>.</p>

<p>assert.oneOf(1, [ 2, 1 ], &lsquo;Not found in list&rsquo;);</p>

<h2 id="changes-function-object-property-message">.changes(function, object, property, [message])</h2>

<p>Asserts that a function changes the value of a property.</p>

<p>var obj = { val: 10 };
    var fn = function() { obj.val = 22 };
    assert.changes(fn, obj, &lsquo;val&rsquo;);</p>

<h2 id="changesby-function-object-property-delta-message">.changesBy(function, object, property, delta, [message])</h2>

<p>Asserts that a function changes the value of a property by an amount (delta).</p>

<p>var obj = { val: 10 };
    var fn = function() { obj.val += 2 };
    assert.changesBy(fn, obj, &lsquo;val&rsquo;, 2);</p>

<h2 id="doesnotchange-function-object-property-message">.doesNotChange(function, object, property, [message])</h2>

<p>Asserts that a function does not change the value of a property.</p>

<p>var obj = { val: 10 };
    var fn = function() { console.log(&lsquo;foo&rsquo;); };
    assert.doesNotChange(fn, obj, &lsquo;val&rsquo;);</p>

<h2 id="changesbutnotby-function-object-property-delta-message">.changesButNotBy(function, object, property, delta, [message])</h2>

<p>Asserts that a function does not change the value of a property or of a function&rsquo;s return value by an amount (delta)</p>

<p>var obj = { val: 10 };
    var fn = function() { obj.val += 10 };
    assert.changesButNotBy(fn, obj, &lsquo;val&rsquo;, 5);</p>

<h2 id="increases-function-object-property-message">.increases(function, object, property, [message])</h2>

<p>Asserts that a function increases a numeric object property.</p>

<p>var obj = { val: 10 };
    var fn = function() { obj.val = 13 };
    assert.increases(fn, obj, &lsquo;val&rsquo;);</p>

<h2 id="increasesby-function-object-property-delta-message">.increasesBy(function, object, property, delta, [message])</h2>

<p>Asserts that a function increases a numeric object property or a function&rsquo;s return value by an amount (delta).</p>

<p>var obj = { val: 10 };
    var fn = function() { obj.val += 10 };
    assert.increasesBy(fn, obj, &lsquo;val&rsquo;, 10);</p>

<h2 id="doesnotincrease-function-object-property-message">.doesNotIncrease(function, object, property, [message])</h2>

<p>Asserts that a function does not increase a numeric object property.</p>

<p>var obj = { val: 10 };
    var fn = function() { obj.val = 8 };
    assert.doesNotIncrease(fn, obj, &lsquo;val&rsquo;);</p>

<h2 id="increasesbutnotby-function-object-property-message">.increasesButNotBy(function, object, property, [message])</h2>

<p>Asserts that a function does not increase a numeric object property or function&rsquo;s return value by an amount (delta).</p>

<p>var obj = { val: 10 };
    var fn = function() { obj.val = 15 };
    assert.increasesButNotBy(fn, obj, &lsquo;val&rsquo;, 10);</p>

<h2 id="decreases-function-object-property-message">.decreases(function, object, property, [message])</h2>

<p>Asserts that a function decreases a numeric object property.</p>

<p>var obj = { val: 10 };
    var fn = function() { obj.val = 5 };
    assert.decreases(fn, obj, &lsquo;val&rsquo;);</p>

<h2 id="decreasesby-function-object-property-delta-message">.decreasesBy(function, object, property, delta, [message])</h2>

<p>Asserts that a function decreases a numeric object property or a function&rsquo;s return value by an amount (delta)</p>

<p>var obj = { val: 10 };
    var fn = function() { obj.val -= 5 };
    assert.decreasesBy(fn, obj, &lsquo;val&rsquo;, 5);</p>

<h2 id="doesnotdecrease-function-object-property-message">.doesNotDecrease(function, object, property, [message])</h2>

<p>Asserts that a function does not decreases a numeric object property.</p>

<p>var obj = { val: 10 };
    var fn = function() { obj.val = 15 };
    assert.doesNotDecrease(fn, obj, &lsquo;val&rsquo;);</p>

<h2 id="doesnotdecreaseby-function-object-property-delta-message">.doesNotDecreaseBy(function, object, property, delta, [message])</h2>

<p>Asserts that a function does not decreases a numeric object property or a function&rsquo;s return value by an amount (delta)</p>

<p>var obj = { val: 10 };
    var fn = function() { obj.val = 5 };
    assert.doesNotDecreaseBy(fn, obj, &lsquo;val&rsquo;, 1);</p>

<h2 id="decreasesbutnotby-function-object-property-delta-message">.decreasesButNotBy(function, object, property, delta, [message])</h2>

<p>Asserts that a function does not decreases a numeric object property or a function&rsquo;s return value by an amount (delta)</p>

<p>var obj = { val: 10 };
    var fn = function() { obj.val = 5 };
    assert.decreasesButNotBy(fn, obj, &lsquo;val&rsquo;, 1);</p>

<h2 id="iferror-object">.ifError(object)</h2>

<p>Asserts if value is not a false value, and throws if it is a true value.
This is added to allow for chai to be a drop-in replacement for Node&rsquo;s
assert class.</p>

<p>var err = new Error(&lsquo;I am a custom error&rsquo;);
    assert.ifError(err); // Rethrows err!</p>

<h2 id="isextensible-object">.isExtensible(object)</h2>

<p>Asserts that <code class="prettyprint">object</code> is extensible (can have new properties added to it).</p>

<p>assert.isExtensible({});</p>

<h2 id="isnotextensible-object">.isNotExtensible(object)</h2>

<p>Asserts that <code class="prettyprint">object</code> is <em>not</em> extensible.</p>

<p>var nonExtensibleObject = Object.preventExtensions({});
    var sealedObject = Object.seal({});
    var frozenObject = Object.freeze({});</p>

<p>assert.isNotExtensible(nonExtensibleObject);
    assert.isNotExtensible(sealedObject);
    assert.isNotExtensible(frozenObject);</p>

<h2 id="issealed-object">.isSealed(object)</h2>

<p>Asserts that <code class="prettyprint">object</code> is sealed (cannot have new properties added to it
and its existing properties cannot be removed).</p>

<p>var sealedObject = Object.seal({});
    var frozenObject = Object.seal({});</p>

<p>assert.isSealed(sealedObject);
    assert.isSealed(frozenObject);</p>

<h2 id="isnotsealed-object">.isNotSealed(object)</h2>

<p>Asserts that <code class="prettyprint">object</code> is <em>not</em> sealed.</p>

<p>assert.isNotSealed({});</p>

<h2 id="isfrozen-object">.isFrozen(object)</h2>

<p>Asserts that <code class="prettyprint">object</code> is frozen (cannot have new properties added to it
and its existing properties cannot be modified).</p>

<p>var frozenObject = Object.freeze({});
    assert.frozen(frozenObject);</p>

<h2 id="isnotfrozen-object">.isNotFrozen(object)</h2>

<p>Asserts that <code class="prettyprint">object</code> is <em>not</em> frozen.</p>

<p>assert.isNotFrozen({});</p>

<h2 id="isempty-target">.isEmpty(target)</h2>

<p>Asserts that the target does not contain any values.
For arrays and strings, it checks the <code class="prettyprint">length</code> property.
For <code class="prettyprint">Map</code> and <code class="prettyprint">Set</code> instances, it checks the <code class="prettyprint">size</code> property.
For non-function objects, it gets the count of own
enumerable string keys.</p>

<p>assert.isEmpty([]);
    assert.isEmpty(&rdquo;);
    assert.isEmpty(new Map);
    assert.isEmpty({});</p>

<h2 id="isnotempty-target">.isNotEmpty(target)</h2>

<p>Asserts that the target contains values.
For arrays and strings, it checks the <code class="prettyprint">length</code> property.
For <code class="prettyprint">Map</code> and <code class="prettyprint">Set</code> instances, it checks the <code class="prettyprint">size</code> property.
For non-function objects, it gets the count of own
enumerable string keys.</p>

<p>assert.isNotEmpty([1, 2]);
    assert.isNotEmpty(&lsquo;34&rsquo;);
    assert.isNotEmpty(new Set([5, 6]));
    assert.isNotEmpty({ key: 7 });
Aliases.
chai
Copyright&copy; 2011-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="fail-actual-expected-message-operator">.fail(actual, expected, [message], [operator])</h2>

<p>Throw a failure.
chai
Copyright&copy; 2011-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="fail-actual-expected-message-operator">.fail(actual, expected, [message], [operator])</h2>

<p>Throw a failure.</p>

<h2 id="equal-actual-expected-message">.equal(actual, expected, [message])</h2>

<p>Asserts non-strict equality (<code class="prettyprint">==</code>) of <code class="prettyprint">actual</code> and <code class="prettyprint">expected</code>.</p>

<p>should.equal(3, &lsquo;3&rsquo;, &lsquo;== coerces values to strings&rsquo;);</p>

<h2 id="throw-function-constructor-string-regexp-string-regexp-message">.throw(function, [constructor/string/regexp], [string/regexp], [message])</h2>

<p>Asserts that <code class="prettyprint">function</code> will throw an error that is an instance of
<code class="prettyprint">constructor</code>, or alternately that it will throw an error with message
matching <code class="prettyprint">regexp</code>.</p>

<p>should.throw(fn, &lsquo;function throws a reference error&rsquo;);
    should.throw(fn, /function throws a reference error/);
    should.throw(fn, ReferenceError);
    should.throw(fn, ReferenceError, &lsquo;function throws a reference error&rsquo;);
    should.throw(fn, ReferenceError, /function throws a reference error/);</p>

<h2 id="exist">.exist</h2>

<p>Asserts that the target is neither <code class="prettyprint">null</code> nor <code class="prettyprint">undefined</code>.</p>

<p>var foo = &lsquo;hi&rsquo;;</p>

<p>should.exist(foo, &lsquo;foo exists&rsquo;);</p>

<h2 id="not-equal-actual-expected-message">.not.equal(actual, expected, [message])</h2>

<p>Asserts non-strict inequality (<code class="prettyprint">!=</code>) of <code class="prettyprint">actual</code> and <code class="prettyprint">expected</code>.</p>

<p>should.not.equal(3, 4, &lsquo;these numbers are not equal&rsquo;);</p>

<h2 id="throw-function-constructor-regexp-message">.throw(function, [constructor/regexp], [message])</h2>

<p>Asserts that <code class="prettyprint">function</code> will <em>not</em> throw an error that is an instance of
<code class="prettyprint">constructor</code>, or alternately that it will not throw an error with message
matching <code class="prettyprint">regexp</code>.</p>

<p>should.not.throw(fn, Error, &lsquo;function does not throw&rsquo;);</p>

<h2 id="not-exist">.not.exist</h2>

<p>Asserts that the target is neither <code class="prettyprint">null</code> nor <code class="prettyprint">undefined</code>.</p>

<p>var bar = null;</p>

<p>should.not.exist(bar, &lsquo;bar does not exist&rsquo;);
Chai - addChainingMethod utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed
Module dependencies
Module variables</p>

<h2 id="addchainablemethod-ctx-name-method-chainingbehavior">.addChainableMethod(ctx, name, method, chainingBehavior)</h2>

<p>Adds a method to an object, such that the method can also be chained.</p>

<p>utils.addChainableMethod(chai.Assertion.prototype, &lsquo;foo&rsquo;, function (str) {
      var obj = utils.flag(this, &lsquo;object&rsquo;);
      new chai.Assertion(obj).to.be.equal(str);
    });</p>

<p>Can also be accessed directly from <code class="prettyprint">chai.Assertion</code>.</p>

<p>chai.Assertion.addChainableMethod(&lsquo;foo&rsquo;, fn, chainingBehavior);</p>

<p>The result can then be used as both a method assertion, executing both <code class="prettyprint">method</code> and
<code class="prettyprint">chainingBehavior</code>, or as a language chain, which only executes <code class="prettyprint">chainingBehavior</code>.</p>

<p>expect(fooStr).to.be.foo(&lsquo;bar&rsquo;);
    expect(fooStr).to.be.foo.equal(&lsquo;foo&rsquo;);
Chai - addLengthGuard utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="addlengthguard-fn-assertionname-ischainable">.addLengthGuard(fn, assertionName, isChainable)</h2>

<p>Define <code class="prettyprint">length</code> as a getter on the given uninvoked method assertion. The
getter acts as a guard against chaining <code class="prettyprint">length</code> directly off of an uninvoked
method assertion, which is a problem because it references <code class="prettyprint">function</code>&lsquo;s
built-in <code class="prettyprint">length</code> property instead of Chai&rsquo;s <code class="prettyprint">length</code> assertion. When the
getter catches the user making this mistake, it throws an error with a
helpful message.</p>

<p>There are two ways in which this mistake can be made. The first way is by
chaining the <code class="prettyprint">length</code> assertion directly off of an uninvoked chainable
method. In this case, Chai suggests that the user use <code class="prettyprint">lengthOf</code> instead. The
second way is by chaining the <code class="prettyprint">length</code> assertion directly off of an uninvoked
non-chainable method. Non-chainable methods must be invoked prior to
chaining. In this case, Chai suggests that the user consult the docs for the
given assertion.</p>

<p>If the <code class="prettyprint">length</code> property of functions is unconfigurable, then return <code class="prettyprint">fn</code>
without modification.</p>

<p>Note that in ES6, the function&rsquo;s <code class="prettyprint">length</code> property is configurable, so once
support for legacy environments is dropped, Chai&rsquo;s <code class="prettyprint">length</code> property can
replace the built-in function&rsquo;s <code class="prettyprint">length</code> property, and this length guard will
no longer be necessary. In the mean time, maintaining consistency across all
environments is the priority.
Chai - addMethod utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="addmethod-ctx-name-method">.addMethod(ctx, name, method)</h2>

<p>Adds a method to the prototype of an object.</p>

<p>utils.addMethod(chai.Assertion.prototype, &#39;foo&rsquo;, function (str) {
      var obj = utils.flag(this, &lsquo;object&rsquo;);
      new chai.Assertion(obj).to.be.equal(str);
    });</p>

<p>Can also be accessed directly from <code class="prettyprint">chai.Assertion</code>.</p>

<p>chai.Assertion.addMethod(&lsquo;foo&rsquo;, fn);</p>

<p>Then can be used as any other assertion.</p>

<p>expect(fooStr).to.be.foo(&lsquo;bar&rsquo;);
Chai - addProperty utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="addproperty-ctx-name-getter">.addProperty(ctx, name, getter)</h2>

<p>Adds a property to the prototype of an object.</p>

<p>utils.addProperty(chai.Assertion.prototype, &lsquo;foo&rsquo;, function () {
      var obj = utils.flag(this, &lsquo;object&rsquo;);
      new chai.Assertion(obj).to.be.instanceof(Foo);
    });</p>

<p>Can also be accessed directly from <code class="prettyprint">chai.Assertion</code>.</p>

<p>chai.Assertion.addProperty(&lsquo;foo&rsquo;, fn);</p>

<p>Then can be used as any other assertion.</p>

<p>expect(myFoo).to.be.foo;
Chai - compareByInspect utility
Copyright&copy; 2011-2016 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed
Module dependancies</p>

<h2 id="comparebyinspect-mixed-mixed">.compareByInspect(mixed, mixed)</h2>

<p>To be used as a compareFunction with Array.prototype.sort. Compares elements
using inspect instead of default behavior of using toString so that Symbols
and objects with irregular/missing toString can still be sorted without a
TypeError.
Chai - expectTypes utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="expecttypes-obj-types">.expectTypes(obj, types)</h2>

<p>Ensures that the object being tested against is of a valid type.</p>

<p>utils.expectTypes(this, [&lsquo;array&rsquo;, &lsquo;object&rsquo;, &lsquo;string&rsquo;]);
Chai - flag utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="flag-object-key-value">.flag(object, key, [value])</h2>

<p>Get or set a flag value on an object. If a
value is provided it will be set, else it will
return the currently set value or <code class="prettyprint">undefined</code> if
the value is not set.</p>

<p>utils.flag(this, &lsquo;foo&rsquo;, &lsquo;bar&rsquo;); // setter
    utils.flag(this, &lsquo;foo&rsquo;); // getter, returns <code class="prettyprint">bar</code>
Chai - getActual utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="getactual-object-actual">.getActual(object, [actual])</h2>

<p>Returns the <code class="prettyprint">actual</code> value for an Assertion.
Chai - getEnumerableProperties utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="getenumerableproperties-object">.getEnumerableProperties(object)</h2>

<p>This allows the retrieval of enumerable property names of an object,
inherited or not.
Chai - message composition utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed
Module dependancies</p>

<h2 id="getmessage-object-message-negatemessage">.getMessage(object, message, negateMessage)</h2>

<p>Construct the error message based on flags
and template tags. Template tags will return
a stringified inspection of the object referenced.</p>

<p>Message template tags:
- <code class="prettyprint">#{this}</code> current asserted object
- <code class="prettyprint">#{act}</code> actual value
- <code class="prettyprint">#{exp}</code> expected value
Chai - getOwnEnumerableProperties utility
Copyright&copy; 2011-2016 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed
Module dependancies</p>

<h2 id="getownenumerableproperties-object">.getOwnEnumerableProperties(object)</h2>

<p>This allows the retrieval of directly-owned enumerable property names and
symbols of an object. This function is necessary because Object.keys only
returns enumerable property names, not enumerable property symbols.
Chai - getOwnEnumerablePropertySymbols utility
Copyright&copy; 2011-2016 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="getownenumerablepropertysymbols-object">.getOwnEnumerablePropertySymbols(object)</h2>

<p>This allows the retrieval of directly-owned enumerable property symbols of an
object. This function is necessary because Object.getOwnPropertySymbols
returns both enumerable and non-enumerable property symbols.
Chai - getProperties utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="getproperties-object">.getProperties(object)</h2>

<p>This allows the retrieval of property names of an object, enumerable or not,
inherited or not.
chai
Copyright&copy; 2011 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed
Dependencies that are used for multiple exports are required here only once
test utility
type utility
expectTypes utility
message utility
actual utility
Inspect util
Object Display util
Flag utility
Flag transferring utility
Deep equal utility
Deep path info
Check if a property exists
Function name
add Property
add Method
overwrite Property
overwrite Method
Add a chainable method
Overwrite chainable method
Compare by inspect method
Get own enumerable property symbols method
Get own enumerable properties method
Checks error against a given set of criteria
Proxify util
addLengthGuard util
isProxyEnabled helper
isNaN method</p>

<h2 id="inspect-obj-showhidden-depth-colors">.inspect(obj, [showHidden], [depth], [colors])</h2>

<p>Echoes the value of a value. Tries to print the value out
in the best way possible given the different types.
Chai - isNaN utility
Copyright&copy; 2012-2015 Sakthipriyan Vairamani <a href="mailto:thechargingvolcano@gmail.com">thechargingvolcano@gmail.com</a>
MIT Licensed</p>

<h2 id="isnan-value">.isNaN(value)</h2>

<p>Checks if the given value is NaN or not.</p>

<p>utils.isNaN(NaN); // true
Chai - isProxyEnabled helper
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="isproxyenabled">.isProxyEnabled()</h2>

<p>Helper function to check if Chai&rsquo;s proxy protection feature is enabled. If
proxies are unsupported or disabled via the user&rsquo;s Chai config, then return
false. Otherwise, return true.
Chai - flag utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed
Module dependancies</p>

<h2 id="objdisplay-object">.objDisplay(object)</h2>

<p>Determines if an object or an array matches
criteria to be inspected in-line for error
messages or should be truncated.
Chai - overwriteChainableMethod utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="overwritechainablemethod-ctx-name-method-chainingbehavior">.overwriteChainableMethod(ctx, name, method, chainingBehavior)</h2>

<p>Overwites an already existing chainable method
and provides access to the previous function or
property.  Must return functions to be used for
name.</p>

<p>utils.overwriteChainableMethod(chai.Assertion.prototype, &lsquo;lengthOf&rsquo;,
      function (_super) {
      }
    , function (_super) {
      }
    );</p>

<p>Can also be accessed directly from <code class="prettyprint">chai.Assertion</code>.</p>

<p>chai.Assertion.overwriteChainableMethod(&lsquo;foo&rsquo;, fn, fn);</p>

<p>Then can be used as any other assertion.</p>

<p>expect(myFoo).to.have.lengthOf(3);
    expect(myFoo).to.have.lengthOf.above(3);
Chai - overwriteMethod utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="overwritemethod-ctx-name-fn">.overwriteMethod(ctx, name, fn)</h2>

<p>Overwites an already existing method and provides
access to previous function. Must return function
to be used for name.</p>

<p>utils.overwriteMethod(chai.Assertion.prototype, &lsquo;equal&rsquo;, function (_super) {
      return function (str) {
        var obj = utils.flag(this, &lsquo;object&rsquo;);
        if (obj instanceof Foo) {
          new chai.Assertion(obj.value).to.equal(str);
        } else {
          _super.apply(this, arguments);
        }
      }
    });</p>

<p>Can also be accessed directly from <code class="prettyprint">chai.Assertion</code>.</p>

<p>chai.Assertion.overwriteMethod(&lsquo;foo&rsquo;, fn);</p>

<p>Then can be used as any other assertion.</p>

<p>expect(myFoo).to.equal(&lsquo;bar&rsquo;);
Chai - overwriteProperty utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="overwriteproperty-ctx-name-fn">.overwriteProperty(ctx, name, fn)</h2>

<p>Overwites an already existing property getter and provides
access to previous value. Must return function to use as getter.</p>

<p>utils.overwriteProperty(chai.Assertion.prototype, &lsquo;ok&rsquo;, function (_super) {
      return function () {
        var obj = utils.flag(this, &lsquo;object&rsquo;);
        if (obj instanceof Foo) {
          new chai.Assertion(obj.name).to.equal(&lsquo;bar&rsquo;);
        } else {
          _super.call(this);
        }
      }
    });</p>

<p>Can also be accessed directly from <code class="prettyprint">chai.Assertion</code>.</p>

<p>chai.Assertion.overwriteProperty(&lsquo;foo&rsquo;, fn);</p>

<p>Then can be used as any other assertion.</p>

<p>expect(myFoo).to.be.ok;
Chai - proxify utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="proxify-object">.proxify(object)</h2>

<p>Return a proxy of given object that throws an error when a non-existent
property is read. By default, the root cause is assumed to be a misspelled
property, and thus an attempt is made to offer a reasonable suggestion from
the list of existing properties. However, if a nonChainableMethodName is
provided, then the root cause is instead a failure to invoke a non-chainable
method prior to reading the non-existent property.</p>

<p>If proxies are unsupported or disabled via the user&rsquo;s Chai config, then
return object without modification.</p>

<h1 id="stringdistance-stra-strb">stringDistance(strA, strB)</h1>

<p>Return the Levenshtein distance between two strings.
Chai - test utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed
Module dependancies</p>

<h2 id="test-object-expression">.test(object, expression)</h2>

<p>Test and object for expression.
Chai - transferFlags utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="transferflags-assertion-object-includeall-true">.transferFlags(assertion, object, includeAll = true)</h2>

<p>Transfer all the flags for <code class="prettyprint">assertion</code> to <code class="prettyprint">object</code>. If
<code class="prettyprint">includeAll</code> is set to <code class="prettyprint">false</code>, then the base Chai
assertion flags (namely <code class="prettyprint">object</code>, <code class="prettyprint">ssfi</code>, <code class="prettyprint">lockSsfi</code>,
and <code class="prettyprint">message</code>) will not be transferred.</p>

<p>var newAssertion = new Assertion();
    utils.transferFlags(assertion, newAssertion);</p>

<p>var anotherAsseriton = new Assertion(myObj);
    utils.transferFlags(assertion, anotherAssertion, false);
assertion-error
Copyright&copy; 2013 Jake Luer <a href="mailto:jake@qualiancy.com">jake@qualiancy.com</a>
MIT Licensed
Return a function that will copy properties from
one object to another excluding any originally
listed. Returned function will create a new <code class="prettyprint">{}</code>.
Primary Exports</p>

<h2 id="assertionerror">AssertionError</h2>

<p>An extension of the JavaScript <code class="prettyprint">Error</code> constructor for
assertion and validation scenarios.
Inherit from Error.prototype
Statically set name
Ensure correct constructor
Allow errors to be converted to JSON for static transfer.
!
Chai - checkError utility
Copyright&copy; 2012-2016 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="checkerror">.checkError</h2>

<p>Checks that an error conforms to a given set of criteria and/or retrieves information about it.</p>

<h2 id="compatibleinstance-thrown-errorlike">.compatibleInstance(thrown, errorLike)</h2>

<p>Checks if two instances are compatible (strict equal).
Returns false if errorLike is not an instance of Error, because instances
can only be compatible if they&rsquo;re both error instances.</p>

<h2 id="compatibleconstructor-thrown-errorlike">.compatibleConstructor(thrown, errorLike)</h2>

<p>Checks if two constructors are compatible.
This function can receive either an error constructor or
an error instance as the <code class="prettyprint">errorLike</code> argument.
Constructors are compatible if they&rsquo;re the same or if one is
an instance of another.</p>

<h2 id="compatiblemessage-thrown-errmatcher">.compatibleMessage(thrown, errMatcher)</h2>

<p>Checks if an error&rsquo;s message is compatible with a matcher (String or RegExp).
If the message contains the String or passes the RegExp test,
it is considered compatible.</p>

<h2 id="getfunctionname-constructorfn">.getFunctionName(constructorFn)</h2>

<p>Returns the name of a function.
This also includes a polyfill function if <code class="prettyprint">constructorFn.name</code> is not defined.</p>

<h2 id="getconstructorname-errorlike">.getConstructorName(errorLike)</h2>

<p>Gets the constructor name for an Error instance or constructor itself.</p>

<h2 id="getmessage-errorlike">.getMessage(errorLike)</h2>

<p>Gets the error message from an error.
If <code class="prettyprint">err</code> is a String itself, we return it.
If the error has no message, we return an empty string.
globals Symbol: true, Uint8Array: true, WeakMap: true
deep-eql
Copyright&copy; 2013 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed
Module dependencies
Check to see if the MemoizeMap has recorded a result of the two operands
Set the result of the equality into the MemoizeMap
Primary Export
Assert deeply nested sameValue equality between two objects of any type.
Many comparisons can be canceled out early via simple equality or primitive checks.
The main logic of the <code class="prettyprint">deepEqual</code> function.
Compare two Regular Expressions for equality.
Compare two Sets/Maps for equality. Faster than other equality functions.
Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
Simple equality for generator objects such as those returned by generator functions.
Determine if the given object has an @@iterator function.
Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
This will consume the iterator - which could have side effects depending on the @@iterator implementation.
Gets all entries from a Generator. This will consume the generator - which could have side effects.
Gets all own and inherited enumerable keys from a target.
Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
each key. If any value of the given key is not equal, the function will return false (early).
Recursively check the equality of two Objects. Once basic sameness has been established it will defer to <code class="prettyprint">deepEqual</code>
for each enumerable key in the object.
Returns true if the argument is a primitive.</p>

<p>This intentionally returns true for all objects that can be compared by reference,
including functions and symbols.
!
type-detect
Copyright&copy; 2013 jake luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="typeof-obj">typeOf (obj)</h2>

<p>Uses <code class="prettyprint">Object.prototype.toString</code> to determine the type of an object,
normalising behaviour across engine versions &amp; well optimised.
! Speed optimisation
Pre:
  string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
  boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
  number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
  undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
  function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
Post:
  string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
  boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
  number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
  undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
  function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
! Speed optimisation
Pre:
  null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
Post:
  null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
! Spec Conformance
Test: <code class="prettyprint">Object.prototype.toString.call(window)</code><code class="prettyprint">
 - Node === &quot;[object global]&quot;
 - Chrome === &quot;[object global]&quot;
 - Firefox === &quot;[object Window]&quot;
 - PhantomJS === &quot;[object Window]&quot;
 - Safari === &quot;[object Window]&quot;
 - IE 11 === &quot;[object Window]&quot;
 - IE Edge === &quot;[object Window]&quot;
Test:</code>Object.prototype.toString.call(this)<code class="prettyprint">
 - Chrome Worker === &quot;[object global]&quot;
 - Firefox Worker === &quot;[object DedicatedWorkerGlobalScope]&quot;
 - Safari Worker === &quot;[object DedicatedWorkerGlobalScope]&quot;
 - IE 11 Worker === &quot;[object WorkerGlobalScope]&quot;
 - IE Edge Worker === &quot;[object WorkerGlobalScope]&quot;
! Speed optimisation
Pre:
  array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
Post:
  array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
! Spec Conformance
(https://html.spec.whatwg.org/multipage/browsers.html#location)
WhatWG HTML$7.7.3 - The `Location` interface
Test: `Object.prototype.toString.call(window.location)</code>
 - IE &lt;=11 === &ldquo;[object Object]&rdquo;
 - IE Edge &lt;=13 === &ldquo;[object Object]&rdquo;
! Spec Conformance
(https://html.spec.whatwg.org/#document)
WhatWG HTML$3.1.1 - The <code class="prettyprint">Document</code> object
Note: Most browsers currently adher to the W3C DOM Level 2 spec
      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
      which suggests that browsers should use HTMLTableCellElement for
      both TD and TH elements. WhatWG separates these.
      WhatWG HTML states:
        &gt; For historical reasons, Window objects must also have a
        &gt; writable, configurable, non-enumerable property named
        &gt; HTMLDocument whose value is the Document interface object.
Test: <code class="prettyprint">Object.prototype.toString.call(document)</code><code class="prettyprint">
 - Chrome === &quot;[object HTMLDocument]&quot;
 - Firefox === &quot;[object HTMLDocument]&quot;
 - Safari === &quot;[object HTMLDocument]&quot;
 - IE &lt;=10 === &quot;[object Document]&quot;
 - IE 11 === &quot;[object HTMLDocument]&quot;
 - IE Edge &lt;=13 === &quot;[object HTMLDocument]&quot;
! Spec Conformance
(https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
Test:</code>Object.prototype.toString.call(navigator.mimeTypes)<code class="prettyprint">
 - IE &lt;=10 === &quot;[object MSMimeTypesCollection]&quot;
! Spec Conformance
(https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
Test: `Object.prototype.toString.call(navigator.plugins)</code>
 - IE &lt;=10 === &ldquo;[object MSPluginsCollection]&rdquo;
! Spec Conformance
(https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
WhatWG HTML$4.4.4 - The <code class="prettyprint">blockquote</code> element - Interface <code class="prettyprint">HTMLQuoteElement</code>
Test: <code class="prettyprint">Object.prototype.toString.call(document.createElement(&#39;blockquote&#39;))</code><code class="prettyprint">
 - IE &lt;=10 === &quot;[object HTMLBlockElement]&quot;
! Spec Conformance
(https://html.spec.whatwg.org/#htmltabledatacellelement)
WhatWG HTML$4.9.9 - The</code>td<code class="prettyprint">element - Interface</code>HTMLTableDataCellElement<code class="prettyprint">
Note: Most browsers currently adher to the W3C DOM Level 2 spec
      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
      which suggests that browsers should use HTMLTableCellElement for
      both TD and TH elements. WhatWG separates these.
Test: Object.prototype.toString.call(document.createElement(&#39;td&#39;))
 - Chrome === &quot;[object HTMLTableCellElement]&quot;
 - Firefox === &quot;[object HTMLTableCellElement]&quot;
 - Safari === &quot;[object HTMLTableCellElement]&quot;
! Spec Conformance
(https://html.spec.whatwg.org/#htmltableheadercellelement)
WhatWG HTML$4.9.9 - The</code>td<code class="prettyprint">element - Interface</code>HTMLTableHeaderCellElement<code class="prettyprint">
Note: Most browsers currently adher to the W3C DOM Level 2 spec
      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
      which suggests that browsers should use HTMLTableCellElement for
      both TD and TH elements. WhatWG separates these.
Test: Object.prototype.toString.call(document.createElement(&#39;th&#39;))
 - Chrome === &quot;[object HTMLTableCellElement]&quot;
 - Firefox === &quot;[object HTMLTableCellElement]&quot;
 - Safari === &quot;[object HTMLTableCellElement]&quot;
! Speed optimisation
Pre:
  Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
  Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
  Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
  Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
  Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
  Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
  Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
  Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
  Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
Post:
  Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
  Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
  Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
  Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
  Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
  Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
  Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
  Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
  Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
! Speed optimisation
Pre:
  regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
  regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
Post:
  regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
  regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
! Speed optimisation
Pre:
  date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
Post:
  date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be &quot;Promise&quot;:
Test:</code>Object.prototype.toString.call(Promise.resolve())<code class="prettyprint">
 - Chrome &lt;=47 === &quot;[object Object]&quot;
 - Edge &lt;=20 === &quot;[object Object]&quot;
 - Firefox 29-Latest === &quot;[object Promise]&quot;
 - Safari 7.1-Latest === &quot;[object Promise]&quot;
! Speed optimisation
Pre:
  set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
Post:
  set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
! Speed optimisation
Pre:
  map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
Post:
  map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
! Speed optimisation
Pre:
  weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
Post:
  weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
! Speed optimisation
Pre:
  weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
Post:
  weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be &quot;DataView&quot;:
Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))</code>
 - Edge &lt;=13 === &ldquo;[object Object]&rdquo;
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be &ldquo;Map Iterator&rdquo;:
Test: <code class="prettyprint">Object.prototype.toString.call(new Map().entries())</code><code class="prettyprint">
 - Edge &lt;=13 === &quot;[object Object]&quot;
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be &quot;Set Iterator&quot;:
Test:</code>Object.prototype.toString.call(new Set().entries())<code class="prettyprint">
 - Edge &lt;=13 === &quot;[object Object]&quot;
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be &quot;Array Iterator&quot;:
Test: `Object.prototype.toString.call([][Symbol.iterator]())</code>
 - Edge &lt;=13 === &ldquo;[object Object]&rdquo;
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be &ldquo;String Iterator&rdquo;:
Test: <code class="prettyprint">Object.prototype.toString.call(&#39;&#39;[Symbol.iterator]())</code>`
 - Edge &lt;=13 === &ldquo;[object Object]&rdquo;
! Speed optimisation
Pre:
  object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
Post:
  object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
!
Chai - getFuncName utility
Copyright&copy; 2012-2016 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="getfuncname-constructorfn">.getFuncName(constructorFn)</h2>

<p>Returns the name of a function.
When a non-function instance is passed, returns <code class="prettyprint">null</code>.
This also includes a polyfill function if <code class="prettyprint">aFunc.name</code> is not defined.
!
Chai - pathval utility
Copyright&copy; 2012-2014 Jake Luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a></p>

<h2 id="hasproperty-object-name">.hasProperty(object, name)</h2>

<p>This allows checking whether an object has own
or inherited from prototype chain named property.</p>

<p>Basically does the same thing as the <code class="prettyprint">in</code>
operator but works properly with null/undefined values
and other primitives.</p>

<p>var obj = {
        arr: [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;]
      , str: &lsquo;Hello&rsquo;
    }</p>

<p>The following would be the results.</p>

<p>hasProperty(obj, &lsquo;str&rsquo;);  // true
    hasProperty(obj, &lsquo;constructor&rsquo;);  // true
    hasProperty(obj, &lsquo;bar&rsquo;);  // false</p>

<p>hasProperty(obj.str, &lsquo;length&rsquo;); // true
    hasProperty(obj.str, 1);  // true
    hasProperty(obj.str, 5);  // false</p>

<p>hasProperty(obj.arr, &lsquo;length&rsquo;);  // true
    hasProperty(obj.arr, 2);  // true
    hasProperty(obj.arr, 3);  // false
!</p>

<h2 id="parsepath-path">parsePath(path)</h2>

<p>Helper function used to parse string object
paths. Use in conjunction with <code class="prettyprint">internalGetPathValue</code>.</p>

<p>var parsed = parsePath(&lsquo;myobject.property.subprop&rsquo;);</p>

<h2 id="paths">Paths:</h2>

<ul>
<li>Can be infinitely deep and nested.</li>
<li>Arrays are also valid using the formal <code class="prettyprint">myobject.document[3].property</code>.</li>
<li>Literal dots and brackets (not delimiter) must be backslash-escaped.
!
## internalGetPathValue(obj, parsed[, pathDepth])</li>
</ul>

<p>Helper companion function for <code class="prettyprint">.parsePath</code> that returns
the value located at the parsed address.</p>

<p>var value = getPathValue(obj, parsed);
!</p>

<h2 id="internalsetpathvalue-obj-value-parsed">internalSetPathValue(obj, value, parsed)</h2>

<p>Companion function for <code class="prettyprint">parsePath</code> that sets
the value located at a parsed address.</p>

<p>internalSetPathValue(obj, &lsquo;value&rsquo;, parsed);</p>

<h2 id="getpathinfo-object-path">.getPathInfo(object, path)</h2>

<p>This allows the retrieval of property info in an
object given a string path.</p>

<p>The path info consists of an object with the
following properties:</p>

<ul>
<li>parent - The parent object of the property referenced by <code class="prettyprint">path</code></li>
<li>name - The name of the final property, a number if it was an array indexer</li>
<li>value - The value of the property, if it exists, otherwise <code class="prettyprint">undefined</code></li>
<li>exists - Whether the property exists or not
## .getPathValue(object, path)</li>
</ul>

<p>This allows the retrieval of values in an
object given a string path.</p>

<p>var obj = {
        prop1: {
            arr: [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;]
          , str: &lsquo;Hello&rsquo;
        }
      , prop2: {
            arr: [ { nested: &lsquo;Universe&rsquo; } ]
          , str: &lsquo;Hello again!&rsquo;
        }
    }</p>

<p>The following would be the results.</p>

<p>getPathValue(obj, &lsquo;prop1.str&rsquo;); // Hello
    getPathValue(obj, &lsquo;prop1.att[2]&rsquo;); // b
    getPathValue(obj, &lsquo;prop2.arr[0].nested&rsquo;); // Universe</p>

<h2 id="setpathvalue-object-path-value">.setPathValue(object, path, value)</h2>

<p>Define the value in an object at a given string path.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">prop1</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">arr</span><span class="p">:</span> <span class="p">[</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">]</span>
      <span class="p">,</span> <span class="na">str</span><span class="p">:</span> <span class="s1">'Hello'</span>
    <span class="p">}</span>
  <span class="p">,</span> <span class="na">prop2</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">arr</span><span class="p">:</span> <span class="p">[</span> <span class="p">{</span> <span class="na">nested</span><span class="p">:</span> <span class="s1">'Universe'</span> <span class="p">}</span> <span class="p">]</span>
      <span class="p">,</span> <span class="na">str</span><span class="p">:</span> <span class="s1">'Hello again!'</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
<p>The following would be acceptable.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">properties</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'tea-properties'</span><span class="p">);</span>
<span class="nx">properties</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">'prop1.str'</span><span class="p">,</span> <span class="s1">'Hello Universe!'</span><span class="p">);</span>
<span class="nx">properties</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">'prop1.arr[2]'</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">);</span>
<span class="nx">properties</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">'prop2.arr[0].nested.value'</span><span class="p">,</span> <span class="p">{</span> <span class="na">hello</span><span class="p">:</span> <span class="s1">'universe'</span> <span class="p">});</span>
</code></pre>
<p>!
type-detect
Copyright&copy; 2013 jake luer <a href="mailto:jake@alogicalparadox.com">jake@alogicalparadox.com</a>
MIT Licensed</p>

<h2 id="typeof-obj">typeOf (obj)</h2>

<p>Uses <code class="prettyprint">Object.prototype.toString</code> to determine the type of an object,
normalising behaviour across engine versions &amp; well optimised.
! Speed optimisation
Pre:
  string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
  boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
  number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
  undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
  function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
Post:
  string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
  boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
  number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
  undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
  function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
! Speed optimisation
Pre:
  null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
Post:
  null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
! Spec Conformance
Test: <code class="prettyprint">Object.prototype.toString.call(window)</code><code class="prettyprint">
 - Node === &quot;[object global]&quot;
 - Chrome === &quot;[object global]&quot;
 - Firefox === &quot;[object Window]&quot;
 - PhantomJS === &quot;[object Window]&quot;
 - Safari === &quot;[object Window]&quot;
 - IE 11 === &quot;[object Window]&quot;
 - IE Edge === &quot;[object Window]&quot;
Test:</code>Object.prototype.toString.call(this)<code class="prettyprint">
 - Chrome Worker === &quot;[object global]&quot;
 - Firefox Worker === &quot;[object DedicatedWorkerGlobalScope]&quot;
 - Safari Worker === &quot;[object DedicatedWorkerGlobalScope]&quot;
 - IE 11 Worker === &quot;[object WorkerGlobalScope]&quot;
 - IE Edge Worker === &quot;[object WorkerGlobalScope]&quot;
! Speed optimisation
Pre:
  array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
Post:
  array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
! Spec Conformance
(https://html.spec.whatwg.org/multipage/browsers.html#location)
WhatWG HTML$7.7.3 - The `Location` interface
Test: `Object.prototype.toString.call(window.location)</code>
 - IE &lt;=11 === &ldquo;[object Object]&rdquo;
 - IE Edge &lt;=13 === &ldquo;[object Object]&rdquo;
! Spec Conformance
(https://html.spec.whatwg.org/#document)
WhatWG HTML$3.1.1 - The <code class="prettyprint">Document</code> object
Note: Most browsers currently adher to the W3C DOM Level 2 spec
      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
      which suggests that browsers should use HTMLTableCellElement for
      both TD and TH elements. WhatWG separates these.
      WhatWG HTML states:
        &gt; For historical reasons, Window objects must also have a
        &gt; writable, configurable, non-enumerable property named
        &gt; HTMLDocument whose value is the Document interface object.
Test: <code class="prettyprint">Object.prototype.toString.call(document)</code><code class="prettyprint">
 - Chrome === &quot;[object HTMLDocument]&quot;
 - Firefox === &quot;[object HTMLDocument]&quot;
 - Safari === &quot;[object HTMLDocument]&quot;
 - IE &lt;=10 === &quot;[object Document]&quot;
 - IE 11 === &quot;[object HTMLDocument]&quot;
 - IE Edge &lt;=13 === &quot;[object HTMLDocument]&quot;
! Spec Conformance
(https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
Test:</code>Object.prototype.toString.call(navigator.mimeTypes)<code class="prettyprint">
 - IE &lt;=10 === &quot;[object MSMimeTypesCollection]&quot;
! Spec Conformance
(https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
Test: `Object.prototype.toString.call(navigator.plugins)</code>
 - IE &lt;=10 === &ldquo;[object MSPluginsCollection]&rdquo;
! Spec Conformance
(https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
WhatWG HTML$4.4.4 - The <code class="prettyprint">blockquote</code> element - Interface <code class="prettyprint">HTMLQuoteElement</code>
Test: <code class="prettyprint">Object.prototype.toString.call(document.createElement(&#39;blockquote&#39;))</code><code class="prettyprint">
 - IE &lt;=10 === &quot;[object HTMLBlockElement]&quot;
! Spec Conformance
(https://html.spec.whatwg.org/#htmltabledatacellelement)
WhatWG HTML$4.9.9 - The</code>td<code class="prettyprint">element - Interface</code>HTMLTableDataCellElement<code class="prettyprint">
Note: Most browsers currently adher to the W3C DOM Level 2 spec
      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
      which suggests that browsers should use HTMLTableCellElement for
      both TD and TH elements. WhatWG separates these.
Test: Object.prototype.toString.call(document.createElement(&#39;td&#39;))
 - Chrome === &quot;[object HTMLTableCellElement]&quot;
 - Firefox === &quot;[object HTMLTableCellElement]&quot;
 - Safari === &quot;[object HTMLTableCellElement]&quot;
! Spec Conformance
(https://html.spec.whatwg.org/#htmltableheadercellelement)
WhatWG HTML$4.9.9 - The</code>td<code class="prettyprint">element - Interface</code>HTMLTableHeaderCellElement<code class="prettyprint">
Note: Most browsers currently adher to the W3C DOM Level 2 spec
      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
      which suggests that browsers should use HTMLTableCellElement for
      both TD and TH elements. WhatWG separates these.
Test: Object.prototype.toString.call(document.createElement(&#39;th&#39;))
 - Chrome === &quot;[object HTMLTableCellElement]&quot;
 - Firefox === &quot;[object HTMLTableCellElement]&quot;
 - Safari === &quot;[object HTMLTableCellElement]&quot;
! Speed optimisation
Pre:
  Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
  Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
  Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
  Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
  Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
  Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
  Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
  Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
  Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
Post:
  Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
  Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
  Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
  Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
  Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
  Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
  Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
  Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
  Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
! Speed optimisation
Pre:
  regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
  regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
Post:
  regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
  regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
! Speed optimisation
Pre:
  date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
Post:
  date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be &quot;Promise&quot;:
Test:</code>Object.prototype.toString.call(Promise.resolve())<code class="prettyprint">
 - Chrome &lt;=47 === &quot;[object Object]&quot;
 - Edge &lt;=20 === &quot;[object Object]&quot;
 - Firefox 29-Latest === &quot;[object Promise]&quot;
 - Safari 7.1-Latest === &quot;[object Promise]&quot;
! Speed optimisation
Pre:
  set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
Post:
  set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
! Speed optimisation
Pre:
  map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
Post:
  map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
! Speed optimisation
Pre:
  weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
Post:
  weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
! Speed optimisation
Pre:
  weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
Post:
  weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be &quot;DataView&quot;:
Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))</code>
 - Edge &lt;=13 === &ldquo;[object Object]&rdquo;
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be &ldquo;Map Iterator&rdquo;:
Test: <code class="prettyprint">Object.prototype.toString.call(new Map().entries())</code><code class="prettyprint">
 - Edge &lt;=13 === &quot;[object Object]&quot;
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be &quot;Set Iterator&quot;:
Test:</code>Object.prototype.toString.call(new Set().entries())<code class="prettyprint">
 - Edge &lt;=13 === &quot;[object Object]&quot;
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be &quot;Array Iterator&quot;:
Test: `Object.prototype.toString.call([][Symbol.iterator]())</code>
 - Edge &lt;=13 === &ldquo;[object Object]&rdquo;
! Spec Conformance
(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be &ldquo;String Iterator&rdquo;:
Test: <code class="prettyprint">Object.prototype.toString.call(&#39;&#39;[Symbol.iterator]())</code>`
 - Edge &lt;=13 === &ldquo;[object Object]&rdquo;
! Speed optimisation
Pre:
  object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
Post:
  object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)</p>
<pre class="highlight ruby tab-ruby"><code><span class="nb">require</span> <span class="s1">'kittn'</span>

<span class="n">api</span> <span class="o">=</span> <span class="no">Kittn</span><span class="o">::</span><span class="no">APIClient</span><span class="p">.</span><span class="nf">authorize!</span><span class="p">(</span><span class="s1">'meowmeowmeow'</span><span class="p">)</span>
</code></pre><pre class="highlight python tab-python"><code><span class="kn">import</span> <span class="nn">kittn</span>

<span class="n">api</span> <span class="o">=</span> <span class="n">kittn</span><span class="o">.</span><span class="n">authorize</span><span class="p">(</span><span class="s">'meowmeowmeow'</span><span class="p">)</span>
</code></pre><pre class="highlight shell tab-shell"><code><span class="c"># With shell, you can just pass the correct header with each request</span>
curl <span class="s2">"api_endpoint_here"</span>
  -H <span class="s2">"Authorization: meowmeowmeow"</span>
</code></pre><pre class="highlight javascript tab-javascript"><code><span class="kr">const</span> <span class="nx">kittn</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'kittn'</span><span class="p">);</span>

<span class="kd">let</span> <span class="nx">api</span> <span class="o">=</span> <span class="nx">kittn</span><span class="p">.</span><span class="nx">authorize</span><span class="p">(</span><span class="s1">'meowmeowmeow'</span><span class="p">);</span>
</code></pre>
<blockquote>
<p>Make sure to replace <code class="prettyprint">meowmeowmeow</code> with your API key.</p>
</blockquote>

<p>Kittn uses API keys to allow access to the API. You can register a new Kittn API key at our <a href="http://example.com/developers">developer portal</a>.</p>

<p>Kittn expects for the API key to be included in all API requests to the server in a header that looks like the following:</p>

<p><code class="prettyprint">Authorization: meowmeowmeow</code></p>

<aside class="notice">
You must replace <code>meowmeowmeow</code> with your personal API key.
</aside>

<h1 id="kittens">Kittens</h1>

<h2 id="get-all-kittens">Get All Kittens</h2>
<pre class="highlight ruby tab-ruby"><code><span class="nb">require</span> <span class="s1">'kittn'</span>

<span class="n">api</span> <span class="o">=</span> <span class="no">Kittn</span><span class="o">::</span><span class="no">APIClient</span><span class="p">.</span><span class="nf">authorize!</span><span class="p">(</span><span class="s1">'meowmeowmeow'</span><span class="p">)</span>
<span class="n">api</span><span class="p">.</span><span class="nf">kittens</span><span class="p">.</span><span class="nf">get</span>
</code></pre><pre class="highlight python tab-python"><code><span class="kn">import</span> <span class="nn">kittn</span>

<span class="n">api</span> <span class="o">=</span> <span class="n">kittn</span><span class="o">.</span><span class="n">authorize</span><span class="p">(</span><span class="s">'meowmeowmeow'</span><span class="p">)</span>
<span class="n">api</span><span class="o">.</span><span class="n">kittens</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</code></pre><pre class="highlight shell tab-shell"><code>curl <span class="s2">"http://example.com/api/kittens"</span>
  -H <span class="s2">"Authorization: meowmeowmeow"</span>
</code></pre><pre class="highlight javascript tab-javascript"><code><span class="kr">const</span> <span class="nx">kittn</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'kittn'</span><span class="p">);</span>

<span class="kd">let</span> <span class="nx">api</span> <span class="o">=</span> <span class="nx">kittn</span><span class="p">.</span><span class="nx">authorize</span><span class="p">(</span><span class="s1">'meowmeowmeow'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">kittens</span> <span class="o">=</span> <span class="nx">api</span><span class="p">.</span><span class="nx">kittens</span><span class="p">.</span><span class="nx">get</span><span class="p">();</span>
</code></pre>
<blockquote>
<p>The above command returns JSON structured like this:</p>
</blockquote>
<pre class="highlight json tab-json"><code><span class="p">[</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="s2">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Fluffums"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"breed"</span><span class="p">:</span><span class="w"> </span><span class="s2">"calico"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"fluffiness"</span><span class="p">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w">
    </span><span class="s2">"cuteness"</span><span class="p">:</span><span class="w"> </span><span class="mi">7</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="s2">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
    </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Max"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"breed"</span><span class="p">:</span><span class="w"> </span><span class="s2">"unknown"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"fluffiness"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
    </span><span class="s2">"cuteness"</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre>
<p>This endpoint retrieves all kittens.</p>

<h3 id="http-request">HTTP Request</h3>

<p><code class="prettyprint">GET http://example.com/api/kittens</code></p>

<h3 id="query-parameters">Query Parameters</h3>

<table><thead>
<tr>
<th>Parameter</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>include_cats</td>
<td>false</td>
<td>If set to true, the result will also include cats.</td>
</tr>
<tr>
<td>available</td>
<td>true</td>
<td>If set to false, the result will include kittens that have already been adopted.</td>
</tr>
</tbody></table>

<aside class="success">
Remember — a happy kitten is an authenticated kitten!
</aside>

<h2 id="get-a-specific-kitten">Get a Specific Kitten</h2>
<pre class="highlight ruby tab-ruby"><code><span class="nb">require</span> <span class="s1">'kittn'</span>

<span class="n">api</span> <span class="o">=</span> <span class="no">Kittn</span><span class="o">::</span><span class="no">APIClient</span><span class="p">.</span><span class="nf">authorize!</span><span class="p">(</span><span class="s1">'meowmeowmeow'</span><span class="p">)</span>
<span class="n">api</span><span class="p">.</span><span class="nf">kittens</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre><pre class="highlight python tab-python"><code><span class="kn">import</span> <span class="nn">kittn</span>

<span class="n">api</span> <span class="o">=</span> <span class="n">kittn</span><span class="o">.</span><span class="n">authorize</span><span class="p">(</span><span class="s">'meowmeowmeow'</span><span class="p">)</span>
<span class="n">api</span><span class="o">.</span><span class="n">kittens</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre><pre class="highlight shell tab-shell"><code>curl <span class="s2">"http://example.com/api/kittens/2"</span>
  -H <span class="s2">"Authorization: meowmeowmeow"</span>
</code></pre><pre class="highlight javascript tab-javascript"><code><span class="kr">const</span> <span class="nx">kittn</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'kittn'</span><span class="p">);</span>

<span class="kd">let</span> <span class="nx">api</span> <span class="o">=</span> <span class="nx">kittn</span><span class="p">.</span><span class="nx">authorize</span><span class="p">(</span><span class="s1">'meowmeowmeow'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">max</span> <span class="o">=</span> <span class="nx">api</span><span class="p">.</span><span class="nx">kittens</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</code></pre>
<blockquote>
<p>The above command returns JSON structured like this:</p>
</blockquote>
<pre class="highlight json tab-json"><code><span class="p">{</span><span class="w">
  </span><span class="s2">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
  </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Max"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"breed"</span><span class="p">:</span><span class="w"> </span><span class="s2">"unknown"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"fluffiness"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
  </span><span class="s2">"cuteness"</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
<p>This endpoint retrieves a specific kitten.</p>

<aside class="warning">Inside HTML code blocks like this one, you can&rsquo;t use Markdown, so use <code>&lt;code&gt;</code> blocks to denote code.</aside>

<h3 id="http-request">HTTP Request</h3>

<p><code class="prettyprint">GET http://example.com/kittens/&lt;ID&gt;</code></p>

<h3 id="url-parameters">URL Parameters</h3>

<table><thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>ID</td>
<td>The ID of the kitten to retrieve</td>
</tr>
</tbody></table>

          <h1 id="errors">Errors</h1>

<aside class="notice">This error section is stored in a separate file in `includes/_errors.md`. Slate allows you to optionally separate out your docs into many files&hellip;just save them to the `includes` folder and add them to the top of your `index.md`&lsquo;s frontmatter. Files are included in the order listed.</aside>

<p>The Kittn API uses the following error codes:</p>

<table><thead>
<tr>
<th>Error Code</th>
<th>Meaning</th>
</tr>
</thead><tbody>
<tr>
<td>400</td>
<td>Bad Request &ndash; Your request sucks</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized &ndash; Your API key is wrong</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden &ndash; The kitten requested is hidden for administrators only</td>
</tr>
<tr>
<td>404</td>
<td>Not Found &ndash; The specified kitten could not be found</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed &ndash; You tried to access a kitten with an invalid method</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable &ndash; You requested a format that isn&rsquo;t json</td>
</tr>
<tr>
<td>410</td>
<td>Gone &ndash; The kitten requested has been removed from our servers</td>
</tr>
<tr>
<td>418</td>
<td>I&rsquo;m a teapot</td>
</tr>
<tr>
<td>429</td>
<td>Too Many Requests &ndash; You&rsquo;re requesting too many kittens! Slow down!</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error &ndash; We had a problem with our server. Try again later.</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable &ndash; We&rsquo;re temporarily offline for maintenance. Please try again later.</td>
</tr>
</tbody></table>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="shell">shell</a>
                <a href="#" data-language-name="ruby">ruby</a>
                <a href="#" data-language-name="python">python</a>
                <a href="#" data-language-name="javascript">javascript</a>
          </div>
      </div>
    </div>
  </body>
</html>
